MANUTENÇÃO ADITIVA:

PARA INSTRUCOES DO PROJETO:
	-----> NOTAÇÃO URGENTE: parametros de função são sempre por referencia: se mudar no metodo, a mudança refletirá
	no objeto parametro. Use objetos dentro do metodo, atribuindo com o objeto parametro, e daí fazer o processo.
	-----> NOTACAO URGENTE: o codigo em arquivo deve ser carregado pela classe [ParserAFile], pois contem processamento de comentários e processamento de [Module] (module).
					----> nomes de modulos deve ter o mesmo nome do arquivo que contem o modulo, incluindo subdiretorios.
					----> nomes de modulos devem estar entre parenteses, porque nomes podem ter espaçoes em branco.

   -----> UTILIZACAO DE instrucoes: Module, Library:
					----> Module deve conter o nome do arquivo de codigo do modulo, incluindo extensoes.
					---> Library deve conter o nome do arquivo da classe library, e especificar o nome da classe da library.


	------> especialização em POO:
			-----> todos metodos tem um escopo, definido na compilação. Do jeito que está,
			não está claro esta questão: há escopo de uma classe, mas não há garantia que
			haja criação de um sub-escopo, para um método. Há sub-escopos para blocos de código...

			----> definição de tipos de tokens.
					----> para operadores, verificar se o haja em uma das classes
					dos operandos! Isto garante que haja operador para os tipos de objetos
					da expressão...

			---->  refatoração da classe Expressao, com os tipos de tokens definidos...
					----> tokens podem ser objetos, chamadas de funções (verificar
					no escopo a existência de nome de objeto, e nome de função, e nome de operadores, 
					e numeros...

			---> extensão do operador vetorial "[]", dentro da classe currente,  que estende
			os vetores com um método especializado para este operador...

			-----> extrator de cabeçalhos de classes! Auxilia no processamento de expressões.


	----> a versão anterior começou com programação estruturada, sem classes,
		  o que dificultou a modelagem para construção de classes...

	----> verificar se há os termos-chave "true", "false". Se não, implementar.
______________________________________________________________________________________________________________________________________________________________________________________
PRODUCT BACKLOG:

[novas funcionalidades]:
		ANOTAÇÃO: um metodo-parametro deve ser chamada com uma expressao chamada de metodo, que contém o nome do metodo, a classe, e os parametros do metodo-parametro.
		ANOTAÇÃO: um parametro multi-argumento, na definicao do metodo, comeca com o operador [!], seguido de um objeto do tipo Vector, que
		contera os dados em quantidade variavel. Um multi-argumento não pode estar vizinho de outros parametro com o mesmo tipo do multi-argumento,
		pois se fosse, haveria confusão de qual parametro, um parametro do multi-argumento pertenceria.


		----> (feito) FORMAR HEADERS (semelhante a arquivos .h em C++), a fim de na construção de Expressões, sabe-se exatamente todas classes, com seus métodos e propriedades e operadores,
		tornando mais fácil a extração dos tokens de uma expressão.
								-----> processamento de classes herdadas, deserdadas, na formação de métodos, propriedades, operadores herdados/deserdados.
								-----> para cada "caso de uso" de headers, construir um método que defina os nomes, como nomes de classe, nomes de metodos, tipos de retorno de metodos, etc...
								-----> codificação, testes feitos.


		----> (feito)refatorar a classe "Expressao", com todos tokens já com uma classificação de tokens.
								----> (feito com uma classe especifica de "ExpressaoOperator", com busca de operadores compativeis, e tipo de operador (binario, unario).
								com relação aos operadores presentes numa expressão, fazer uma varredura entre as classes dos operandos, para encontrar	um operador compatível com o operador presente na expressão. 

								----> testes feitos para ExpressaoOperador, ExpressaoObjeto, ExpressaoPropriedadeAninhada (caso simples), ExpressaoMetodosAninhados (caso simples, não há suporte para metodos estaticos).

								----> integrar a nova classe Expressao, no projeto...
													----> nova classe Expressao muito mais robusta, com verificação de operadores de classe, tipo da expressão, que era um pesadelo, foram feitas.



		----> (fixado) verificar se escopo de metodos está operacional, podendo acessar todas variaveis dentro do codigo do metodo. Tem que haver
			  um escopo para cada metodo, clonado e feito o processamento do metodo, junto com as propriedades do objeto da classe do metodo.
								----> a ligação de escopo-pai & escopos-folhas estava incompleta.	
								----> ligação de escopos de método && escopo de classe fixado.


		-----> (feito) primeiras bibliotecas ("read","write", linha de argumentos CLI, na classe "Prompt").
								-----> lembrando C/C++, muito se faz com "printf", "scanf", não vai desanimar.

			  
		----> (feito) codificar em forma de expressoes regex, as strings identificadoras de cabecalhos.  Após, se sucesso à codificacao, codificar tanbém
			  as strings identificadoras da classe ProcessadorID.

		----> (A FAZER) passagens de cabecalho de funções como argumento para outros métodos....
						é "só" acrescentar no corpo do método a execução da função parâmetro,
						tendo as especificações de acordo com os dados do método passada como parãmetro....
										-----> uma estrutura de dados que informa o nome do método, a classe do metodo, é passada como parâmetro, 
											   o que possibilita a execução de "chamadas de método".
										
										-----> uma estrutura de dados específica, com nome do método, classe do método, com/sem objeto para a chamada de método.
										
		-----> (sendo feito) uma biblioteca para manipulação de arquivos texto: open, close, write, read (read/write com sobrecarga de métodos, para compor com leitura de um caracter, uma linha inteira).
										-----> esta biblioteca é prioritária.
		

		----> (feito, classes são abertas para incluir metodos, propriedades, operadores): EXTENSÕES DE CLASSES: operadores, métodos podem ser inseridos, segundo uma instrução (a codificar),
		por exemplo, se importar uma classe como "Matriz", pode-se com esta instrução adicionar operadores nesta classe! (extensão).
		É fácil! é só cuidar da inserção do operador, método, na lista de operadores da classe, que já existe. lista de métodos de uma classe 
		também já existe. Classes importadas são convertidas em classes orquidea, e nesta conversão, pode-se inserir operadores/metodos.
										----> complexidade: 3; relevância: 8. mudança aprovada pela simplicidade de implementar.

		----> (feito, para classes string, e double (operações matemáticas)): Métodos básico para classes "int","float","double", "string", "char", como "float.ToInt()", "string.Lenght()", ....
			  do jeito que está, somente com operadores, não se tem "casting", manipulação de "strings", operações de alta relevância para uma linguagem..
										----> em por certo, manipulação de string, que muitas linguagens modernas dão enfase por causa da Internet, com processamento de textos;
										
		----> (feito) com a tecnica de objeto ficticio para fazer uma chamada de metodo, é possivel transformar qualquer metodo em metodo estático!!!								
		

		---> (começo com a classe "Library") INSTRUÇÃO DE IMPORTAR BIBLIOTECAS NO CODIGO: bibliotecas são adicionadas aos headers de expressao, via repositorio de classes.
			  
		
		(feito para 4 novos tipos de estruturas de dados Wrapper, podendo escalar industrialmente.
		(feito) mudança:  QUALQUER ESTRUTURA DE DADOS, NUM FORMATO, TENDO UM WRAPPER QUE CONVERTE O FORMATO DA ESTRUTURA PARA ACESSO A UMA CLASSE, DA CLASSE BASE OU DA LINGUAGEM
		ORQUIDEA!!!
		-----> exemplos:
					----> formato dicionario Python [,], ou Javascript { : }.
					----> formato vetor <,,,,> da matemática.
					-----> formato matricial [,,,] que foi a base para esta ideia: uma classe que implementar uma interface "matriz",
					       mas interpretado como um texto diferenciado, como B[1,5]...
					
					-----> o interessante é que em diversas lingugens, como Python, Javascript,as sintaxes para estrutura de dados é a mesma.
					Faz-se o desenvolvedor confortado, ao aprender uma nova linguagem de programação, com o conhecimento de outras linguagens.
					
					
		----> mudança aprovada, agrega valor à linguagem, em seu aspecto simples quanto a tipos de estrutura de dados (currentemente apenas uma classe, "Objeto",
			  podendo formar estrutura de dados na forma de dados simbolicos.
		
		
		
					-----> planejamento do "WrapperData":
								----> a ideia é ter uma estrutura de dados, mas acessível por um formato proprio.
											----> por exemplo, a estrutura "Matriz", tem que ser acessado em algo como "Matriz.GetElement(1,1)",
												  com o "Wrapper", o acesso é "Matriz[1,1]", ou seja um formato de sintaxe especifica, estendendo a 
												  sintaxe da linguagem, quanto a estruturas de dados.
															----> é feito uma substituição de ExpressaoObjeto "Matriz[1,1]", para uma ExpressaoChamadaDeMetodo "Matriz.GetElement(1,1)",
															implementando então uma parte do "WrapperData"....
															----> para uma atribuição "x=Matriz[1,1]", é feito uma substituição da expressão de atribuição, para "x.SetElement(Matriz, 1,1)".

			
								-----> formato do "WrappeData":
												-----> um token-chave "var", para identificar objetos do "WrappeData".
												-----> um nome para o objeto "Wrapper".
												-----> uma string do tipo "Regex": "formatoExpressao", para reconhecer o objeto como o "Wrapper" currente.
												-----> uma classe "classeWrapperData" que guarda os dados do "WrapperData",
														
															
												-----> métodos:							
															-----> um metodo SetElement(id,...), e SetElement(express,...), para setar objetos do tipo: "var id = formatoExpressao(objetoParametro1,..)".
																   este metodo constroi o objeto especificado.
																				----> este método não necessariamente deva ser implementado, pois uma expressão
																				de instanciação de objeto tem extensão para uma chamada de metodo, feita com "GetElement()".

											
															-----> um metodo GetElement(id, id,...), e GetElement(express,...), para obter dados de um objeto da estrutura de dados "WrappeData".
								
															-----> metodos de inserção de texto no codigo, via expresoes chamadas de metodo,
															escritas pelo metodo de inserção. ex.: "M[1,1]", será "M.GetElement(1,1)", este
															codigo será inserido via expressoes. não está claro ainda como será feito
															a pre-compilação, ou mesmo a inserção por instruções de chamadas de metodo.
																			----->  mas se o codigo for carregado em arquivo,
																			pode-se durante a leitura, fazer o processamento de WrappersData,
																			como ex.: o descrito para "M[1,1]" se tornando codigo como "M.GetElement(1,1)".
											
								-----> anotações:			
												-----> implementar a instanciação de objetos, como uma "Expressao".			
												-----> e uma Expressao específica, (ExpresssaoWrapperData: Expressao)..., que fará a substituição da expressão da sintaxe
												do "WrapperData" para uma "ExpressaoChamadaDeMetodo",  metodos: GetElement(), SetElement(), do "Wrapper".
												
												
												
								-----> expressões regex para um "WrappeData" de vetores: "var id = < exprss [,exprss] >"!, se match, gera um construtor de vetores.
								então, outra expressao regex para obter dado: "id_obj<exprss[, exprss]> = exprss", se match, gera uma chamada de método 
								"id_obj.SetElement(exprss,...);", que é inserida no processamento de expressões..., e para id=id_obj<exprss [,exprss], uma
								atribuição e uma chamada de método id=id_obj.GetElement(exprss,...);
												-----> 3 expressões regex, uma para instanciar (construtor), outra para acessar (get) , outra para setar (set).


												
												
		------->  (feito) estendendo, "WrapperImportObject", fornecendo uma interface (classe abstrata), e tipo de expressão específica para instanciar/setar/ler/executar um objeto "WrapperImport".
		-------> (feito):					
					---> ESTUDO PARA "WRAPPERDATA" para JaggedArrarys (feito)
					---> ESTUDO PARA "WRAPPERDATA" para vetor; (feito)
					---> ESTUDO PARA "WRAPPERDATA" para matriz; (CODIFICANDO).
					---> ESTUDO PARA "WRAPPERDATA" para dicionario (feito).
					---> ESTUDO PARA "WRAPPERDATA" para lista; (A FAZER).
					



[NOVAS INSTRUÇÕES ORQUIDEA]:
			-----> (A PLANEJAR) um insight: instruções em forma de uma chamada de função! Entrada o objeto que chamou a instrução-função, e saída
			o objeto modificado pela função. Evita escrever toda vez que criar uma instrução, um novo método na VM...

[NOVAS MUDANÇAS NO PROUCT BACKLOG] (feito, faltando a verificação da inclusão da funcao-parametro para dentro do escopo do metoo principal):
			----> nova funcionalidade: multi-argumentos! Um metodo pode ter varios  multi-argumentos, desde que verificando que o próximo argumento (multi-argumentos ou nao)
			nao seja do mesmo tipo do argumento anterior, para nao incorrer de registrar um parametro multi-argumento, com o proximo parametro multi-argumeento ou não.
			----> a implementação:
								----> em headers, acrescentar o operador: [....], que sinaliza que o arqumento é multi-argumentos.
								----> em UtilsTokens.GetMethodCompatible(), verificar a passagem pelos multi-argumentos.

			----> funcoes parametros! bastando incluir no metodo de encontrar funcoes compativeis, uma olhada no escopo,funcoes,
			se tiver, valida o parametro.

Novas Anotacoes:			
			[Projeto]:
			[VERIFICACAO]: legal ver o compilador esta funcionando com a nova classe [ExpressaoGrupos] integrada ao seu codigo.

			[PRATICAS DE PROGRAMAÇÃO]:
						----> NAO foi boa ideia de codificar sem condensar trechos de codigo em metodos separados, apesar de deixar mais "claro" o que o codigo está fazendo,
						repetições de trechos de codigo iguais, se fixar em um trecho, todos os outros também terão que ser fixados.
						Alem, aumenta e muito o tamanho do metodo, tornando dificil seguir a programacao estruturada do codigo...

			[FUNCIONALIDADES NOVAS, MUDANCA APROVADA]:
						----> (feito) nova funcionalidade: multi-argumentos! Um metodo pode ter varios  multi-argumentos, desde que verificando que o próximo argumento (multi-argumentos ou nao)
						nao seja do mesmo tipo do argumento anterior, para nao incorrer de registrar um parametro multi-argumento, com o proximo parametro multi-argumeento ou não.
									----> a implementação:
														----> em headers, acrescentar o operador: [....], que sinaliza que o arqumento é multi-argumentos.
														----> em UtilsTokens.GetMethodCompatible(), verificar a passagem pelos multi-argumentos.

						----> (feito, mas verfiicar a inclusao do metodo-parametro para dentro do escopo do metodo principal) funcoes parametros! bastando incluir no metodo de encontrar funcoes compativeis, uma olhada no escopo,funcoes,
						se tiver, valida o parametro.

ANOTAÇÃO: um metodo-parametro deve ser chamada com uma expressao chamada de metodo, que contém o nome do metodo, a classe, e os parametros do metodo-parametro.
ANOTAÇÃO: um parametro multi-argumento, na definicao do metodo, comeca com o operador [!], seguido de um objeto do tipo Vector, que
contera os dados em quantidade variavel. Um multi-argumento não pode estar vizinho de outros parametro com o mesmo tipo do multi-argumento,
pois se fosse, haveria confusão de qual parametro, um parametro do multi-argumento pertenceria.

[WrapperData]: codigo de nome, e tipo de wrapper, dependente de outros tipos de wrapper. acrescimos de novos
tipos de wrapper data será preciso revisar todos codigos de wrapper data object!
			

					
__________________________________________________________________________________________________________________________________________________________________________________________________
SPRINT RESTROPECTIVE: ANOTAÇÕES:

		------> (BOA PRATICA DE PROGRAMAÇÃO). Tão logo os testes unitarios ficarem prontos, para cada modificação no código deve-se
				executar todos os testes, evitando efeitos colaterais de "quebrar o código"...

		------> (BOAS PRATICAS DE PROGRAMAÇÃO): a codificação com testes de pequenos incrementos, como se faz em desenvolvimento de jogos, junto com massa de testes específicos,
				e também testes "caixa-preta" sem muita depuração, salvou o dia.

		------> (BOAS PRATICAS DE PROGRAMAÇÃO): quanto menos uso do depurador (modo debug do codigo),
		melhor, porque a cada iteração que falha, há a oportunidade de aprender mais a atenção de como o codigo foi escrito.

		------> (BOAS PRATICAS DE PROGRAMAÇÃO): testes com validação entre um bloco try/catch é muito importante ademais,
		porque a validação não quebra a execução de outros testes, além de permitir testar apenas a validação precisa,
		sem codificar cautelas de assercoes até chegar na validação necessário.

		
___________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.07:

		----> codificado classe "FileHeader", que compões o cabeçalho de classe, semelhante a arquivos .h em C/C++.
				----> codificado classe de testes para "FileHeader".
								-----> (fixado, testes) testes feitos para um "HeaderProperty".
		
								----->  teste para um "HeaderMethod", faltando a extração de todos tokens do método.
														-----> processamento de match para "HeaderMethod", sucedido.
														-----> (feito) testar a formula de contagem de tokens do metodo...


				----> (fixado) fixar os tokens da classe, só está contando os tokens do corpo da classe.


				----> na passagem de um cenario de teste para outro, o "HeaderMethod" está com os tokens do "HeaderProperty" anterior!!!!.
						---> uma infeliz coincidência os indices dos casos de uso nos cenarios de testes, são vizinhos, e um erro na contagem de indice,
						que é um assunto espinhoso, gerou a inconsistência verificada.
													----> sanado a incongruência... faltante o calculo dos tokens de um hearderMethod.
																----> fixado, por dando o nome certo às variáveis, havia uma diferença entre indice (começa com 0), e Count (começa com 1, não vazio).


				----> faltou um detalhe: transformar os IDs em nomes de classe, nome de propriedades, nome de metodos, nome de operadores.
								----> codificado metodos para conversao de dados de  headers, e campos de dados para headers de propriedade, headers de metodos, e headers de operadores;
								----> RETESTAR TODOS CENÁRIOS DE TESTES, ANTE A MODIFICAÇÕES NO CODIGO.

____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.07:
			----> (codificado) completar a classe "HeaderMethod", na extração de parâmetros de um metodo.
								---> codificado a extração de parametros de um header method.
												----> há uma extensão, que é o parametro de metodo for uma assinatura de função.


			----> (fixado) RETESTAR TODOS CENÁRIOS DE TESTES, ANTE A MODIFICAÇÕES NO CODIGO.
								----> testes para "HeaderProperty", não está havendo o processamento dos dados do header. (fixado).
								----> testes para "HeaderMethod", não está havendo processamento dos dados do header. (fixado).
												---> atualizar o "HeaderOperator", após fixar o "HeaderMethod". (feito).




			----> (codificado) codificar nos cabeçalhos de classes as classes herdadas, deserdadas.
								----> codificado a extração de nome de classes herdadas e deserdadas.
								----> codificado o processamento de inclusão/exclusão de herança/deserança de métodos, propriedades, operadores.


			----> (codificar) a extração de cabeçalhos de classes no RepositorioDeClasses, extendendo os cabeçalhos a todas classes da linguagem.						
								----> (fixar) a inclusão de herança em cabecalhos de classes. 
												----> a falha está no processamento de uma segunda classe, no mesmo cenario de teste.
																	----> fixado um erro de indices, mas as propriedades da segunda classe não estão sendo extraidas.
								----> (fixar) a extração de uma segunda classe, no cenario de testes com duas classes.
												----> falha grave fixada, no processamento de casos de uso...
												----> o metodo "Match" com a codificação refeita, quebrou!!
																	----> (fixado) o erro de indices, no método "Match". 
												


			----> (feito) testes mais complexos para classe "FileHeader".
								----> testes com tres propriedades, teste com dois metodos em uma classe, feito.
												----> testes com uma classe+ uma propriedade, e uma classe + um metodo, feitos.								
												----> testes com uma classe + tres propriedades, e uma classe + 2 metodos feitos.
						

____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.07:

			----> testes para "FileHeader", composição de herança, deserança.
								---> na extração de tokens classe, não está extraindo tokens-nome de herança.
												------> na extração de tokens, não está avançando o ponteiro de "beginTokensClasse"...
																-----> erro no sequenciamento de passos.
																-----> fixado no espinheiro de indices, a extração de classes herdadas, e deserdadas.
																				----> testes para herança, feitos.

			----> codificar testes para "HeaderOperator".

		   -----> codificação de método de composição de "headerClass" a partir de objetos "Classe", na linguagem orquidea.
								----> codificado metodo para extração de header, de classes do repositorio de classes.
								----> testes, mas as classes basicas so tinham operadores, que foram registrados nos headers....
																----> melhoria na visualização debug, para textos ToString() para todos headers.

								----> codificar um cenario de teste, que importe classes com a instrução "importer", para
									  verificar a extração de classes a partir de um assembly.
																---->testes feitos, está extraindo headers, mas parece que
																     os parâmetros dos métodos não estão sendo processados.

							    ----> VERIFICAR COM UMA CLASSE APENAS, SE OS PARÂMETROS DOS MÉTODOS DA CLASSE ESTÃO
								SENDO EXTRAÍDOS.
																---> não estão sendo extraídos os parametros. (fixado).

								----> completar o cenario de teste para automatizado, para verificação se o codigo quebrou,
								      quando se modifica o codigo. (feito).
_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.07:

		----> refatorar a classe "Expressao", com todos tokens já com uma classificação de tokens.
								----> com relação aos operadores presentes numa expressão, fazer uma varredura entre as classes dos operandos, para encontrar
								um operador compatível com o operador presente na expressão.


		----> planejamento da refatoração da classe "Expressao":

					um termo de uma expressao (sub-expressao) pode ser:
								---> uma variavel.

								---> um objeto.
											----> com chamada de uma propriedade.
											----> com uma chamada de metodo.

								---> um numero.
								---> (a codificar) um operador.
								---> parenteses.


					----> (codificado) codificação para casos de uso, para um objeto:
								----> objeto com chamada de propriedade, com possibilidade de encadeamento de propriedades.
								----> objeto com chamada de metodo, com possibilidade de encadeamanento de chamadas de metodo.
								----> caso em que não há propriedade ou chamada de metodo na aparição de um objeto.

					----> codificado expressao para numero.
					----> codificado expressao entre parenteses.



					----> FALTA A VALIDAÇÃO DE ERROS NO PROCESSO DE EXTRAÇÃO DE EXPRESSOES.
_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.07:

					

					----> (codificado) codificar a expressão de ligação "ExpressaoOperador".
									----> incluir a analise do operador, e se for binario, extrair o proximo ExpressaoObjeto.
	
					----> (codficado em expressaoObjeto, expressaoPropriedades, ExpressaoObjetoChamadaDeMetodos, expressaoEntreParenteses)
					      modificar todas expressões refatoradas, para compor a expressão extraida, diretamente nas sub-Expressoes da expressão currente.


					---> (codificado) codificação atual: encontra propriedades aninhadas (somente propriedades), ou chamada de metodos aninhadas (somente chamadas).
									---> (atualizacao): expressoes chamadasMetodoAninhadas, e propriedadesAninhadas não são processadas diretamente, utiliza-se a expressaoObjeto
									     para extrarir tanto propriedades quanto metodos, aninhados ou não.

					---> (codificado) codificação de metodos "ToString()" para todos tipos de expressão, para fins de impressão em depuração, ou descrição da expressão, em seus tokens. 

					----> (em planejamento) um tipo de expressão que processe operadores duplos, como "[]".
									---> o operador duplo "[]" é um operador, mas com lista variavel de operandos (parâmetros do vetor).
												---> planejamento por generalização segue nos textos seguintes.


					----> (codificado) codificar o metodo "ExtraiExpressoes", que possui tokens de término de expressão, como: ";"  ou "{", ou "," (mas com pilha de parenteses vazia).


					----> (codificado) incluir na expressaoOperador o tipo de operador, binario, unario, para calculos de avaliação de expressoes, classe EvalExpression.
_________________________________________________________________________________________________________________________________________________________________________________________________________

QUALQUER ESTRUTURA DE DADOS, NUM FORMATO, TENDO UM WRAPPER QUE CONVERTE O FORMATO DA ESTRUTURA PARA ACESSO A UMA CLASSE, DA CLASSE BASE OU DA LINGUAGEM
ORQUIDEA!!!
		-----> exemplos:
					----> formato dicionario Python [,], ou Javascript { : }.
					----> formato vetor <,,,,> da matemática.
					-----> formato matricial [,,,] que foi a base para esta ideia: uma classe que implementar uma interface "matriz",
					       mas interpretado como um texto diferenciado, como B[1,5]...
					
					-----> o interessante é que em diversas lingugens, como Python, Javascript,as sintaxes para estrutura de dados é a mesma.
					Faz-se o desenvolvedor confortado, ao aprender uma nova linguagem de programação, com o conhecimento de outras linguagens.
					
					
		----> mudança aprovada, agrega valor à linguagem, em seu aspecto simples, podendo formar estrutura de dados na forma de dados simbolicos.
		
		

-----> planejamento da interface que converte um schemma de texto, em dados para um wrapper que constroi a estrutra, com a unidade basica da linguagem: Objeto.
						----> GetELement().
						----> SetElement().
						----> acesso de instanciação com o token elemento-chave "var".


_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.07:

			---> testes para instanciação de expressoes refatoradas.
						----> testes fixado a utilização de expressões nulas ou tokens=0;
						----> resultou em expressao com  expressoes objeto, mas FALHA na obtenção do operador "+".
									----> erro a fixar na contagem de tokens de expressao operador.
											---> a falha esta no registro do operador, que é complicado pois envolve tokens
											que ainda não foram processados.
											---> (fixado) fixado, mas os dados do operador não estão aparecendo...
											---> (fixado, o processamento do operando, mas um problema de indices está impedindo o registro posteriormente) o registro do operando 2 não está aparecendo.
																----> fixar o indice de tokens, está ultrapassando o tamanho da lista.
																				---> fixar a obtenção de operadores compativeis, está registrando como unario, deveria ser binario.
																									----> codificado o processamento antecipado do operando 2 da expressão operador.
																									----> para manter a ordem de processamento ("A+B"", e nao "A B +"),
																									insere-se o operador no meio dos operandos.
																									----> fixado o erro de contagem de token: o codigo feito estava para
																									contagem dentro de uma malha de tokens "for", mas a malha é de "while",
																									que não incrementa explicitamente o indice da malha...




			----> (fixado) (verificar) verificar os indices e processamento de operando2 no caso de uso do operador ser unario.
										  ----> do jeito que está, está registrando como operador unario. (antes da ultima fixação).
										  ----> fixado, mas testar: o loop de operadores validos não estava testando todos operadores binarios, passava para os
												operadores unarios no primeiro incremento da malha. Foi acrescido outro loop "for", para operadores unarios.
															----> fixado a classe Header, que não estava registrando o tipo de operador (unario, binario),
															justamente que depois dos testes é que havia inserido o tipo de operador. falha essa foi.




			---> anotar que as classes verificadas está "na linguagem orquidea" + classes "do repositorio de classes".



			---> continuando testes.
									---> o codigo da classe "ProcessadorID" estava quebrado!.
														----> o codigo é muito fixo, tem que ter um acessor para a classe... (nao fixou).
														----> o codigo exige que se tenha pelo menos um construtor. como nao havia, apesar de extrair propriedades corretamente,
														setava para null a classe, por não ter um construtor. (fixado! o codigo há muito tempo não modificado, está funcionando perfeitamente).

									---> verificar se a classe extraida pelo "ProcessadorID", está sendo registrada no repositorio de classes, ou se está apenas no escopo do processador...
														---> nao está registrando no repositorio, mas na lista de classes da linguagem...


									---> o teste é rodado sem erros fatais, mas não está processando a expressao de propriedade aninhada...
														----> falha no processamento de expressoes de chamada de metodo. (fixado, objetos null pipocando).
														----> entrou em loop infinito.... (fixado, mais um erro de contagem de indices em malhas de tokens).
														----> "ExpressaoPropriedadeAninhada" não está funcionando corretamente.

														----> fixado, mesmo erro de contagem de indices em malhas de tokens..


									----> fixado, testes propriedade aninhada feito.



		----> testes para "ExpressaoOperador", "ExpressaoPropriedadesAninhadas" feito, com um cenario de teste cada.

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.07:

		    -----> os testes em sequencia na mesma execução  nao estão passando, de um cenario proximo, há alguma propriedade estática está impedindo o processamento normal.
													----> a classe "ProcessadorID" tem propriedades estáticas...


			-----> testes para chamada de metodos aninhados.
									---> codificacao de testes para expressoes metodos aninhados.
													----> (fixado) fixar: está executando sem erros fatais, porém devolve uma expressão vazia...
													----> (fixar) o codigo está encontrando a expressao, mas não está passando os dados para a expressao encontrada...
																			----> fixado, os nomes do metodo, da classe do metodo e do objeto são encontradas 
																			na expressao objeto, e repassadas para a sub-expressão chamada do método.

													----> testes mais simples, teste passou.
			
		   


			-----> testes para chamada de metodos aninhados, mais complexos.
								----> fixado um erro na extração de dados de um metodo, na classe "FileHeader", mas
								já havia este dados em outros locais do "FileHeader".

								----> há uma pequena confusão quanto ao objeto da chamada de metodo aninhada:
											deve ser o nome da classe, ou uma propriedade da classe???

										---->(A FAZER) retomar os testes, fixando o nome do objeto da chamada de metodo 2, aninhada.
												----> (fixado) CONSTATAÇÃO:  duas chamadas de metodo aninhadas, na chamada 2, o objeto
													           é o nome do retorno da chamada 1, ou seja, o metodo 2 tem que ser estático....
								
												----> é um caso de uso pouco provavel, testar se nao quebrou o codigo e seguir.
															----> não há suporte para propriedades ou metodos estáticos!!!. 
															como nao ha suporte, por enquanto, não há previsão para de 2 ou mais chamadas de metodos aninhados....

		
			-----> testes para chamadas de propriedades aninhadas, mais complexos.
								----> (verificado, está operacional) VERIFICAR URGENTEMENTE SE AS CLASSES EXTRAIDAS TEM ESCOPO DE CLASSE FEITO CORRETAMENTE, pois o codigo ficou sem modificações por 6 meses,
									  e a versão desta branch pode não ser a ultima versão, publicado no GitHub.

								----> o teste passou, mas os dados da 2a. propriedade aninhada não estão sendo registrados.
													---> a verificação de expressao propriedade aninhada está em falha. é um erro de indices, dentro da expressão principal...
								----> (fixado, sabe-se que há duas sub-expressoes ExpressaoPropriedade, então codificou um merge de sub-expressoes) as propriedades aninhadas estão sendo validadas, mas estão em duas sub-expressoes, deveria ser uma sub-expressao somente.
													---> no teste "para cardiacos"(passo a passo), o teste passou, resultando uma sub-expressao da expressao principal, mais uma sub-expressao dentro da sub-expressao da expressao principal...

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.07 ---> 21.07:

			-----> planejamento do "WrapperData":
								----> a ideia é ter uma estrutura de dados, mas acessível por um formato proprio.
											----> por exemplo, a estrutura "Matriz", tem que ser acessado em algo como "Matriz.GetElement(1,1)",
												  com o "Wrapper", o acesso é "Matriz[1,1]", ou seja um formato de sintaxe especifica, estendendo a 
												  sintaxe da linguagem, quanto a estruturas de dados.
			
								-----> formato do "WrappeData":
												-----> um token-chave "var", para identificar objetos do "WrappeData".
												-----> uma string do tipo "Regex": "formatoExpressao", identificando a sintaxe do acesso à estrutura..
												-----> uma classe "classeWrapperData" que guarda os dados do "WrapperData",
												-----> instanciação: um identificador "id" para ser reconhecido no codigo.
														
															
												-----> métodos:							
															-----> um metodo SetElemento(id,...), e SetElement(express,...), para setar objetos do tipo: "var id = formatoExpressao(objetoParametro1,..)".
																   este metodo constroi o objeto especificado.
											
															-----> um metodo GetElement(id, id,...), e GetElement(express,...), para obter dados de um objeto da estrutura de dados "WrappeData".
								
											
								-----> anotações:			
												-----> talvez seja necessario implantar a instanciação de objetos, como uma "Expressao".			
												-----> e também o reconhecimento como uma Expressao, de cada objeto com sintaxe específica.
												-----> cerca de casos de uso: uma estrutura de dados é utilizada em:
															----> instanciação.
															----> presente em expressões.
															
												
______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.07:

			----> a fim de obter o teste seguinte, foi preciso modificar a obtencao de subExpressao, na ExpressaoObjetoRefatorada...
							----> validar para o teste de propriedades aninhadas, como: a.propriedadeA.propriedadeB;
												----> fixar o merge de sub-expressoes.
															---> é um problema de referencia, ponteiros de objetos.
												----> (fixado) validar o merge.
												----> não se sabe qual o resultado para 3 ou mais propriedades aninhadas...
															----> verificar se é conveniente deixar as propriedades aninhadas mais de 2 como sub-expressões.
															----> a solução foi unir as duas sub-expressoes, na sub-expressao[0], sendo a ultima sub-expressao contendo duas propriedades aninhadas.
																garante que há resultado para 3 ou mais propriedades aninhadas também...


												----> FIXAR URGENTEMENTE os pulos de tokens em "ExpressaoObjetoRefatorada", do jeito que está,
													  pode pegar tokens de outros tipos de expressão, seguidas da "ExpressaoObjetoRefatorada" currente...
																(fixado) com token de termino de expressao [;], retorna, e se não obter objetos atraves de um token, retorna
																também.


												----> E O MERGE DE EXPRESSOES OBJETO, pois pode ocorrer o mesmo problema: tem ser a expressao.cont-2. e nao expressao[0]...
																(fixado), respeita o inicio da expressao objeto, pois pode ter outras expressoes que nao objeto, antes do 
																processamento da expressao objeto currente.




			----> testes para uma propriedade aninhada, seguida de uma chamada de metodo aninhado, é possível e ocorre frequentemente.
												----> fixar: a extração da expressao chamada de metodo não está sendo feita...
														----> não estava passando o nome da classe do objeto.
														----> fixado, testes feito.

			----> teste para uma chamada de metodo, mas com parametros do metodo.
												----> testes feito.


			----> testes para extração de expressoes, metodo Expressao.ExtraSubExpressoes();
								---> (fixado, o codigo do teste é que estava por fixar) fixar o metodo, nao está extraindo as expressoes.
													---> não está sendo extraidos os objetos sem propriedades/chamadas de metodos...
																	----> falha na codificação do cenario de teste! recodificado, o teste passou para extracao de expressoes...



			----> testes para expressao entre parenteses.
								---> stack overflow...
											----> os tokens entre parenteses, nao estava extraindo os parenteses. também não estava atualizando o indexTokens da expressao currente.

								---> fixado, testes feitos.
								
								



			----> teste para uma expressao maior, "a+b-c";
								---> testes feitos.
			
			----> verificar se há processamento para "a=b+c", com o operador "=". Se não houver processamento, criar um novo tipo de expressao.
								---> boas noticias: o operador "=" esta listado para tipos basicos. mas talvez precise implementar em classes não básicas.
												----> (feito) implementar na expressao operador, um operador "=", exceção, para poder calcular a expressão.
												na classe "EvalExpression", o operador está a parte, sendo calculado num caso de uso especializado...


								----> teste para "a=b+c;"
												----> testes feitos. Então,  expressões de atribuição podem ser processadas como uma expressão...
			
			----> teste para "a+b.metodoA()";
								----> (esta validado, o cenario de teste estava validando incorretamente)
								      (fixar) testes, a expressao resultante tem três sub-expressoes, o desejado é uma subExpressao, na expressão teste...
												----> mas a descrição da expressão aparece corretamente, com os dados validados.
												----> inclusive, o formato de sub-expressoes está no formato para avaliador de expressoes (classe EvalExpression).


_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.07:

		----> refatorado a classe de testes de "Expressao", para possibilitar mais testes unitarios, mais focado, e sem repetições de codigo, poupando
			  codigo, esforço, em cada teste unitario.



		----> executado todos testes:
					
					----> (fixar) por alguma razão, a classe do cenario de teste nao está sendo processada corretamente.
											----> nao está carregando as classes basicas! Isto porque foi feito um "clear"
												  nas classes do repositorio e da linguagem, mas o singleton da linguagem
												  não é reinicializado...

											----> está em stack overflow!
											        ----> é um problema de sequenciamento.
													As classes basicas estão sendo apagadas, no metodo de teste.
													----> a situação atual é que as classes dos testes anteriores
													não estão sendo apagadas.

											----> fixado não apagando o RepositorioDeClasses, mas a cada
											instanciação de uma nova classe que tem uma versão anterior,
											a versão anterior é removida, e a nova classe é adicionada.


											----> Não é erro da refatoração dos testes, é um problema de tentar
											executar todos os testes, mas pelo codigo ter propriedades estáticas,
											adicionar classes repetidas é um problema constatado anterioremente.


					----> (fixar) (fixar) teste de "a.propriedadeE.metodoA()" não passou...
											-----> erro de digitação do nome da propriedade, no cenario teste.


					----> (fixar) teste de "a.metodoA().metodoB()" não passou...
											----> erro desconhecido, o escopo nao reconhece o nome de objeto...
															----> um erro pelo desuso de um metodo da TabelaDeValores, que não havia sido testado,
															justamente pela preferência de outro metodo que faz o mesmo codigo.
															----> mais um erro, de codificação no mesmo metodo nao utilizado, fixado...


										-----> pode ser contornado: criar um objeto do mesmo tipo de retorno do "metodoA", e fazer o
										processamento do metodoB(), mas não haverá em tempo de execução extração de propriedades do objeto criado temporariamente,
										mas se o "metodoB()" faz algo fora de suas propriedades internas, a chamada do "metodoB" é viavel.
													----> (implementado) implementar na expressao chamada de metodo, a instanciação de um objeto temporario do tipo de retorno
														  da chamada de metodo anterior...

					----> retestar testes para:
											----> expressao: "a.metodoA().metodoB()" (feito), 
					                        ----> expressao: "a.propriedade1.metodoB()"; (feito, erro de digitação no cenário teste).




					----> um teste que também por modificação no código não está passando, 
										----> expressão= "a.propriedade1;", não é erro de passagem de cenarios de teste,
											  nem de apagar e atualizar classes, entre versões diferentes em cenários de teste.
										----> os headers não estão apagando as versões de classes anteriores!
															----> os headers são reinicializados a cada teste.



		----> todos testes podem ser feito em um unico processamento de todos metodos.
										----> todos testes feitos.
		

_________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.07:

	   ----> fixar:
					----> fixar o erro em instanciação de uma expressão entre parenteses, seguido de uma expressão de operedores,
						  vai falhar porque a Expressão Entre Parenteses não é uma ExpressaoObjeto, que é requerido na obtenção de operandos
						  para o operador.
					----> fixar o mesmo problema, mas para expressoes numero. tentativa de especificar o tipo de numero foi feita,
						  validar com testes.


			----> codificado o tipo da expressão, necessário para avaliação da expressão.

			----> teste para expressão entre numeros,
						 ----> (fixado) a obtenção de uma expressao operador, para expressao com numeros.
						 ----> (verificado) (VERIFICAR) se a condição de operador, quando operador2==null, está capturando operadores unarios.
										----> está capturando o 2o. operando, quando o operador é binario (eliminou uma redundância quando havia 2 operandos).
										----> está capturando operadores unarios, num "else" a parte.


		    ----> por razoes de logica, retorna apenas a expressao operador, em vez das expressões operando1, operador, operando2.
						 ----> até porque uma expressao matematica com operador é maior que expressoes operandos+operador.


			----> tem-se uma condição inédita de processamento de operadores unarios como "++a", ou seja, o operador vem antes do operando,
				  modificando a "ExpressaoOperador" para verificar se o token inicial é um operador unário.
							----> (A FAZER) testar para operando unario precedente, como "++b"...


	   ----> INTEGRAÇÃO DO CODIGO ExpressoesRefatoradas no projeto...
					-----> extrair os metodos auxiliares da classe velha "Expressao".
					-----> extrair o metodo "PosOrdemExpressao".

____________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.07:

		----> testes finais, "Expressao".
					----> (fixado) operando para operador binario como "++a", não está sendo inicializado.
									----> para simplificar o metodo "Expressao.PosOrdem()", foi retirado a união de operandos e operador. Não foi pensado
										  anterior dia que poderia dificultar a colocação da expressão na forma pos-ordem.

					----> (fixado) está retornando um operador "fantasma", no indice 0 de subExpressao, na expressão "++a";
									----> fixado, a expressao objeto do operando não estava setado o nome e tipo do objeto.
									----> fixado também a atualização do indice da malha de tokens da expressão currente, pois
									não estava sendo feito quando obtem uma expressao objeto. A atualização do indice de
									token é de responsabilidade de quando se obtem a sub-expressão.



					----> modificado  o nome de ExpressaoBase.SubExpressoes, para "ExpressoesBase.Elementos",
						  para ajudar na migração.
					
							----> A FAZER:
									--->(codificar) está faltando uma expressao "string literal (constante, como um numero).
									---> (codificar) está faltando uma expressao que é o nome de uma classe, como em propriedades estáticas.
									---> (codificar) está faltando uma expressao "Null", para sinalizar que uma propriedade esta nula...
											----> legal verificar que todos casos da antiga classe "Expressao" está 
												  representada na nova classe "Expressao".

									----> (metodo nao relevante, mas importar) metodo "ExtraiExpressaoSemValidar" descontinuada, pois as Expressões Refatoradas
												utilizam "headers", podendo formar expressoes validas sem o processamento completo do codigo...
														----> no entanto, para facilitar a migraçao, verificar se há possibilidade
															  de adaptar essa funcionalidade para a nova classe de expressao...


					---> (continuar) inicio de uso de expressoes regulares para identificar casos de uso em headers.


					---> (decisão) expresssão "VetorExpressao" está descontinuada, pois será um "WrapperData".
					Isso deixa a linguagem com um unico tipo de dados "Objeto", sendo estendido por "WrappersData",
					que é um "Objeto" com uma chamada "GetElement", e "SetElement".


					----> metodo "ExtraiExpressaoSemValidar" descontinuada, pois as Expressões Refatoradas
					utilizam "headers", podendo formar expressoes validas sem o processamento completo do codigo...
									----> no entanto, para facilitar a migraçao, verificar se há possibilidade
									de adaptar essa funcionalidade para a nova classe de expressao...

					---> metodos de verificação de tipos de numeros, e conversao entre tipos de numeros, adicionada
					para a classe "Expressao", pois o codigo quando sem a classe Expressao anterior, 
					serão utilizadas também no codigo...
____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.07:
				
				
				-----> importado todos metodos (relevantes) que estava em "Expressao", para "Expressao", para tornar a migração de "Expressao" para "Expressao".
				-----> retestar todos cenarios de teste de Expressoes, ante a modificação de "ExpressaoBase" para "Expressao",
					   e eliminação de "ExpressaoBase".
										----> (fixado) testes para "ExpressaoOperador", operando2 não está sendo instanciado corretamente...
														----> fixado na ExpressaoNumero, que não estava instanciando seus dados...

														----> ultimas modificações quebraram a "ExpressaoOperador"!.

														----> propriedades duplicadas, justamente o "tipoDaExpressao" e "tipoExpressao".

														----> confusão entre Expressao.GetSubExpressao() e a expressao que chama este metodo.
															  o operando2 estava retornando seu texto corretamente, justamente porque estava em seus Elementos,
															  em "operando2.Elementos", o que confundiu o erro, pois o texto estava correto, mas a expressao
															  de retorno não.

										----> (fixado) testes para "ExpressaoObjeto.Propriedades" falha em obter os dados do objeto e da propriedade chamada.
														----> se seguir o conceito, de não mexer nos tokens da expressão quando está verificando se é expressao,
														teria passado no teste.
																	-----> Verificar todos metodos VerificaSeEhExpressao, para ver se está modificando 
																	o indice de tokens da expressao currente....
																				----> (fixado) verificado, em "ExpressaoOperador.VerificaSeEhExpressao" estava
																				modificando o indice da malha de tokens da expressao, quebrando o conceito quando
																				programado, na ânsia de obter o segundo operando.

																				----> (verificação feita) todas expressoes verificadas.

																				----> (fixado) modificações feitas, a "ExpressaoOperador" quebrou!.
																							----> não estava consumindo o token do operador, quando a extração
																							de expressao operador era bem sucedida.

																							----> clareando o codigo, foi criada uma expressao clone,
																							que livra de atualizar a expressao depois da obtenção do 2o. operando.
																											----> fixado, teste feito.




										----> testes para "ExpressaoObjetoChamadaDeMetodo", passou no teste.

										----> teste com duas chamadas de metodo passou no teste.

										----> teste para expressao com operador unario precedente passou.
													----> o teste não estava inicializando o escopo, justamente porque não há codigo de classes para compilar.


										(FIXAR) testes que não passaram:
												----> (fixar) teste "TesteExpressoesOperadorComObjetoEChamadaDeMetodo" não passou.
															----> não passou porque não está processando corretamente a expressao com operador.
																			----> porque os operandos tem que ser "ExpressaoObjeto", mas o 2o. operando do teste
																			é "ExpressaoObjetoChamadaDeMetodo".
																			----> utilizando o conceito de "Expressao.Clone()", simplificou bastante
																			a investigação "ExpressaoOperador.VerificaSeEhEstaExpressao()", que 
																			precisa de sondagem do segundo operando, e isto modificava a expressao de entrada.
																						----> a expressao "ExpressaoObjetoChamadaDeMetodo" não estava extraindo
																						o tipo de expressão!.
																			---> no entanto, teste com operador com dois numeros validou, o que significa
																			que o codigo "nao quebrou" após a modificação com clone de expressão.
															----> a expressao "ExpressaoComChamadaDeMetodo" tem que ter o tipo de expressao, como
															o tipo de retorno do método, pois na operação com operadores, é visto o retorno da chamada de metodo
															para operação, como "a+b.metodo1()", se a="int", então b.metodo1()= "int", para completar os operandos do operador "+".

												----> fixar o teste, modificações não fixaram a solução.

_____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.07:

		----> confiando em que já havia experiencia anterior que embasasse a construção de novas expressoes, criou-se uma mentalidade automatica
			  que junto com a ansiedade resultou num mal-design das classes. 
				

		----> testes para "ExpressaoOperador".
						----> testes para expressao operador passou.
						----> testes para expressao com objetos sem propriedades ou chamada de metodos aninhados, fixado, teste passou.
						----> testes para expressão com duas chamadas de método passou.

						----> (FIXAR) expressao com operador e chamada de metodo, como: "a+metodo1()".
											----> a falha está no ExpressaoOperador, quando tenta retirar o operando2, está retornando null.
															----> o operando2 está sendo calculado corretamente, porém está contido dentro da expressao principal,
															em um das subexpressoes, e não há como retirar a expressão das sub-expressoes devido a classe da expressao...
															----> TEM que obter a classe do método,que está incorretamente setada como classe de retorno do metodo.

											----> a classe do metodo estava incorreto, foi preciso obter o objeto da chamada do metodo, para obter o nome da classe do metodo.
											----> teste para "a+metodo2()" passou...


		----> testes com expressao "++c";
						----> (fixado) está retornado a quantidade de sub-expressoes correta, mas o nome do operador está incorreto.
											----> faltou adicionar a expressao do operador unario para as sub-expressoes da expressao principal.
											----> (fixado) está retornando um 2o. operando na expressão principal.
														----> a extração de operador unario, um dos casos de uso, estava não estava setando os dados do operador unario,
														      e tentou-se adicionar o operando na lista de sub-expressoes da expressão principal, o que aumentou
															  o numero de sub-expressoes, não passando no teste. teste passou.


						----> toda lista de testes passou.



		----->novos testes;
					---> (testes feito) (codificado) está faltando uma expressao "string literal (constante, como um numero).
								Para testes com strings entre aspas: 
										caracter aspas, valor unicode:
										Unicode (\u0022)
										
					---> (testes feito) (codificado) está faltando uma expressao "Null", para sinalizar que uma propriedade esta nula...
								----> legal verificar que todos casos da antiga classe "Expressao" está 
									  representada na nova classe "Expressao".


						


_______________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.07: 

		---> migração da classe "Expressao" para "ExpressaoRefatorada"... agora é o longo trajeto de recuperação...
							----> inicio de testes para classe "Expressao".									


		----> em expressao operador, contar com o caso de uso: "a++", ou seja não há o segundo operando.
							----> codificado, mas criar cenario de teste de expressao: "a++";

		----> testes com "Expressao", ante a migração, que conteve erros de substituição de "ExpressaoRefatorada", "ExpressaoObjetoRefatorada".
							----> teste "TesteExpressoes2PropriedadesAninhadas" não passou.
							----> teste "TesteExpressoesPropriedadeSeguidaDeChamadaDeMetodo" não passou.
							----> teste "TesteInstanciacaoExpressaoObjetoPropriedadesAninhadas" não passou.
							----> demais testes passou.

							----> (fixado, mas aguardando testes) o "ProcessadorID" está quebrado, pois está com um metodo "GetExpressaoResumida" sem migração,
							e mais métodos da classe anterior de "Expressao" está sem validação para Expressoes.
										----> está validando Expressoes pois não é utilizado "ProcessadorID" para obter dados,
										mas por "headers".
													----> metodo "ExtraiUmaExpressaoSemValidar" não migrada!.
													----> e metodo "ProcessadorID.ResumeExpressoes" utiliza "ExtraiExpressaoSemValidar"!..
																----> metodo "ExtraiExpressaoSemValidar" atualizado e migrado...


										----> codificação com nova instanciação de "Expressao", que utiliza headers e não compila para fazer o processamento...
													---> os headers necessário está sendo calculado uma unica vez por compilação na classe "ProcessadorID.CompilaEmDoisEstagios".
													---> tem que manter nos testes a setar os Expressao.headers=null, para compilar corretamente.
__________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.08:


		---> (nao prioritario) retirar do projeto a classe "Vector", que está criando casos de uso extra em todas instruções orquidea.
			 será implementado uma classe similar com "WrapperData".

		----> (nao prioritario) classes "WrapperData":
				na expressao onde haver dados "WrapperData", modificar a expressao, para m.GeElement(expressoesParametros),
				ou m.SetElement(expressoesParametros) (sendo m o objeto da classe wrapper data), modificando o codigo e incluindo a formatação de "WrapperData"s.


		---> aguardando testes: 
					---> (codificado) está faltando uma expressao que é o nome de uma classe, como em propriedades estáticas.
								----> codificar na "ExpressaoObjeto".
								----> problema de propriedades ou metodo estaticos resolvido, com a
									  criação de um objeto fora do codigo, que não alterará as propriedades da classe,
									  justamente por estar fora do código...
												-----> fixar a propriedade estática, que tem previsão no projeto, mas não está nos headers. 

				   ---> testes para expressao objeto como nome de função.



				----> (implementado o metodo migrado "ExtraiExpressaoSemValidar") metodo "ExtraiExpressaoSemValidar" descontinuada, pois as Expressões Refatoradas
   					  utilizam "headers", podendo formar expressoes validas sem o processamento completo do codigo...
						
				----> testes: não está construindo as "classes" da linguagem Orquidea.
									----> (a fixar) o codigo de "ProcessadorID" quebrou!.
													----> para testes com Expressoes, pode ser permutado a compilação pela leitura de headers.
													---> (FIXAR) o codigo de "ProcessadorID" está quebrado!.



									----> (fixado) o codigo de "FilesHeader" também quebrou! (nao estava retirando metodos construtores, que não tem tipo de retorno).
													----> (fixado) a classe "FilesHeaders" não estava "retirando" os metodos construtores, que não tem retorno...
													----> (fixado) falha na escrita do cenario de testes...



				----> continuando os testes para expressoes , que não precisam dos codigos quebrados em "ProcessadorID", mas do código de "FileHeader" (headers).
									----> a ordem dos testes está alterando sua validação!
												----> resolveu validar.
												----> (fixar) testes com propriedades aninhadas não está passando...
															----> os headers não construidos!
															----> os escopos não estavam sendo construidos, depois de retirar
															a compilação por "ProcessadorID", e os Expressao.headers estavam
															no cenario de teste setado para null, aí não estava
															construido, pois o codigo passado para Expressao não continha
															a lista de tokens do codigo inteiro.

															----> é um erro devido a instanciação de vários cenários de testes,
															que dificulta a obtenção dos headers, tendo que recorrer
															a instanciação de "Expressao.headers" para cada cenário de testes.

												----> (fixado) testes que não passou:
															----> TesteExpressoesOperadorComObjetoEChamadaDeMetodo(). Não está construindo o operador da expressao.
																		----> a expressao "ExpressaoChamadaDeMetodo" está
																		com tipo de expressão "indefinido"!, por isso não
																		está validando a "ExpressaoOperador"...
																		----> fixado o tipo da expressão, falha desconhecida
																		no processamento de operador...

																		----> (fixado, com mais codigo) os headers não estão com os tipos básicos
																		da linguagem! então não está acessando o nome do operador,
																		para os tipos de operandos....

																		----> está processado o operador, mas o 2o. operando
																		não está sendo obtido...

																		---> fixado, em parte: o 2o. operando não está sendo obtido...






				----> (feito, testado) ajustes nos temporizadores das classes de Testes.
								----> temporizador está falhando no computo do tempo passado na execução de um método teste.
											----> fixado o temporizador das classes de teste


				----> (codificado, testado) alguns ajustes na gravação de resultados dos cenario de teste, no logger.

				----> fixar para uma expressao "ExpressaoEntreParenteses", quando processa uma "ExpressaoObjeto".

___________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.08:
				
				---->(fixado) fixar a classe "ExpressaoOperador", que não está registrando o 2o. operando.
								----> (fixado) a classe "ExpressaoObjeto" quebrou!!
												----> não está extraindo uma "ExpressaoChamadaDeMetodo"..., porque os headers não estão com a classe do cenario de teste.
												----> os codigos dos cenario de testes estão uma bagunça...
												----> falha ao extrair headers das classes da linguagemOrquidea, + headers das classes do cenario de teste.
																----> fixado com codigo no cenario de teste, os headers estão com as classes orquidea, mais as classes do cenario de teste.

												----> o operador está com os operandos esperados, mas falha em obter a "ExpressaoChamadaDeMetodo" na malha de sub-expressoes extraidas na expressao principal....
																----> é um problema na atualização do indice de token, da expressao principal, e a não atualização está em "ExpressaoOperador".
																-----> há um indice perdido dentro da Obtenção de SubExpressao na classe "ExpressaoOperador".
																			----> o conceito é: em verificar se é uma expressao, NÃO MEXER NO INDICE DE TOKENS DA EXPRESSAO PRINCIPAL,
																			mas no caso de "ExpressaoOperador.VerificaSeEhSubExpressao", o INDICE DE TOKENS DA EXPRESSAO PRINCIPAL
																			ESTAVA SENDO MODIFICADO...


				

_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.08:

				
				----> (feito) criar uma pasta para "classes reuso", e transferir as classes de teste...
				
				----> (feito) acrescentar na classe "ExpressaoObjeto", o processamento de "ExpressaoEntreParenteses".
										----> codificado.
										----> criar cenario de testes.
													----> testes feitos.

				
				----> (fixado, com ressalva) o codigo de "ProcessadorID" quebrou!.
								----> para testes com Expressoes, pode ser permutado a compilação pela leitura de headers.
											-----> (fixado, apenas as definicoes de metodos, sem corpo de funcao) o handler da instrucao DefinicaoDeMetodo está em indice incorreto.
															-----> o metodo "ProcessadorID.ResumeExpressoes(sequencia.tokens, escopo)" não está funcionando corretamente....
															----> o metodo "Expressao.ExtraiExpressaoSemValidar" foi importado de versões anteriores do codigo,
															e o codigo foi fixado...


											----> falha na extração de propriedades, devido a nova classe "Expressao",
												  todos handlers de instrução não estão validados.
															----> os metodos e propriedades devem terminar com um ponto-e-virgula, depois do corpo bloco do metodo, ou depois da definicao de propriedade.

								----> "ProcessadorID", quanto à definição de metodos e propriedades, está fixado.


				----> para fixar totalmente "ProcessadorID", tem que retestar cada instrução orquidea, em seus handlers.

				----> inicio testes de instruções.
								----> os handlers corretos estão sendo chamados, mas o processamento
								das expressoes está falhando, justamente por causa da refatoração na classe "Expressao". está no ajustamento da nova "Expressao", ao codigo NÃO DA EXPRESSAO, MAS O CODIGO DA LINGUAGEM!
													----> (TERMINAR O CODIGO DE "Expressao.ExtraiSubExpressoes()").



								----> uma ultima modificação no codigo de "Expressao" quebrou o código!!!!
											----> teste: "TesteExpressoes2ChamadasDeMetodo" não passou...
															----> a expressao falha: "a.metodoA().metodoB();"
															----> problema de casting, nas expressao objeto "operando1" e "operando2", em "ExpressaoOperador.operando1",
															"ExpressaoOperador.operando2". Fixado com conversao de "operando1=Expressao", e "operando2=Expressao".
															
															----> alguns testes estavam com "Expressao.headers" setado incorretamente.

											----> fixado todos testes de expressao.
		
				 -----> testes de instruções:
								-----> instrução "for".
									----> justamente o operador unario poscedente, supostamente pouco utilizado, e não testado, invalidou as expressoes "for".
											----> (fixar) expressão com operador unario poscedente, como "c++".
															----> (fixado) o teste falhou. 
																	----> um indice de token + 1 estava ultrapassando o contador de tokens da expressao,
																	e por algum motivo tinha a condição de (indiceToken+1)< tokens.Count.

											----> (fixar) falha na expressao "int x=0;".
															----> a "ExpressaoObjeto" não está "preparada" para processamento de expressoes como "int x = 0";
															----> implementar em "ExpressaoObjeto" expressoes que começam com definicao do tipo do objeto.

									----> (feito) implementado na classe "ExpressaoObjeto", um teste para obter expressões definição de objeto.
											----> (fixar) o método "ExpressaoObjeto.GetSubExpressoes()", não está retornando uma expressão objeto válido.
											----> fixado, houve um codigo "à parte" que era preciso copiar os tokens da expressão principal para a expressao objeto.

____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.08:
	
		------> (BOA PRATICA DE PROGRAMAÇÃO). Tão logo os testes unitarios ficarem prontos, para cada modificação no código deve-se
				executar todos os testes, evitando efeitos colaterais de "quebrar o código"...

		------> organização do algoritmo "ExpressaoOperador.GetSubExpressao()", para melhor compreensão. 

		------> (codificado, testado!) codificado de validação de parâmetros, em "ExpressaoChamadaDeMetodo".
		------> (codificado, testado, mas novo teste pois foi criado uma expressao de instanciação de objeto) codificado validação de operandos, para operador "=".

		------> (codificado) codificar a instanciação de objetos atraves de metodos construtores.
							-----> um metodo construtor gera um objeto temporario, que é então associado a um objeto numa expressao com operador "=".

							------>  substituição da instrução "Create", por chamada de metodos construtor, observando os tipos e quantidade de parâmetro.
									 Uma pequena verificação se a chamada de método tem o nome de uma classe...

							-----> os metodos construtores "cria" um objeto temporário, que num operador "=", é associado o  "1o. operando = 2o. operando ",
									(o 2o. operando é o objeto temporario). Este conceito pode ser aplicado também a funções estruturadas,
									que não tem um objeto da chamada de método. É por isso que um construtor chamado sem um operador "=", não
									gera efeito em nenhum objeto, com exceção de modificações de objetos dentro do construtor.


		------> (codificado)  codificado a definição de método, como uma Expressão Objeto.




		------> (codificado) mover a expressão "função estruturada", da "ExpressaoObjeto" para "ExpressaoChamadaDeMetodo",
		       criando um objeto temporário para gerar uma instrução "chamada de método", em vez de uma	"chamada de função".
									----> é preciso compilar o codigo, para validar os parametros,
													o que não estava sendo feito. Mudança de validação atraves
													de "headers".
											


				-----> NOTAS PARTICULARES:
								-----> na chamada de construtor, os parâmetros devem ser passados para a função do construtor, para proceder a instanciação
									   do objeto!

								-----> na instanciacao de objeto por expressão, a instanciação ocorre com a chamada de construtor, e depois passada para o objeto na equação de instanciação (int x=1).



				-----> testes para:
						------> (falha) teste para expressão como "int x=0;".
								---> falha ao obter os parametros da chamada de metodo: estava instanciando os parametros, dentro do metodo de obter parametros,
								portanto não passaria para fora do método, a mesma lista de parametros instanciada...
								---> FileHeader não está processando todos parâmetros de um método!!!.
								---> (fixado!) incompatibilidade de representação de classes, no compilador e os headers...
												----> um ponto e virgula, entre a definição de classes no compilador "ProcessadorID", e os headers (que não tinha
												ponto e virgula podendo separar uma definição de método e outra definição de método)... um token, gerando um erro
												dificil de pegar...
												
												----> (fixado) (fixar em FileHeader) falha quando um metodo é "public metodo1()".
																		-----> fixado com codificação de instruções nos corpos do método.
			
_____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.08:
	
	
	----> fixar com observação dos testes: 
					---->  (fixado) "TesteExpressaoDefinicaoDeObjeto".
					---->  (fixado) "TesteExpressaoInstanciacaoDeObjetoComAtribuicao".


															
	----> favor escrever daqui para frente, automatização de testes mais específicos, os erros está mais sutil, uma condição de asserção mais "genérica" não está adiantando...



				----> testes a serem feitos:

							----> teste para chamada de função estruturada.
									----> funções estruturadas são carregadas diretamente no escopo currente/global (global melhor, assim todos escopos tem acesso às estas funções).
									----> implementado. testes feitos.
																----> vai dar certo, pois a chamada de metodo envolve o objeto temporario, e a funcao estruturada,
																numa chamada de método, não haverá alterações nos objetos do codigo, nem
																do objeto temporario, mas isso não tem importância, já que o objeto temporario está
																fora da lógica do programa compilado... 
																				-----> na prática, é uma chamada de função, mas só que por uma chamada de método,
																				com o objeto temporario chamando a função estruturada...

									
													
							----> teste para chamada de construtor.
										-----> (fixado) os headers não estão construindo os construtores, o nome do construtor está incorreto.
														-----> (fixado) regressão para os testes de "FileHeader".
																		----> os tokens de metodo estava contando erroneamente, pois supunha-se que o método deva ter
																			  um token do tipo de retorno do metodo, mas nos construtores não há este token de retorno do metodo.
				
										----> (FIXAR) testes feitos, fixar com base neste cenario de teste:
														----> "TesteExpressoesChamadaDeMetodo".
														----> "TesteExpressoesOperadorComObjetoEChamadaDeMetodo".	
														----> "TestesFuncaoEstruturadaComChamadaDeMetodo".
																	----> são todos testes com "ExpressaoChamadaDeMetodo".
													
														----> (fixado) quando o "HeaderMethod" é de um construtor, 
														e com acessor ("public","protected","private"), em que não havia 
														previsão de construtor com acessor, pois o teste nos "FileHeader" não
														se testou métodos construtores com acessor..


	----> com as modificações feitas, poderá ser "cortado" as instruções "definição de função", e "chamada de função",
	 	  e indo um pouco além, a instrução "Create", com a construção de objetos feito por uma chamada de método..
	
	
	-----> (codificar, em "FileHeader.BuildParameters()"): funções parametros são carregadas diretamente no escopo do método, junto com os dados do objeto que faz a chamada de metodo...
_______________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.08:

			-----> fixado a "ExrpessaoChamadaDeMetodo" para chamada de um construtor. 
									-----> um erro descoberto, foi que se o metodo tiver expressoes dentro do corpo,esta
										   expressão está sendo passada como parametro, pela classe "FileHeader".



	-----> codificando aqui, para uso de regex para reconhecer sequencias de instruções orquidea, ou de casos de uso em "FileHeader".
		   Isto permitira um processamento mais robusto, e mais extensível, além de eliminar metodos complicado em "ProcessadorID".

						-----> para match com expressoes regulares (regex), pesquisa-se em ordem decrescente em números de tokens da expressão "modelo",
							   e para cada expressão regex, termina-se com "qualquer número de caracteres", aí sim pode-se fazer um match de expressoes de pesquisa, com um número variável de tokens
							   da string a pesquisar...
													----> mudança aprovada, corta-se um bom "bocado" de código "obscuro", com pouca probabilidade de estender...
														  além "clareia" o que se pretende fazer....


						-----> testes, fixado, aprendendo mais sobre expressões regex.
													----> reconheceu uma definição de método, com 0 ou 1 definições de parâmetro. 
													----> reconheceu uma definição de método, mas não está incluindo no match o corpo do método (ex: "{ int x; }").
																		---> para os fins do projeto, não é necessário reconhecer o corpo de instruções do método.
													----> (codificado) faltando reconhecer "sequencias opcionais".
																		---> fixado, agora há uma "sequencia opcional" para "definição de parametros".
													----> reconheceu uma chamada de função/método.

													----> faltando reconhecer ids de um unico caracter (ex: "x").
																		---> codificado, mas não está resultando o esperado, apesar de "id" ser "um ou mais caracter".

													----> reconhecer um texto para a instrução "for"! (para operador "++", no texto padrão sem que ser setado "+ +").


						----> formatado a classe "TextoExpressoesRegulares" para utilização em match(s) de casos de uso, em relação a um texto formatado (ex: "id id () ").
						
			

_______________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 09.08:

	-----> Expressoes Regulares:

					----> um identificador para expressoes regex, para expressoes de codigo: "exprss" , com (qualquer quantidade de caraacter + caracteres em branco *).
					com "exprss", há a formatação para expressoes regulares, para instruções como "for (int x= a+b; x< 1+b ; x++ )".
					quanto a qusntidade de caracteres para o match de regex, há um "extrator" de tokens para sequencias id validas: classe "SequenciaID"...,
					que calcula uma lista de tokens para determinada instrução, expressão, definição de metodos, propriedades, classes...



					----> quanto mais caracteres "fixos", melhor é o match de expresses regulares.



	

			----> testes para instruções orquidea, continuação.
						----> (fixado) o operador em expressao operador está com nome errado de classe do operador.
												-----> fixado.
						----> o codigo refatorado de "ExtraiExpressoes" está funcionando sem muitas alterações.

						----> (fixado) teste para instrucao "case of use" não passou.

						----> (fixado) teste para atribuição simples não passou.
												----> foi preciso retirar a execuçao do codigo pela VM.
												----> as variaveis estavam sendo instanciadas quando na expressao, e na instrução...


						----> (fixado) teste para instrução "importer" não passou.
												----> não está no processamento da instrução.
												----> a instrução "importer" não estava no arquivo xml de definição da linguagem.

						----> (fixado) teste para instrução "create" não passou.
												----> está chegando no handler de instrução, mas o método " FoundACompatibleConstructor" está falhando....
																----> fixado, com a nova propriedade de "Expressao", "tipoDeExpressao", calculado com "headers".

												----> instanciação de um objeto importado ("Matriz m") foi feito.


						----> (fixado) teste para instrução "for" não passou.
												 ---> a instrução está sendo instanciada, mas o número de expressoes de "for" não está o esperado.
												 ---> (fixado) método "Expressao.isExpressionAritmetico()" não está funcionando corretamente.
																	----> confusão entre operador.getTipo() ("UNARIO, BINARIO"), e operador.retornoDeFuncao.

	
						----> testes feitos, outras instruções tem que ser validadas na execução de um programa na "virtual machine".
		
		


			-----> (fixar) testes para avaliaçao de expressoes, classe "EvalExpression".
						----> o código de "Expressao" quebrou!!!
									-----> falha no operador "=".
									-----> (fixado) falha em colocar a expressao em "pos-ordem".
									-----> (fixado) falha na instrução de atribuição, não está setando o valor do objeto da atribuição.
														-----> (fixado) a expressao objeto não está setando o valor de número.
														-----> (fixado) na migração para a novo "Expressao", perdeu-se o setar o valor do objeto, se for numero.
																			-----> fixado temporariamente, tem que fixar o operador "=" na classe "ExpressaoOperador".


____________________________________________________________________________________________________________________________________________________________________________________________					
Daily Scrum 10.06:

		-----> (fixado) fixar o operador "=", em "ExpressaoOperador".
								----> não há erros em "Expressaoperador", o processamento de operador está ocorrendo normalmente.


		----> (fixado) testes na classe "EvalExpression", expressao "c=a+b", não está retornando o valor esperado...
								----> em testes com classe "Expressao", a expressao é processado, mas na classe "EvalExpression", não...
								----> o metodo "InitExpresssao" estava sendo chamado após a instanciação da expressao do teste.





		-----> (fixar) as expressoes de chamada de método, classe "Expressao", que estão falhando nos testes de expressao.
								----> a expressao objeto está extraindo sub-expressoes erroneamente...
								----> falha em retirar uma propriedadade aninhada após outra propriedade aninhada....
								

		-----> (fixado) (FIXAR URGENTEMENTE) os headers "HeadersMethod", com corpo de metodo, os parametros estão sendo construidos com falha, acrescentando parametros definições de instruções dentro do corpo do metodo...
								----> não havia previsão de token de operador de bloco, estava passando por cima dos tokens do método,
									 capturando tokens do corpo do método.


		-----> (fixado) classe "FileHeader":
					-----> (fixar) (FIXAR URGENTEMENTE) os acessors de metodos publicos,estão como "protected".
					-----> (fixar) (FIXAR URGENTEMENTE) os metodos publicos, estão retornando se o acessor, e pula um token a menos do corpo do metodo.
								----> fixado o contador de tokens, estava com codigo "cola" com varios erros.



_____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.06:


-----> Atividades do dia:

	-----> (fixado) fixar com testes para expressao.
					-----> (fixado) os headers metodo não estão retornando o tipo de retorno dos metodos!!!
					-----> (fixado) num "mix" de propriedade aninhada/ chamadas de metodo aninhada, entra em loop infinito, pois não há previsão de propriedade-->chamadaDeMetodo,
						   na sequencia.
										----> fixado, com intersecção de chamadas de metodos com propriedades aninhadas. varios erros fixados, desde
										a obtenção de operadores em "ExpressaoOperador", até erros devido a sequencia de sub-expressões a verificar, em "Expressao".


	----> (feito, inicio de instrução) termino da codificação classe "Library". inicio da codificaçao da instrução "import [id];", já incluido no 
		  arquivo xml de definição da linguagem.


	----> FAVOR ESPECIFICAR CONDIÇOES DE TESTES BASTANTES ESPECÍFICAS, VÁRIOS TESTES, COM CONDIÇÃO MAIS GENERICA, RESULTOU EM FALHAS EM OUTROS PONTOS
		  DO CODIGO, QUE PRECISAM DESSAS CLASSES TESTADAS.

	----> RODAR TODOS TESTES UNITARIOS É IMEDIATO, POIS HOUVE VÁRIAS QUEBRAS AO TENTAR FIXAR SOB UM TESTE, LEVOU A ERROS COLATERAIS...
	



______________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.08:



	-----> (feito) fixar o otimizador de ´expressoes, do jeito que está, não vai calcular uma segunda vez uma expressao.
						----> um contorno seria validar as mudanças de valor de objeto, setando "expressao.isModify=true", para cada expressão
							 dentro do escopo do objeto.
										----> todas expressoes do escopo estão registradas em "escopo.tabela.AdicionaExpressoes(escopo, umaExpressao);",
										ao modificar o valor de um objeto, verificar nas expressoes se há o objeto modificado, e setar
										a expressao.isModify=true.
														-----> esta prática estava sendo utilizada antes desta manutenção, mas
														estava calculando por outra lista de expressoes, que se perdeu 	na migração da classe "Expressao".

	-----> fazer um teste operacional de imprimir na tela: "Hello World", com importação da classe "TerminalConsole", e execução de uma chamada de método "Output".
						----> (a fazer) implementar a instrução "import [id];"...
						----> modificações testadas em classe "Library".
						----> confusão programada, foi codificado e fixado um novo metodo de acesso a metodos de uma biblioteca.
						
						
				----> proxima codigo: fazer uma instrução chamada de metodo, num programa na VM, para escrever "hello world" via um programa da linguagem orquidea.

_____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.08:


			-----> testes para execução de instruções. enfase na instrução "ChamadaDeMetodo", a fim de entregar o "hello world" via
			execução de uma instrução de programa VM. "Software bom é software entregue"...
						----> instrução "for" está funcionando, mas a avaliação de uma expressao incremento está incorreta...
									----> notar que antes da migração de Expressoes, desta manutenção, todas expressoes estavam funcionando corretamente.


						----> testes para instruções "Atribuicao","for","while", "if", "create", "casesOfUse", "construtorUP" fixados.
									----> (fixado, erro no cenario do teste) verificar a sintaxe da instrucao create, depurar a instrução create.
									----> instrução "DefinicaoDeMetodo"já feito, no processamento de classes, com escopo de classe, definiçao de métodos, proprieades, bloco de corpo de métodos.
													----> (fixado) o escopo do método não está sendo bem construido...
																----> fixado a construção de escopos pai- escopos filho, uma lacuna há muito tempo não fixada...
																----> fixado também a construção de escopo-classe && escopos-filho. A hieararquia de escopos está completa!
																----> fixado finalmente o problema de "escopo pai- escopos filhos".

									----> instrução "construtorUP" é necessário um teste mais especifico, que verifica a execução da instrução no programa VM.
									



			----> modificar urgentemente a avaliação de chamadas de método, para o caso de uso "this.metodoA()", e não "a.metodoA()".
				  no método "ExecuteAMethod()", verificar se o nome do objeto for null. Se for, não transferir os dados do objeto que
				  fez a chamada, e as modificações de variáveis feita pela execução do método tem que serem passadas para o escopo
				  da chamada do método..., emulando uma chamada de método dentro de um método de classe...

			----> expressões regex para um "WrappeData" de vetores: "var id = < exprss [,exprss] >"!, se match, gera um construtor de vetores.
				  então, outra expressao regex para obter dado: "id_obj<exprss[, exprss]> = exprss", se match, gera uma chamada de método 
				  "id_obj.SetElement(exprss,...);", que é inserida no processamento de expressões..., e para id=id_obj<exprss [,exprss], uma
				  atribuição e uma chamada de método id=id_obj.GetElement(exprss,...);
								-----> 3 expressões regex, uma para instanciar (construtor), outra para acessar (get) , outra para setar (set).


Prioritário:

		




______________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.08:


			---->(feito, insight, implementado!) com a tecnica de objeto ficticio para fazer uma chamada de metodo, é possivel transformar qualquer metodo em metodo estático!!!



			----> (feito)  a fim de obter chamadas de metodos transformados em estaticos, para uma chamada de metodo "Prompt.write("hello world!")",
			      foi codificado na classe Expressão um tipo de chamada metodos transformado estaticos.
								---> (feito)  codificar em "ExpressaoChamadaDeMetodo", uma chamada de método explicita, com o nomeDaClasse.nomeDoMetodo(),
									 essencial para escrever na tela "hello world", em um program VM.
								---> (feito)IMPORTAR A CLASSE "Prompt" como uma classe basica da linguagem, pela relevância de acessso à tela para escrever/ler textos, numeros.
								
								---> a "InstrucaoChamadaDeMetodo" é necessária para um programa VM que imprime um texto; "hello world",
									  no código do "ProgramaVM", e não numa chamada indireto, em um cenario de teste...


			----> (feito, fixado com testes) uma extensão interessante seria criar uma "headerParameter.headerProtypeFunction", que guardaria a assinatura
			de uma função, que seria "injetada" no escopo da definição de método.
							   -----> (A FAZER) extrair parâmetros-protótipo de função, nas classes Expressao, e registrar a função no escopo da chamada de metodo....



			----> verificar se na instrução "Create" que instancia objeto, estaria criando uma instancia do mesmo objeto, quando estão num
			loop.. Verifica-se se o objeto já existe, e se existir, não cria uma instancia, mas passa os parametros da instrução create,
			para o objeto já instanciado.
								---> (VERIFICADO) O objeto create não cria o objeto, ele já vem criado no compilador. mas executa o construtor,
								como se o objeto ainda não estivesse criado.
								---> (VERIFICAR) verificar a lógica da instrução, há uma clonagem de escopos meio obscuro...
			

			---> (verificado, não há duplo código) (VERIFICAR) se há código duplo na instrução "ChamadaDeMetodo", verificando quando em outros testes, se não me engano,
				 na classe método a execução de método "ExecuteAMethod" faz
				 todo trabalho de dados do objeto para o escopo, e na instrução, há o mesmo código, de transferência de dados...
						---> instrução "ChamadaDeMetodo" agora tem suporte para chamadas de método aninhadas, ex: "a.metodoB().metodoE(x);".

			
			----> (codificado) codificar urgenemente a adição de 2 ou mais instruções geradas, na "InstrucaoChamadaDeMetodo",
				  para a lista de instruções.
						----> uma codificaçao possível seria calcular as instruçoes, mas retornar a ultima instrucao,
						e as demais instruçoes são adicionadas previamente na lista de instrucao.


_________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.08:

		 ---> teste com código VM, de chamada estática de método, para compor "hello world" na tela.
							----> validar a passagem de parãmetros texto-literal a uma chamada de método.
							----> expressoes parâmetro são chamadas recursivas de "Expressao", então teoricamente seria gerado uma "ExpressaoLiteral", para Expressoes string constante.
							----> é possivel chamar funções "Prompt" estaticamente, mas a passagem  de parãmetro, na expressão "ExpressaoChamadaMetodo",
								  não foi testado ainda...
												----> (fixado) há um problema, uma string com espaço em branco está sendo processado como 2 ou mais tokens, justamente por causa do espaço em branco.
												----> (fixar) falha na construção de "ExpressaoChamadaDeMetodo".
																	----> (fixar) o codigo de "FileHeader" quebrou! Está processando incorretamente a quantidade de parâmetros de um método de biblioteca.
																						----> a chamada de metodo está dentro de um outro metodo, então não está sendo processado por headers, que verifica apenas definições de metodos´, propriedades e operadores.
																	----> (fixado) investigando, o método Importer.ImportAClassFromApplication(typeof(Prompt)) quebrou!! Não está setando corretamente o numero de parametros.
																						----> um erro grave, a lista de parâmetros não estava sendo esvaziada, na passagem de processamento de um método para outro...	
																	----> (fixado) o metodo "Expressao.ExtraiExpressoes()" não está extraindo as expressoes literais..
																	----> (fixado) expressao literal não está contabilizando o indice de tokens corretamente.

																	
																	
						 ----> (fixado) as ultimas modificações quebrou a maioria do processamento de instruçoes!!!
												----> a contabilização de uma expressao "ExpressaoNumero" desestabiliou o codigo do metodo "Expressao.ExtraiExpressoes()",
												que não devia ter sido feito, já que era para acrescentar o processamento de expressoes "ExpressaoLiteral".

						----> (fixado) incompatibilidade da antiga versão de "EvalExpression" com a versão recente de instrução "Chamada de Método".
												----> (fixado) codigo antigo para "EvalExpression()"	expressão chamada de método, estava com duas entradas para avaliação de "ExpressaoChamadaDeMetodo".
						
						----> (fixado) faltou especificar a "Funcao" da chamada de metodo...
												----> verificado o metodo de encontrar função compativel, com nome, classe, e parâmetros da função.
		


						----> pronto para execução de chamada de método, para escrever na tela "hello world"...
												----> (fixado) falha na instanciação de parametros para a execução do método.
		

						----> (fixado), teste para instrução direta de chamada de método feito bem sucedido...
												----> (fixado) em "ExpressaoChamadaDeMetodo", para casos como: "a.metodoB()", está sem
													  inicializar o objeto "funcao".

												----> pronto para executar teste de "hello world" via processo de execução de método dentro de um metodo de classe.
														----> (fixar) falha na execução da chamada de metodo, objeto que invoca a chamada está null.
												----> pausa devido a fadiga.

												----> (verificado) verificar urgentemenete por que o escopo de um método está como null.
														----> na definição de um método, está criando o escopo do método sim,
															  mas para a construção de uma chamada de método, como instrução de outro metodo,
															  não passa pela definição de método, justamente no caso do teste é uma função importada, não uma função
															  orquidea... NADA A ALTERAR.
	

												----> execução de uma chamada de metodo, como instrução de um outro metodo, feito com sucesso!


									
									-----> testes para "hello world" feito, com instrução direta, e com instrução de corpo de metodo.

									
												


		----> Em Tokens.GetTokens(), incluir o caso de aparecimento de aspas, em que tem que unir tokens até outra aspas seja encontrada...


		---> uma biblioteca para manipulação de arquivos texto: open, close, write, read (read/write com sobrecarga de métodos, para compor com leitura de um caracter, uma linha inteira), append.
										-----> esta biblioteca é prioritária.
		
		---> instrução "Create" está com uma copia de escopo que não está muito claro.
						---> (VERIFICAR) verificar a lógica da instrução, há uma clonagem de escopos meio obscuro...
										-----> sem erros em diversos testes, com instrução "Create".
		

		---> resolver a iteração de métodos estáticos (com um objeto ficticio) com propriedades estáticas.
		

		----> extrair parâmetros-protótipo de função, nas classes Expressao, e registrar a função no escopo da definicao de metodo.
						---> confusão entre chamada de metodo, definição de método:  o protótipo de função-parâmetro deve estar na
						definição do método, não na chamada de método...
										----> se a definição de método retirar seus dados dos headers, estará lá o protótipo de função-parâmetro!
										Aí é só construir o escopo do método, e validando no seu corpo de função chamadas de métodos que
										utilizam o protótipo de função. melhor seria se no escopo do corpo do método, estivesse
										registrado esta função. O escopo de método é apenas do método.

						---> definir os parâmetros função como um método estático sem classe(?!), para simplificar a interface de declaração deste parêmetro, retirando o nome da classe do método.
 

		----> testes para execução de expressões chamadas de método. 
					   ----> com a construção de expressoes chamadas de método, será possível escrever na tela "hello world" via codigo VM.
__________________________________________________________________________________________________________________________________________________________________________________________________			
Daily Scrum 31.08:

	----> retirada a compilação em dois estágios, e obter uma classe no repositorio, pode retornar uma classe não compilada ainda, em RepositorioDeClassesOO.GetClasse().
						----> migração da extração de classes, para compor com Headers, que elimina o problema de "instanciação posterior a atribuição de propriedades e acesso a metodos".
									----> (a testar) o corpo dos metodos não está compilado ainda, codificar no ProcessadorID, após todas classes serem extraidas, 
									fazer a compilação do corpo dos metodos.
													----> (fixado com a migração para headers) a compilação de uma classe não compilada pode falhar, mas o metodo "GetClasse()" retorna um "involucro" para a classe requisitada...
													----> (testes sucedido) TESTAR o processamento de classes, classe "ExtratoresOO".


	----> (feito) incluir nos casos de uso de "headerProperty", a declaração de propriedades estáticas.
									---> (testes sucedido, classe "FileHeader"). 
									---> (testes sucedido, classe "ExtratoresOO"). funcionalidade proprieadades estaticas, na definição de classe, feito.





	----> (a testar) retirar as aspas da literal constante, está escrevendo com aspas.
		
	----> (a fazer) Em Tokens.GetTokens(), incluir o caso de aparecimento de aspas, em que tem que unir tokens até outra aspas seja encontrada...

	
	----> (testado) o corpo dos metodos não está compilado ainda, codificar no ProcessadorID, após todas classes serem extraidas, 
							fazer a compilação do corpo dos metodos.
											---> teste codificado na classe ProcessadorID.
											---> teste sucedido.
											---> VERIFICAR AS EXPRESSOES de atribuição, e com operadores, pois no teste de corpo de metodos, foi constatado codigo que era atribuição, mas estava como "ValidExprss".

	----> (testado) retirar as aspas da literal constante, está escrevendo com aspas.
	
	
	
________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.09:

	
			---->(feito, ante avaliação) estudo de fazer classe "Funcao" a renomear como "Metodo", e fazer de "Metodo" como sub-classe de "Objeto", para capturar "Metodo"
				 como parametros Objeto das funções "Metodo".
								----> classe "Funcao" é agora "Metodo", e "Metodo" e herdeira de "Objeto"... Não cabia chamar uma "Funcao" de "Objeto", é no mínimo heresia..

			
			---->(feito) codificar a validação dos tipos na extração de propriedades,tipos de retorno e tipos dos parametros de um metodo, na classe "ExtratoresOO".
			---->(feito) Em Tokens.GetTokens(), incluir o caso de aparecimento de aspas, em que tem que unir tokens até outra aspas seja encontrada...
								----> codificado, em testes:
												---->(fixado) não está processando uma 2a. literal.
												---->(fixado) não está processando uma 3a literal.

												----> a importancia dos cenarios de testes: lançou-se erro não na extração de um 1a, 2a literais, mas com 3 literais,
												     para perceber que o algorimo estava falho...
			
								----> partes de extração de "ExpressaoLiteral" no codigo das classes "Expressao" foi simplificada.	



			----> não tendo nada a ver com as modificações de literais, mas o codigo da classe "Expressao" quebrou!!!.
								----> foi na migração de processamento por repositorio de classes, que não era garantida em todos cenarios, para processamento por headers, a prova de falhas...
													----> modificado também a classe que executa a chamada de metodo, classe "EvalExpression" para instanciar a função do metodo, caso não esteja feito ainda.
														  Com headers nas expressoes, não se instancia a função, mas o header de função. justamente porque não há compilação completa do código.


								---->(fixado) (codificado um novo metodo, com headers) quebra no codigo do metodo "ObtemFuncaoCompativelComAChamadaDeMetodo()", que não está utilizando
								headers, mas classes do repositorio de classes.
													----> testes que não passaram:
															----->(fixado) "TesteExpressaoDefinicaoDeObjeto".
															


			
___________________________________________________________________________________________________________________________________________________________________________________________________								
Daily Scrum 02.09:

			----> (a fazer) implementação de passagem de função como parâmetro, em uma chamada de outro método.

			----> (explicado) muito estranho, em dias anteriores, a execução de chamada de método, para imprimir na tela "hello world" estava funcionando,
			mas hoje o codigo estava incorreto, com chamadas de todos elementos da expressão a executar, como "ExpressaoChamadaMetodo", o que geraria
			um erro sem tamanho.. talvez porque o unico elemento da expressao do teste "hello world" fosse um unico elemento, uma unica subexpressao,
			que passava no loop incorreto, pois o loop era executado uma unica vez...


			----> (feito) modificado a apresentação de "Expressao", pois estava não pragmático, atrapalhando a leitura, e agora
			   processamento de wrappers.
		

			----> (feito) simplificado os parametros de construtor da classe "Escopo", com sobrecarga de construtor,
				 com texto de codigo a ser definido uma lista de tokens, através do texxto de codigo.


			----> (feito) inicio codificação de um wrapper data, Vector.
					----> (codificado) a classe "VectorWrapperData".
					----> (codificado) a classe "Vector". 
									----> classe "Vector" codificada os metodos "GetElement", "SetElement", faltando o construtor.
									----> classe "Vector", codificado a instanciação resumida de um vector.

					----> testes para classe "WrapperDataVector", feito match para as expressoes regex da classe "WrapperData",
					como regex de instanciacaoVetor, e acessoElemento.
									----> salve melhor resultado de cenário de teste, teste para classe "WrapperDataVector" sucedido.
									----> formação da chamada de metodo para "GetElement" construida, inserção na expressao principal feita.


					----> (fixado) (codificado) o método "SetElement", na classe "VectorWrapperData".
									  ---> no método "SetElement", substiui todos vetores na forma resumida, por expressoes chamadas de metodo.	
									  ---> (fixado) falha na contagem de indices de tokens. 	
												----> contagem de indices de arrays é sempre um desafio...

							

		---->(falha) (VERIFICAR) verificar se é possivel conseguir expressoes com chamadas de metodo como elemento inicial, e com 
		chamadas de metodo com operações matemáticas ("ExpressaoOperador").

		----> tem que garantir que: 
						1 - (verificar) todas expressoes tem sua lista de tokens.
						2 - (falha em instanciar) a Expressao com varias chamadas de metodo combinadas com operadores, numeros, tem que ser instanciada.
										----> modificada a ordem de tipos de sub-expressoes, classe "Expressao".
											  teste falha em obter "ExprressaoEntreParenteses".
															---> regressão para o estado anterior, falha ainda para:
																		"ExpressaoEntreParenteses".
																		"ExpressaoNILL".

						3 - (falha em extrair sub-expressoes).
						

_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.09:

		----> (inviável)(SOB TESTES) codificar em "Expressao.ExtraiExpressoes", se encontrar operador ".", procurar fechar com parenteses completo, 
		      ou atingir operador ";". Extraido tokens nestes termos, formar uma sub-expressao.
										----> vai falhar ante um token operador ligando duas "ExpressaoChamadaDeMetodo", que é este o caso de "WrapperDataVector".
										----> E SE... PARA IDENTIFICAR TIPOS DE EXPRESSÃO, UTILIZAR Expressoes Regex? Problema de classificar erradamente
										uma Expressão estaria resolvido. o problema é que uma expressao pode ter "variantes", como duas ou mais
										"chamada de método".

		----> (feito) o "cálculo" de sequencias aninhadas de "ExpressaoChamadaDeMetodo" ou "ExpressaoPropriedadesAninhadas" está errado!
			  o objeto temporário tem que ser o próprio objeto que fez a primeira "chamada de método" ou a "primeira propriedade aninhada"!
			  por que? porque o objeto modificado na primeira chamada de método ou primeira propriedades aninhada, pode ser modificado
			  e esta modificação teria que ser repassada para as próximas chamadas... é erro pensar que chamadas de método aninhadas
			  devem ser feitas somente nos casos em que a chamda de metodo não modificar o objeto que fez a chamada. (é um erro no conceito de chamadas aninhadas).
			  				----> retificar a expressão "ExpressaoObjeto", para compor não com objeto temporário, mas o objeto que
								fez a primeira chamada, pois pode haver modificações que deveria se propagar entre as chamadas.

								
								
										
***********************************************************************************************************************************************************************										
		----> (CODIFICADO) codificar em "ExpressaoObjeto", parada de processamento se depois de uma "ExpressaoChamadaDeMetodo" ou depois de uma "ExpressaoPropriedadesAninhadas",
		se o próximo token for <> "." (o que teria que processar mais "ExpressaoChamadaDeMetodo" ou mais "ExpressaoPropriedadesAninhadas").

		----> (CODIFICADO, a testar) codificar a propagação de aninhamento tem que ser feito com o objeto principal, e não com objetos temporários, conforme o explanado acima.
		----> (VERIFICADO, retorna como tipo de retorno) se na "ExpressaoObjeto" tiver de uma "ChamadaDeMetodo", o tipo da expressão deve ser o tipo de retorno da "Chamada de Metodo",
			  porque em operações matemáticas, o que conta é o resultado de uma função...
			  
**************************************************************************************************************************************************************************
		----> MAIS UM ERRO CONCEITUAL: uma chamada de metodo como objeto a "setar"!, é o caso de "WrapperDataVector", 
		fixar, calculando o endereço da chamada de método à esquerda da equação, e setar com a Expressao do lado direito
		da equação: retirar os tokens do lado direito, e calcular o resultado desta Expressao, então setar o elemento
		com indice calculado.
					----> todos "WrapperData" no lado esquerdo de uma equação de atribuição, precisam do mesmo algoritmo explanado...
					
		

		----> HÁ MAIS ESTRUTURA DE DADOS, como "Vector": "Matriz", "Dicionario", "Lista", "Pilha", "Fila", etc...,
		estão no planejamento, mas esperando de resultados operacionais com "WrapperDataVector".

*****************************************************************************
----> ante as constantes quebras de codigo, foi codificado metodos de procura de tipos de expressao, atraves de expressoes regex.
					----> codificado metodo de especificações de expressões para procura de match por expressoes regex.
					----> codificado classe para reconhecimento de tipos de expressoes, a partir de lista de textos procura + tipos de expressoes.
					----> iniciar testes, de match de tipo de expressoes, atraves de expressoes regex.
					----> leitura da anotação linha seguinte...
					----> encontrar um modo de diferenciar um "id" de uma "exprss".
									----> id não tem parenteses, operadores braças, sinais <,>, virgula (",")  nomes de operadores, apenas caracteres ou numeros.
									

----> (feito) (CRUCIAL, CRITICO): pesquisar na internet sobre como nomear grupos de textos regex. Se sucesso, sai após busca
por padroes com expressões regex, todas expressoes especificadas por grupos, sem necessitar de processamento por sub-expressoes,
cortando para < 1/4 as linhas de codigo, além é claro da robustez e ortogonalidade da procura com expressões regex..

							-----> pesquisado: como nomear um grupo regex, como obter ocorrencias de um grupo, como grupo: "id",
								   codificado e testado um algoritmo para obter ocorrencias, como id(s)!!!, a partir de
								   um padrao formatado resumido (pattern), e um texto a ser pesquisado (input).

							----->  grupo: entre parenteses, texto regex.
									nome do grupo:  "?<nomeGrupo>", dentro dos parenteses do grupo. O "?" é uma tag para nome de grupo.
									ocorrencias do grupo: group[nomeGrupo].captures. Cada Capture contem um valor que é a ocorrencia no texto input, do grupo de "nomeGrupo".

_______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.09:

-----> (sob testes) codificado o extrator de expressoes (nao validadas), a partir de textos resumidos regex.
							-----> (fixar) testes, não está registrando um operador, apenas ids, e expressoes.
											---> (fixado) é um erro de conceito: só está registrando apenas grupos "id" e "exprss".
														

											---> (fixado) o tipo de expressao nao está sendo instanciado.
														----> localização do tipo de expressao encontrado, e ocorrencias de "ids" e "exprss" encontrados.
					
											---> testes para mais tipos de expressao.
														----> fixado o tipo de expressao "ExpressaoChamadaDeMetodo", com metodos sem parâmetros.

							----> pausa para planejamento. 

----> (a fazer) criar na classe "Vector", o método "Vector.SetElement", que será chamado em uma expressão expandida, de "m<1>=a<2>+b<3>", pata: "m.setElement(1, a.getElement(2)+b.getElement(3)".
	  método "Vector.getElement" já codificado.

________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.09:

---> testes para mais tipos de expressao.
			----> testes para expressoes mais complexas, como "a.metodoA() + b.metodoB()".
							----> (fixado) fixar o erro de textos apos o match, ex: "a.metodoA()", em "a.metodoA() + b.metodoB()", deveria retornar apenas "a.metodoA()".


							----> (feito) testes colocando em primeiro lugares expressoes regex com pattern sem "ids", apenas com "exprss" e com operador,
							conseguiu match para "a.metodoA() + b.metodoB()", com pattern resumido: "exprss + exprss", reconheceu as duas "exprss"!.
												----> atualizado a classe "SearchRegexExpression" para ordenar segundo o aparecimento de pattern resumido com "exprss",
													  ou secundariamente com o tamanho da lista de tokens. Isto implementa o relatado.
												----> para o caso "a.metodoA() + b.metodoB()", retorna um tipo de expressão "ExpressaoOperador", o que é o esperado.


							----> (a testar) testes mais complexos, como "a.metodoA() + b.metodoB() + c + 1 ", precisa de um pensamento melhor, pois
							há varios "ExpressaoOperador" (3), que precisam ser parseadas resumindo as expressoes do 1o. ExpressaoOperador, para "id + c + 1"
												----> tem que limitar os caracteres do padrão resumido "exprss", ou contar cada caracter valido para "exprss".
													  por exemplo, se contém um operador, então "exprss" iria até o caracter anterior ao operador!.
												----> codificado para delimitar o padrao resumido "exprss", com exclusão de nomes de operadores, conforme o observado
													  acima.

												----> (A FAZER) tem que delimitar também se há um "id" após uma "exprss"
												
__________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 08.09:
			----> (feito) metodo para formação de "pattern resume", a partir do "input" (texto a ser parseado).
					----> codificado um metodo em "TextExpression", para correção de patterns resumidos, para incluir tokens adicionais. 
						  ex: paternOriginal= "exprss + express", input = "a.metodoA()+ b.metodoB()+ c.metodoc()", patterModificado= "exprss + exprss + exprss".
					----> (codificado) modificar o metodo explanado, para em vez de produzir somente "exprss", mas também "id", se o input for ex.: "int metodoB()", deveria ser "id id()", e nao "exprss exprss()".



			----> andamento do projeto:
						-----> foi codificado a classe "SearchByRegexExpression", para obterm tipos de expressoes,
							   ids, exprss, para reconhecimento de expressoes complexas, como: "a.metodoA()+b.metodoB(5)+ c.metodoC(x+y)".

						-----> foi codificado na classe "TextExpression", para gerar o pattern resumed, a partir de uma lista de nomes operadores, e o input.
											-----> DEVERIA SER UTILIZADO EM "ExpressoesOperador", em que pode aparecer mais de um operador num codigo de expressao, como "a+b+c.metodoC()".

			----> (feito) modificar o GeradorDePatternReduzido, para incluir "operadores" somente quando não há parenteses "pendentes".
						----> algoritmo complexo, é necessário:
									1 - calcular os indices dos operadores presentes.
									2-  eliminar os indices de operadore presentes fora do fluxo principal.
									3-  calcular os tokens nao operadores, transforma-los em "id","express","number".
									4-  calcular os indices de tokens nao operadores.
									5-  juntar a lista de tokens operadores, e nao operadores.
									6-  juntar a lista de indices de tokens operadores, e nao operadores.
									7-  montar o pattern, inserindo tokens com seus indices.
						----> codificado, retira tokens que não estão no fluxo principal, como operadores de expressoes-parametros de uma expressao chamada de metodo.

					----> o  objetivo agora é codificar um metodo que calcula o "pattern resumido", a partir de um texto "input", não só nos casos com operadores.
							-----> o algoritmo:
										1- carregar todos tokens que possam ser delimitadores: "(" , ")" , "." , "[" , "]".
										2- dividir o "input" com esses tokens delimitadores.
										3- calcular os ids, e seus indices de aparecimento no "input".
										4- calcular os tokens delimitadores presentes, e seus indices de aparecimento no "input".
										5- juntar as listas de tokens, e as listas de indices.
										6- fazer o processamento, inserindo "ids", ou "exprss", ou "number", nos tokens ids.
										7- completar o processamento, inserindo os tokens delimitadores presentes.

							----> fixar a inserção nao validada, de tokens "id", pelo algoritmo.


	----> RESUMO DO ANDAMENTO DO PROJETO:
							----> codificacao de metodo de calculo automatizado de "pattern reduzido", para tornar possivel o processamento de expressoes no "SearchByRegexExpression".
												----> terminado metodo de calculo de "pattern reduzido".
																	-----> um "pattern reduzido" é ponte para formação de expressões regex especificas para o projeto.
						
							----> uma vez estabelecido o "SearchByRegexExpression", será possivel identificar o tipo da expressao,
							e enviar os tokens da expressao para o Expression.GetSubExpression() devido, facilitando e tornando
							mais dificil de erros no processamento de "Expressao".

							----> tb. com o "SearchByRegexExpression", será possível também terminar a codificação de "WrapperData"s,
							que precisa de expressões complexas, como: "a.metodoA()+b.metodoB()+1", em que no atual estágio de "Expressao",
							não é possivel conseguir.



   ----> preparando classe "SearchRegexExpression" para "pattern resumed" automatizados.
						   ----> modificações feitas para compor com patterns resumidos automatizados.	
										----> (feito) faltando incluir os operadores encontrados.

						   ----> os indices de "ids","exprss","operators", estão contidos nas listas de ocorrencias.

						   ----> testes para "SearchRegexExpression", metodo principal: "ProcessingPattern".
										

___________________________________________________________________________________________________________________________________________________________________________________________________________________________
DAily Scrum 09.09:
							----> testes em "SearchRegexExpression", fixado.
										-----> (fixado) input= "a.metodoBO()", resumida em "exprss", está retornando o não esperado.
															----> correcao fixa quebrou os outros casos de uso!.
										-----> (fixado) esta faltando um metodo de obter o "pattern resumido" de acordo com "input".
										-----> (fixar) há problemas de demora de processamento, em modo de depuração, funciona normalmente, mas em modo sem depuração, os
											   calculos nao terminam, loop infinito...
															----> os testes passaram, mas continua a demora de processamento, quando sem depuração...

										----> refatorado a classe "SearchByRegexExpression", não estava retornando o tipo de expressão, apenas as listas de ids, exprss, operadores.
															----> falha desconhecida esta resultando num nao match da expressao regex, com input, apesar de teste em classe "TextExpression" está validando.
																		----> estava instanciando com pattern resumido, nao um pattern regex... fixado.

															----> testes muito mais rapidos, testes sucedido. 
																		----> faltando fixar a procura de sub-expressoes, como "a.metodoA()+ b.metodoB()", "a.metodoA()" é sub-expressao.

									
							----> (feito) continuando testes, para sub-expressoes, falha em determinar o tipo de expressao para sub-expressoes, o pattern reduzido estão corretos, mas
							 			  não encontra "ids", "exprss", ou "operadores".
															----> (fixar) não está extraindo tokens corretos de sub-expressoes, está dividindo "metodoA", "metodoB", para "metodo A", "metodo B".
															----> erro desconhecido está impedindo de extrair tokens de sub-expressao, o que propagou para pattern resumido, e
																  que gerou uma avaliação de expressao não esperado..
																				----> (fixado) a falha está em conseguir um pattern resumido automatizado...
																				----> a lista de patterns resumidos está encontrando um pattern antes do pattern corretamente.
																					----> patterns codigo para chamadas de metodo está codificado incorretamente...
															----> fixado, teste feitos. agora, tem-se expressoes complexas sendo "parseado" gerando tipos de expressões correto,
															o que auxilia muito na instanciação de Expressoes...

															----> a importancia dos testes, e depuração: foi encontrado um erro de codificação dificil de se visualizar, justamente
															na instanciação de padroes resumidos de codigo...

															----> não é preciso ordenar a lista de searchers... 


__________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.09:
				
					------> (fixar) pode-se classificar mais, com os ids de "SearchByRegexExpression", como "ExpressaoObjeto", "ExpressaoNumero", "ExpressaoLiteral", que
					são expressões com 1 token.
										------> (feito) em ProcessingPatterns(), onde está a lista de ids, encontradas, fazer uma busca recursiva, se o numero de tokens
										for > 1. Onde está o grupo de "ids", faz-se a busca recursiva semelhante ao grupo de "exprss".

										------> (fixado) está retornando o tipo errado de expressão, a extração de ids está certo..
																	----> ids mesmo  nomes de metodos, está como "id", "ExpressaoObjeto", pois
																	no escopo do algoritmo, não é possivel determinar que o nome do metodo não é "ExpressaoObjeto".


					-----> fazer mais testes, com input com numeros, NILL, texto literal.
										----> (fixar) não está reconhecendo um numero, como expressao.
																	----> falha na construcao de patter resumido, em vez de lançar "number", está lançando "id".
										----> (fixar) erro desconhecido está não match entre entrada "1+a".


					----> melhoria no codigo de "SearchByRegexExpression", metodo "MatchPatterns", para listar "pattern code" com um só token,
						  para que em "ExpressaoOperador", os pattern code com um só token seja convertido para "exprss".

_________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.09:

		-----> classe "SearchByRegexExpression", falta ligar o tipo de expressao, com a sub-expressao de main..
					----> erro desconhecido está impedindo encontrar o tipo da expressao para a primeira sub-expressao.
					----> (localizado) tokens de obter o pattern automatizado está gerando um token "vazio" a mais, o que está resultando num pattern automatizado incorreto
									----> (fixado) (fixar) fixar o codigo de "TextExpression.FormaPatternResumed()".


					----> (fixar) falha na extração de ids de um só token.
									----> erro desconhecido está impedindo de extrair ids de um token.
												----> (fixar) localizado,  está impedindo de extrair ids dos grupos de expressão regex...
																	----> operadores parenteses estavam codificado erroneamente.
												----> falha em reconhecer um pattern resumido com ids, como "id.id()".
									----> o codigo de "TextExpression" quebrou! Não está reconhecendo grupo "id"!!!.
																	----> o codigo de pattern resumido automatizado quebrou novamente!!!!!
									-----> ufa! o grupo de id estava com texto erroneamente, depois de modificações na tentativa de incluir numeros no grupo de id...

									----> só uma questão: não forma pattern resumido automatizado para "id id ()", está retornando "id ( )", ou seja, não codificou o "id" inicial...
									não estava no planejamento reconhecer "id"s em sequencia, já que expressoes nao há uma instanciação como "int metodoA()".
																	----> cuidado! acrescentado espaço vazio como delimitador em "TextExpression.FormaPatternResumed".
									-----> (fixar) é um erro conceitual: deveria formar pattern a partir dos tokens de input, como "int metodoB()", deveria retornar "id id ( )",
									a utilização de delimitadores está conceitualmente errado...

______________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.09:
					-----> (fixar) é um erro conceitual: deveria formar pattern a partir dos tokens de input, como "int metodoB()", deveria retornar "id id ( )",
									a utilização de delimitadores está conceitualmente errado...
					-----> para ser sincero, o calculo de pattern resumido automatizado foi um "fiasco". Mas não precisa do pattern automatizado,
						   é uma proteção contra pattern codificado (feito pelo desenvolvedor no codigo).
										----> retirar o pattern automatizado do projeto.
										----> por outro lado: o pattern automatizado é essencial para expressoes com operadores, como "exprss + exprss * exprss",
										que foi que justificou a codificação de pattern automatizado... (manter o pattern automatizado para expressoes com operadores,
										retirar de pattern sem operadores).


			----> (falha na codificação) novo planejamento para grupo "exprss" na classe "TextExpression": expressão é qualquer caracter menos tokens de operadores,
			isso delimita "exprss", e com um só grupo de "exprss" no pattern de regex expressions, devolverá todos "exprss",
			e uma busca por grupo "id" dentro de cada "exprss" encontrada, devolverá "id"s.
										----> modificação feita, encontrou processamento para pattern resumido = "exprss",
											  mas falha na extração de "exprss".
														----> regressão para o codigo de "exprss" anterior...

										----> (meio fixado) em outra modificação, no "patternResumido" para ids (nao operadores) reconheceu todos
											  ids em todos testes. Mas se misturar ids com exprss o resultado é indeterminado...

										----> codificado no pattern resumido para "id", uma forma de substituir "id" por "exprss",
										quando se encontra um operador.

										----> (codificado, meio fixado) CODIFICAR A INCLUSAO DE OPERADORES PRESENTES NA FORMAÇÃO DE PATTERNS RESUMIDOS.

			----> em testes na classe "SearchRegexExpression", reconheceu a expressao principal, as sub-expressoes, e
			as sub-expressoes id! A preocupação é com expressoes como: "a.metodo(c+d)", que mistura "exprss" e "id".
										-----> (fixado) testes com expressao: "a.metodo(c+d)", nem reconheceu o input.
														---->(fixado) formação de pattern resumido completamente errada...
														     o operador "+" está com indice completamente fora de parametros.

										-----> (fixar) o grupo "exprss", de "a.metodo(c+d)", não está listando as ocorrencias...
														----> pattern resumido para: "id . id ( exprss + exprss)".
														----> a importancia de se conseguir o resultado é que se pode processar inputs com "exprss" e "id" juntos,
														que é o que está faltando para processeguir para codificação de "Expressao", com "SearchRegexExpression"...
														----> codigo para cenario de teste anterior, nao foi atualizado, por isso não estava reconhecendo com o pattern resumido: "id . id ( exprss + exprss)"...


			----> (pausa) pausa para planejamento sobre: ou prosseguir com o codigo feito para expressoes regex resumido, na classe "SearchByRegexExpression",
			ou tentar obter casos mais "genericos" de pattern resumido...
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 16.09:

	----> (pausa) pausa para planejamento sobre: ou prosseguir com o codigo feito para expressoes regex resumido, na classe "SearchByRegexExpression",
			ou tentar obter casos mais "genericos" de pattern resumido...
											----> será que na classe "SearchByRegexExpression", processará input como: "a.metodoB(c+d)"??
											----> preparando para teste com "a.metodoB(c+d)", classe "SeachByRegexExpression".

	----> o que está atrapalhando é o processamento de id, exprss, contida entre parenteses.
	Isolando o problema, tem-se que processar ids e exprss entre parenteses separadamente da expressao principal.
											----> classe "SearchByRegexExpression" precisa de uma lista de expressoes- parâmetros,
											para o processamento de id, exprss entre parênteses.
											----> retirando tokens entre parenteses, segue-se o processamento de um novo input,
											com os tokens entre parenteses formando o novo input. acrescentanndo como parametro
											os ids e exprss do novo input, para a expressao search do input anterior.



	----> (testes iniciais feitos) codificado metodo "GetParameters()" em "SearchByRegexExpression" para retirada de parametros, primeiro passo para resolver input como "a+b+metodoB(x+metodoC(x))", com parametro: "x+metodoC(x)".
											----> criar uma classe especializada para "parametersSearchByRegexExpression".
											contendo o parametro, e tokens de idenficação...

											----> preparando para capturar varios parametros de varios grupos, 
											falha no metodo GetParameters(), na contagem dos indices dos tokens.
															----> não está obtendo o ultimo grupo de parametros...


											----> (ANOTAÇÃO) para se ter uma ideia da relevância dos parametros: será possivel compor e analisar expressoes como: "a.metodoB(x+c+d.metodoD(x))+1;", coisas que
											não são possiveis anterioremente neste projeto. Com utilização de recursão, é possível compor parametros de parametros, e enviar como sub-expressão.

	----> (sob testes) em outro lado: novo tipo do grupo "exprss", reconhece varias ocorrencias do grupo "exprss",
	o que anteriormente reconhecia somente com pattern descrevendo o "match" completo..
											----> resultados promissores, reconheceu grupo "exprss" em "text1+text2".


_______________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.09:

			-----> (fixado) (FAZER, URGENTEMENTE) retirar a redundância do código da classe "SearchByRegexExpression": cada input novo é recalculado a lista de "seachers":
			o que era necessária se precisava de um pattern reduzido para cada input, mas comparando os patterns de "searches" com o pattern feito
			no método "ProcessingPatterns()", não é mais necessário: bastando calcular os "seachers" uma única vez: os patterns reduzidos dos "seachers"
			são comparados ao pattern automatizado do método citado...
									---> retirado, mas continua a lentidao do PROCESSO do metodo "ProcesssingPatterns".
									---> a lista de nomes de operadores estava sendo chamada a cada instanciação da classe "TextExpression",
									que requer inicialização dos headers, que leva tempo considerável de inicialização.
									---> vale notar que este esforço é feito em tempo de compilação, não prejudica a execução de programas "compilados"...



			----> (fixado) falha desconhecida está não processando grupos de parametros corretamente.
							----> (fixado) não está processamando o ultimo parametro de um grupo, nem outros grupos.
							----> (fixado) esta retornando todos parametros de um grupo, no ultimo parametros do grupo.


			----> (feito) fixar o pattern resumido para operadores, está retornando elementos ("id", "number"),
				   quando deveria retornar apenas "exprss", como elementos do pattern resumido.


			----> (feito) fixar quando o input tem apenas um token, faz o processamento, mas sem recursão
				  para sub-expressoes.


		
________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.09:

	-----> (fixado) implementar a Expressao Literal em "TextExpression", testes para ids de literais. 
	-----> (fixado) implementar a recursão de retirada de grupos de parâmetros, criando uma lista de "SearchByRegexExpression" para todos parametros,
			feito recursivamente. Faltando a identificação de cada grupo de parâmetro, a qual é "SearchByRegexExpression", calculados nos grupos "exprss".
						---> (fixado) codificado, faltando como obter a localização do parametro, dentro da lista de expressoes "exprss".
						---> (fixado) codificado a retirada de tokens dos parametros, da entrada, obtendo indices sem os parametros...


	----> codificar a composição de parametros, na ExpressaoChamadaDeMetodo, ou ExpressaoEntreParenteses. Talvez não seja necessário..
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.09:

	----> (codificado) a inclusão de grupos de parametros, para as searches expressao que tem um grupo de parametros.
	----> (codificado) codificar na retirada de inputParametros, tokens extras como ",".
	----> retirada a lista de sub-expressoes da classe "Expressao", os searchs contem todos dados para processamento de "Expressao", lista de sub-expressao de "Expressao" é na classe currente, redundante.

				----> (fixado) não está atribuindo os parametros para a expressao search correto, pois está no metodo de atribuicao, com "this.parametros.Count==0".

	----> mais testes, como por exemplo: "a.metodoA(x,y)+b.metodoB(a,b,c)", que é preciso para "WrapperData", que requer operaçoes com chamadas de metodo e operadores....
				----> (fixar) o tempo de processamento está muito demorado.
				----> (fixado) falha no "pattern resumed automate", que está retornando uma lista extensa de "exprss".
								----> (fixado) o metodo "TextExpression.FormaPatternResumed".
												---> fixado com o input sem processamento de extração de parâmetros.
						
								----> (fixado) falha no metodo "GetParameters()", está "grudando" dois parâmetros em um só (resutltado: "x,y", esperado: "x","y").
												----> (fixado) trecho de codigo a fixar: 
								 								List<string> umParametro = tokens.GetRange(indexParentesesAbre, indexToken - 1 - indexParentesesAbre + 1); 
												----> contagem errado de indice de tokens.
				----> (fixado) está havendo "cortes" de tokens no input: (resultado: ".metodoA()", esperado: "a.metodoA()").
												----> falha utilizando string.Replace, que está extraindo "a","b", das chamadas de metodo, porque a segunda chamada de metodo contem parâmetros "a,"b"."
												----> PROCESSO de substituição de strings incorreto, função "string.Replace()".


	---> (fixado) a lista de parâmetros está funcionando corretamente. mas a associação com as sub-expressoes está faltando.
				----> associação de parãmetros está funcionando, há a tipagem de sub-expressao corretamente.
				----> fixado se resolver os "cortes" de tokens no input.

	---> (fixado) tempo de processamento melhorou, mas ainda há demora.
				----> fixado, estava obtendo tokens toda vez que fazia uma busca de match de patterns.
	--->  fixado a obtenção de operadores por "TextExpression", que estava com espaços vazios que invalidava comparações em cenario de testes.



	----> PROCESSO de retirada de expressoes, com parametros, ids, exprss, numbers, literals feito em casos complexos, justamente como é o caso de "a.metodoA(x,y)+b.metodoB(a,b,c)",
	que será REAL para o PROCESSO de WrapperData", que contem chamadas de metodo dentro de chamadas de metodo.


	---> é possível com os dados de Search, fazer o PROCESSO de montagem de "WrapperData".


___________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.09:


	----> fixar a obtenção de parametros no caso: "a.metodoB(b.metodoC(x,y)+c)".
	não está setando o tipo de Expressao (ExpressaoChamadaDeMetodo) no parametro. os parametos do parametro (x,y) está registrado, falta o tipo de Expressao.
					----> não está match para uma [chamadaDeMetodo(x,y) + c].
									-----> (está correto) o pattern automate está incorreto.
									-----> fixado um erro quanto a indices de lista de tokens, em "SearchByExpression.FormaParametros()".

					----> (fixar) falha no metodo de retirar parametros  do input de entrada.
									-----> PROCESSO  incorreto de parametros.
									-----> grupos de parâmetros está funcionando corretamente.
												----> metodo "GetParameters()" está correto...
												----> falha na recursão de parametros search em "FormaSearchersParametros()".
																-----> está falhando no calculo do "pattern automate", por isso o parametro dentro de parametro está falhando.
			
									----> formando um teste isolando o parammetro, input="b.metodoC(x,y)+c", está processando corretamente.

					----> o metodo "TextExpression.FormaPatternWithOperators quebrou!!!".
									----> regressão para uma versão estável do método...
									----> susto, a classe da versao estavel do metodo estava sem alterações posteriores...

									
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.09:

			-----> classe "SearchByRegexExpression":
						---->s(fixar) ob testes, está reconhecendo corretamente as sub-expressoes search, porem a primeira sub-expressão search está sem tipo da 
							  expressao.
											----> (fixado) a primeira sub-expressao, no cenario de teste, está como uma sequencia de chamada de metodo dentro de chamada de metodo.
											----> (fixar) está gerando uma sub-expressão search a mais.
															----> 1a. sub-expressao está com o tipo de Expressao correto....
															----> a sub-expressao a mais, em: "a.metodoA(b.metodoC(x,y,z)+c) + b.metodoB(n,m)", 
															está retornando "c" como uma sub-expressao, e "cortando" a primeira chamada de metodo, sem "+c)".
															----> (metodo "FormaSearchersParametros" )(fixar) não está retirando todos tokens de parametros dos parametros.

															----> a chamada de search-parametro está sendo feito corretamente, mas para o primeiro grupo de parametro,
															no segundo grupo de parametro não está funcionando corretamente...
																		-----> o parametro "b.metodoC(x,y,z)+c" está sendo feito corretamente, 
																			   no input: "a.metodoA(b.metodoC(x,y,z)+c) + b.metodoB(n,m)".


																



						---->(fixado) os parâmetros está sendo armazenado em 1 nivel a mais de listas.
											----> (fixar) porem está registrando um parametro a mais, e sem definição de tipo.
											---->  (fixado) em "TextExpression.FormaPatternResumedWithOperators", estava incluido como nome de operador,um token
											vazio, para (tentar) processar os tokens através de "string.split"s, isso estava gerando "operadores vazio"...

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.09:

				-----> (codificado) nova classe para manipulação de parametros: GroupParameters, que contem todos parametros de um grupo, e uma lista de tokens
				identificadores do grupo, mais um indice de entrada na string "input"....
											----> testes, validou procura de parametros, e principalmente o indice de entrada dos grupos de parametros.
											----> (fixado) está inserindo parenteses após o ultimo caracter de input. deveria apagar a assinatura de parametros....
																---> metodo "string.Remove" tem retorno para o string com o remove feito.

											----> (fixado) para o cenario de teste, o input foi processado corretamente.
																---> os parametros estavam sendo processado como sub-expressao de uma sub-expressao, fixado
																para os parametros serem acrescentados na search principal.

											----> search de "ExpressaoChamadaDeMetodo", com parâmetros, sendo processado corretamente.
																----> fixado o teste com 2 grupos de parâmetros, que estva posicionando
																erroneamente os parênteses no "input" de entrada do "SearchBtRegexExpression".



				-----> (testado) ante a confusão na extração de parâmetros nos metodos de "SearchByRegexExpression", foi recodificado
					   um metodo para extração de parâmetros, e calculo de sua entrada em relação ao "input", e modificação do "input",
					   sem os tokens dos parametros, que era o esperado....


				----> varios cenario de testes sem atualizar o metodo de validação, ante a modificação no codigo.
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.09:

				----> apos extracao de "id", não está associando corretamente os parametros, deveria ser OU na search principal,
				que no teste que falhou é uma "ChamadaDeMetodo", e que portanto o grupo de parametros pertence a ela, mas
				está registrando no id do nome do objeto. Mas seria o certo, acontece que outros testes falharam com a modificação.
								----> o teste complexo quase validou, somente a contagem de sub-expressoes está incorreto.
											----> extraiu os parametros corretamente, formando os grupos de parâmetros corretamente....
											----> input modificada corretamente...


				----> parametros são agora acrescentados na sub-search.	
				

				----> (fixado) o cenario teste mais complexo, os grupos de parametros foram calculados corretamente, mas faltou os parâmetros
					  da segunda chamada de metodo, em: "a.metodoA(b.metodoC(x,y,z)+c) + b.metodoB(n,m)", parâmetros: "n","m".
											----> (fixado) teste passou para este cenario de teste complexo, mas... outros testes falharam com as modificações feitas.
											----> este cenario de teste é o que vai se encontrar em classes "WrapperData", que contém chamadas de metodo como parametro de outra chamada de metodo.
																----> falha na automatização dos cenarios de testes, com o esperado antes das modificações no cenário de teste mais complexo.
											----> teste com cenario de teste mais complexo ainda, e passou..
											
											.
				----> (fixado) apenas uma questão: para chamadas de metodo somente, é preciso fazer o processamento de parâmetros?
											----> encontrado uma pequena "falha" na construção de "PatternAutomate", especificadamente, para "chamadaDeMetodo com parâmetros",
											tentativa de corrigir quebrou o codigo... A classe continua funcionando, somente com a especificação de parametros para chamadas de metodo é que não funciona corretamente.......
											----> não está encontrando um pattern automate adequado, a lista de ids não retornando nada....
																----> tentativa "paliativa" de isolar o problema para um caso de uso extra, quebrou o codigo em quase todos cenarios de teste.
											----> o codigo para uma "chamada de metodo", quebrou!!!. os testes para chamada de metodo falhou, mas para a chamada de codigo "simples"..
																----> regressão para o codigo estável, mas os testes não passou. Continua a dúvida: uma chamada de metodo "simples" tem parâmetros?.
																							----> o erro é conceitual: no cenario de teste, foi suposto que uma chamada de metodo tinha que ter duas sub-searchs, o que não é correto...
																----> uma ultima "rodada", para obter parâmetros para "chamada de metodo": pronto para alternativa "grupo de parametro" um nivel de abstração abaixo...
																							----> falhou, continua como está que está "estável"....
																							----> falhou, porque estava com offsetIndiceParenteses incorreto... parado para planejamento de processamento de parametros fora da lista de "exprss", e "ids".
																								  se funcionar, a chamada de metodo "simples" poderá ter parâmetros, como outro search.
																														----> funcionou, o processamento de parâmetros 1 nivel para frente, o que permite que uma chamada de metodo simples tenha parâmetros.
																							----> terminado testes para "formação de parametros um nivel abaixo", para inclusão de "ids" com parametros associados no final do metodo "ProcesingPattern()".												----> validado, a chamada de metodo simples tem parametros, agora... isso finaliza a chamada de metodo sem parametros....
				----> completado os casos de uso de "ExpressaoChamadaDeMetodo", como "metodoB(x)", sem objeto que chama o metodo, porque a chamada de metodo pode estar dentro da classe do metodo.
			
			



				----> pronto para codificação de uma classe Expressao que instancia a classe "SearchByRegexExpression", para ser empregado nos "WrapperData".
______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.10:

			----> inicio de codificação classe "ExpressaoSearch".
							----> tipo de expressoes:
											----> ExpressaoChamadaDeMetodo,
											----> ExpressaoPropriedadesAninhadas,
											----> ExpressaoNumero,
											----> ExpressaoObjeto,
											----> ExpressaoNILL, 
											----> ExpressaoLiteral, 
											----> ExpressaoEntreParenteses,
											----> ExpressaoOperador,
											codificado construção de expressões na classe "ExpressaoSearch"..
													-----> faltando codificar um metodo Clone(), para
													ExpressaoOperador, por o metodo Expressao.Clone() não
													copia todos dados de uma ExpressaoOperador.


			---> para compatibilizar com Expressao, foi acrescentado um nivel seguinte de expressao,
			adicionado a expressao currente para as sub-expressões de um container.

			---> modificar classe EvalExpression, para execução de ExpressaoOperador, retirando
			os operandos a partir da própria ExpressaoOperador.

			---> quando codificar o construtor de ExpressaoSearch, incluir o nivel seguinte de expressao,
			para uma expressao container.

_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.10:

		----> a analise revelou que:
						----> (codificação de alguns métoodos essenciais) falta metodos para as classes basicas, particularmente para "string".


						----> um conceito cruscial para programação, os "arrays", está sem implementação, já qua a classe "Vetor" foi
						retirado do projeto.... Claro, poderia implementar uma classe importada, com métodos x.GetElement(indice),
						pode ser feito já, mas uma utilização genérica de vetor está faltando, nesse sentido o "WrapperData" vetor,
						implementará o "array"!, com a sintaxe clássica de operador [], ou se personalizar vindo de conceito da matemática,
						operador <>, de vetores...
										----> na sequencia, falta métodos para cada "WrapperData"!, coisas como "size", "redims",
										"toText", para "vetor", p. ex...
												----> uma solução rápida: tornar os "WrapperData" uma classe Orquidea,
												com a utilização da API reflexão!, todos método do "WrapperData" estariam
												disponíveis para um código da linguagem... 
												----> para automatizar, fazer uma importação automática do Assembly
												do projeto, de todas classes que herdam a classe abstrata "WrapperData"!

										
										
		----> codificado alguns métodos para classe "string".
										----> (ACRESCENTAR E TESTES) não esquecer de chamar a classe, dentro do construtor da classe "LinguagemOrquidea", após a instanciação
											  das classes básicas.
										----> os metodos compoe com "Objeto" com valor= string, pois toda variavel string é um "Objeto" em  orquidea.
														----> até porque só foi ocorrido que para acessar uma variável "string", por debaixo do capô do carro,
														é utilizado o tipo de dados "Objeto", dentro da execução do código.



___________________________________________________________________________________________________________________________________________________________________________________________________________________
										
										----> (PROCEDER NA CLASSE EVAL EXPRESSION) a verificação do nome do método de acordo com o objetos caller, é necessário, por causa do polimorfismo...
										não se pode carregar o método diretamente vindo da compilação, pois o objeto caller pode mudar de tipo,
										apesar de ter a mesma assinatura de parâmetros...
										
										
										----> acrescentar no RepositorioDeClassesOO, a lista de métodos das classes "string", "float", mencionado anteriormente
										e a seguir...
										
										
										
										-----> um insight! Chamadas de método devem copiar o valor do objeto caller,
										para executar uma execução de método! Isso já é feito na função "Metodo.ExecuteAMethod"!,
										então chamadas como a.metodoA(parametro), é igual a metodoA(a, parametro).
										segue-se então que "a" é um parâmetro, passado na lista de parâmetros da execução do método...
														-----> as funções então tem que começar como o primeiro parâmetro o 
															   objeto caller, com dados para execução da função...
														-----> o valor do objeto caller é adicionado a lista de parâmetros.
														
														-----> as funções string codificadas estão corretamente padronizadas.
														
														-----> a execução de método atual, criar um parâmetro chamado "actual",
														que copia o valor de objeto para dentro do método. Pode-se copiar
														diretamente o valor do objeto caller na lista de parâmetros....
										
 
														----> a classe "Metodo" deve ter uma propriedade booleana, que
														indica que o primeiro parâmetro é o objeto caller, dentro da lista de parâmetros 
														do método. Então, o primeiro parâmetro deve estar explicitamente listado
														na lista de parâmetros do método, e que [true] o codigo adicionará
														este primeiro parâmetro para a lista de parâmetros do método....
																		----> valor default [false], o que não copiará o objeto caller,
																		para a lista de parâmetros.
																		
																		----> se [true], na classe eval expression acrescentará
																		automaticamento o objeto caller na lista de parâmetros da chamada
																		de método, pois é preciso validar a lista de parâmetros...
																		
 
				------> funções string: copy, compare, reverse (verifica se text1< text2, text1>text2, ou text1== text2, pelas letras do string),
				

				------> funções matemática para classe "double":
										root2, power, log, exp, round, toText FromText, abs, clamp...., atan, asin, acos, sin, cos, tan, sinh, cosh, tanh, PI, e,

										
				------> já prometido, a biblioteca "arquivos" E/S de arquivos, deve implementar como classe base do Orquidea. faltando
				especificar as funções desta biblioteca...
											------> ESTA BIBLIOTECA "TEM QUE SER" UMA BIBLIOTECA "MANAGED CLASS", com acesso à blblioteca C++ "fstream",
											porque há acesso tanto a "texto", quanto a outro tipos, como "byte", "int_16"..., além do conhecimento cruscial
											sobre "managed class", "unmaneged class", abrindo horizonte de uma ampla gama de aplicações C++ para C sharp.
							
_________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.10:

				----> funções de string feitas completamente com objetos "Objeto", para ser utilizado com objetos
				na linguagem.

				----> codificação de métodos da classe double.

					----> (feito) não se esquecer de acrecentar os metodos de string e double na classe "LinguagemOrquidea".

				----> codificar um método para escrever dados da classe "Objeto".
____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.10:

-----> (feito )ADICIONAR UMA NOVA "ExpressionSearchInstantiate", para expressões de instanciações.
	   As instanciações estava antes na "ExpressaoObjeto", mas estava uma "bagunça"...
							----> criado como "ExpressaoInstanciacao". apenas os dados, sem métodos
							de extração e validação deste tipo de expressao.


-----> (feito) ADICIONAR NA "SearchByRegexExpression", um pattern "id id = exprss", que codifica
para expressões de instanciação.
							----> precisou de 3 patterns para expressao instanciacao:
												-----> "id id = exprss",
												-----> "id id = id",
												-----> "id id = number".
								  e o pattern code vindo do searchers é o pattern para extrair: "id","exprss","number", "operadores".

								  ----> interessante que mesmo um pattern que mistura "id" e "exprss" conseguiu ser parseado, com a ordenacao no indice da lista de searchers


-----> (feito) CODIFICAR no metodo um bool para acrescentar ou não o objeto caller, na lista
de parâmetros de uma "ExpressaoChamadaDeMetodo". o bool iniciar com false por default.
									---->(feito) sinalizar que os metodos das classes "double" e "string" tem esta propriedade= true.


-----> (feito, aguardando testes) CODIFICAR nos metodos de validação de parâmetros, a opção de acrescentar o caller
na lista de parâmetros a validar.
				----> métodos como b.tan() serão possiveis, melhor que tan(b),
				passando para a lista de parâmetros do método o caller.


-----> (verificado) (VERIFICAR) SE OS METODOS da classe "string" e "double", todos tenham um parâmetro que é o objeto caller,
a fim de compatibilizar com a forma de chamar metodos destas classes. 
				----> metodos da classe double fixado, em 3 metodos faltantes de objeto caller.
				----> metodos da classe string fixado.


-----> (feito) verificar se é necessário ter a lista de tokens de uma expressao. Em "SearchByRegexExpression",
       a inputRaw contem a lista de tokens da expressão extraída...


________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.10:

	
			---->(feito) modificar a classe "Metodo" funções , para incluir se necessário, o objeto caller na lista de parâmetros,
				  de acordo com a propriedade booleana "isIncludeCallerIntoParameters= true".
								----> modificado feita na classe "EvalPosOrdem", pois precisa para encontrar metodos compativeis.
				  
			----> (feito) modificar a classe "EvalPosOrdem", para no resultado de uma chamada de metodo, se for um Objeto, empilhar não o objeto, mas
			o valor do objeto.
								----> modificação já feita no codigo anteriomente.

			----> (sendo codificado) terminar o codigo da classe "ExpressionSearch", com a codificação do construtor da classe.
								----> o construtor deverá ter uma string do codigo da expressao.
								----> testes para a classe "ExpressionSearch".
												----> (codificado) terminar o  codigo do metodo: "CloneExpressaoOperador".
												----->(a fazer) terminar o codigo do metodo ExpressaoDeOperador.


								----> (feito) setar os tokens de todos metodos "ExpressionSearch".


			----> (FIXADO) o codigo do compilador (Processador) quebrou!
								---> o extrator de classes não está funcionando corretamente....
												----> ultimas modificações do codigo, mudança de extração de metodos
												por headers, uma variavel parametro estava erroneamente instanciada
												como "headersMethod", e não "headersProperty", na classe "ExtratorOO".

												---> todas propriedades e objetos tem que serem instanciados. sem instanciar, gera erros.


		    ----> testes para obter expressao chamada de metodo falhou.
								---> a falha está na instanciação do "SearchByRegexExpression", não está retornando
								os ids.
												----> modificações no codigo, substituindo os pattern por pattern code, resultou em falha.
																----> fixado, todos testes passou, até onde os testes vão, o código parece estar estável..
								---> (fixar) obter dados da chamada de metodo estão resultando em metodo diferente do metodo,
								está retornando o metodo anterior.
												----> erro no metodo de extrair parâmetros: para parâmetros numeros, não está reconhecendo.
												----> aparentemente foi fixado, o tipo de numero não estava sendo calculado.
								---> fixado, teste "simples" passou.

								

			-----> finalmente a distinção de operadores unários pos e pre (c++, ++c), foi codificado, classe "FileHeader".
								----> calculo de operadores unarios, classe "EvalExpression", atualizado, para distinção de operadores unarios pre e pos ordem.
													----> TESTAR A CLASSE "EvalExpression", ALÉM DAS EXPRESSOES CHAMADA_DE_METODO, TAMBÉM AS EXPRESSOES_OPERADOR, PARTICULARMENTE OPERADORES UNARIOS POS E PRE.


			-----> VERIFICAR E CODIFICAR os TipoDaExpressao para todos tipos de expressão. É importante para validar os operandos
			são do mesmo tipo e possibilitando "casting".


		

____________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum  14.10:

		----> testes para "ExpressionSearch":
					----> Expressao Numero, implicitamente em testes para outros tipos de expressao.
					----> testes para operadores binarios, simples até complexo (4 operadores, 5 operando).
					----> testes para chamada de metodos simples, mas com parâmetros números.
					----> testes para propriedades aninhadas simples,  mas que envolveu a instrução "create", e construtores sem parâmetros.

					----> (FALTA) faltam testes extremamente complexos para Expressoes Operadores e Chamadas de Metodo, que é o que 
					vai exigir nas classes de "WrapperData"...


		-----> (codificado) para manter a compatibilidade com o codigo de avaliar expressões, colocar os operandos e operadores numa lista de expressões,
		até porque a ordem de calculo pode mudar (ex.: a+b*c, é preciso calcular primeiro b*c, depois somar a+b*c, o que é
		feito no método Expressao.PosOrdem()). lembrou-se da sintaxe de avaliação de expressões: os operandos são empilhados,
		e a cada operador aparece, conforme a colocação em pos-ordem, é desempilhado operandos, e calculado o resultado do operador.

		-----> (feito) VERIFICAR E CODIFICAR os TipoDaExpressao para todos tipos de expressão. É importante para validar os operandos
			   são do mesmo tipo e possibilitando "casting".


		-----> (fixado) falha grave na obtenção de metodos compativeis com a lista de parâmetros: é preciso incluir o nome do método, vindo 
			   da construção search. Os metodos compativeis são metodos polimorficos, que tem o mesmo nome, para lista de parametros diferentes entre si.
		


		-----> (fixado) fixar a expressao search chamada de metodo...
							----> o nome do metodo compativel estava utilizando um metodo GetNome(),
								  herdado de "Objeto", pois "Metodo" é classe herdeira de "Objeto",
								  então o nome do metodo é obtido por "nomeMetodo.nome"...

		
	

		----> (codificado) a expressão operador tem que ter um container de classe igual a este tipo de expressao, para fins de 
			  identificação de tipo de expressao, quando tem que reconhecer  em classes como "EvalExpression".


							----> erro estranho: em cenarios de testes com objetos de mesmo nome, falha na compilação...


		----> (teste feito) testes para propriedade aninhada, demorou porque houve engano no codigo do teste....


		----> o compilador não está construindo o corpo dos métodos!!!.
				----> o metodo de compilar metodos não está sendo chamado, erro de lógica... fez-se modificações, e os testes não detectaram a falha.
				----> as expressoes de atribuição sem definicao não estão sendo processadas!.(fixado).
								----> no construtor de uma segunda classe codificada, não está compilando as instruções do método.
								----> erro estranho: variaveis de mesmo nome, e de classes diferentes, em construtores, não compila a instrução em que a variável está.
								----> (FIXAR) este erro estranho: expressões repetidas dentro de corpo de método não são reconhecidas.
														-----> as propriedades da classe não estão sendo passadas para o corpo do metodo, para acesso!.
									    ----> o erro é de referência (ponteiros para memoria), transsferindo cópias das listas de instrução, o erro
									   quanto aos construtores, de expressões de mesmo nome, foi resolvido.
										----> fixado, quanto às instruções, havia um erro no otimizador de expressões, que estava
										tentando acessar expressoes iguais com ponteiros= null... a parte do codigo deletava expressões iguais,
										o que talvez seja necessario utilizar mais dados, como o nome da classe e do metodo, para
										especificação da expressão a otimizar.

________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.10:


	----> codificando e sob testes:
			----> implementar propriedades aninhadas com mais de uma propriedade alem do nome do objeto: obj.propriedadeA.proprieadadeB,
			----> implementar chamadas de objeto com duas ou mais chamadas aninhadas> obj.metodoA().metodoB().metodoC().
								----> search fica assim: na segunda chamada, o objeto fica sendo o metodo da chamada anterior,
								e o metodo fica sendo o token da 2a. chamada.
								----> (codificado) CODIFICAR A EXTRAÇÃO DE PARÂMETROS, EM CHAMADAS DE METODO ANINHADAS.
													----> fixado metodo para extração de chamadas de metodos aninhadas, sem e com parâmetros.
								----> o metodo implementado pode processar chamadas de metodo e propriedades aninhadas entercaladas se for preciso.

								----> testes para esta funcionalidade, mas o codigo quebrou para expressoes como: "a.metodoA(x,y)+ b.metodoB(a,b,c)",
								está retornando 3 chamadas de método, o correto é 2 chamadas.
													----> a 3a. chamada é "fantasma", não tem ids, exprss, parametros, ou sub-searchers.
													----> o 2o. operador dot é de uma outra chamada de método, não uma chamada de método aninhada.
																	----> "a.metodoA(x,y)+b.metodoB(a,b,c)", o 2o. operador dot está na segunda expressão...
																	----> feito novo teste para diferenciar: "a.metodoB().metodoC() de a.metodoB()+b.metodoC()".

								----> fixado, com testes. era problema de indices, estava incompleto os calculos de "IndexOf".




	----> (mudança feita) sobre funções double e string, os parâmetros não são do tipo "Objeto", mas sim do tipo "object",
		  porque há avaliação de expressões-parâmetros que retornam não o tipo "Objeto", mas tipo "object".
									----> mas... senão haver tipagem correta, pode ocorrer erros em tempo
									de execução, indectáveis em tempo de compilação. Então, eliminar tipos
									"Objeto" e "object" e correção para seus tipos corretos, só melhorou
									a qualidade do código, pois pode-se validar em tempo de compilação, os tipos dos parâmetros.
												----> no codigo da semana passada, a codificação com "Objeto",
												não tinha como validar os parâmetros dos métodos..

									----> fixado a função que encontra metodo compativel com o nome e assinatura de parâmetros,
									e o case de ter o primeiro parâmetro para incluir o objeto caller que chamou o método....

						
	
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.10:

	---> resumo do código:
				---> o codigo está parado na funcionalidade de processamento de aninhamento. e só. resolvido
					 este processamento, pode-se seguir na codificação de "ExpressaoSearch", muito mais completo
					 porque os ids são agora identificados quanto a seu tipo de expressão, melhorando a resolução
					 de instanciação de "Expressao".

				---> os testes que falhou foi em input que mistura propriedades aninhadas com chamada de métodos aninhadas...
									

	---> HÁ EXCESSO DE PALAVRAS NA NOMEAÇÃO DE VARIÁVEIS E MÉTODOS!! ESTÁ dificultando a leitura da LÓGICA MATEMÁTICA do código...





	---> (fixado) o metodo de processamento de aninhamento está criando "subSearchers" "fantasmas"...
					---> um erro "if/else": o else não estava com uma condicional, e sempre que o "if" falha, o "else" era executado.
					---> continua calculando "subSearch"s "fantasmas"!.
									----> o problema nos "searchs" de ids, que calcula erroneamente "ExpressaoObjeto" fantasmas...
									----> (fixado) erro nos indices de tokens "." e "(".
									----> voltou à situação de 1 dia anterior, com "ExpressaoObjeto" a mais, no processamento de "b.propriedadeB.metodoC()", p. ex.
													----> agora sim! As ExpressoesObjeto estavam sendo calculadas a mais, no processamento de "ids".
									----> pode melhorar: no processamento de ids, retirado, para "ids.length== 1", instanciar
									uma "ExpressaoObjeto", "ExpressaoLiteral", ou "ExpressaoNumero", "ExpressaoNILL", que são 
									os tipos de expressão com um só id...
													----> (feito) ids agora são também searchers, com tipo de expressão definido....

					---> (fixado) um problema de qtd de tokes em textos regex de pattern resumed: o texto regex de "id . id",
					vem depois de "id ( id", e está retornando como tipo "chamada de metodo", ou seja,
					o texto "id ( id".
									----> o pattern resumed está sendo feito, regex match o input, mas
									mesmo assim, o pattern regex está reconhecendo não pattern resumed,
									mas substituindo token "." por "(".
													----> fixado no GetExpression(), modificava o pattern resumed,
													com o patter code do regex texto do searcher.


					----> o problema de tipagem de expressao continua, foi feito ordenação decrescente 
					pela quantidade de tokens, mas continua fazendo match de "id.id", como "id.id()".

					----> modificação no método "MatchPatterns", resultou em vários testes falhos...
					mas há condições de fazer a análise deste jeito...


					----> (fixado) (FIXAR URGENTEMENTE) HÁ UMA CLARA FALHA NO METODO DE PROCESSAMENTO DE ANINHAMENTO, O CODIGO
					ESTÁ QUEBRANDO NESTE METODO...
												 ---> modificação no metodo de match patterns melhorou a qualidade
												 do codigo, 2 testes falharam.


					----> (fixado) para um conjunto de propriedade aninhada: "objB.propriedadeB.propriedadeC", 
					reconhece, mas para além, não está reconhecendo...


												
					----> (feito, fixado) (A FAZER, URGENTEMENTE) o conceito de localizar os operador dot e parenteses está erroneo.
						  codificar um metodo de calcular o indice de parenteses, sendo no minimo o indice do operador dot, ou retornar -1,
						  se o indice não alcançar o indice do operador dot, não localizando mais indice de parênteses.
									com os indices certos do operador dot currente, e do parenteses, pode-se calcular 
									uma ocorrencia de propriedades aninhada, ou chamada de metodo aninhada....
												----> codificado com contador de grupos encontrados,
												para calculo do indice de parenteses vindo de input.

												----> codificado, testes passaram.




	---> (FEITO) (incluido um teste com chamadas de metodo dentro de chamadas de metodo, operador) testes mais complexos, para classe "SearchByRegexExpression", para verificar expressoes uteis para "WrapperData".

	---> atividades diária feitas, prosseguindo com a proxima atividade de Daily Scrum seguinte:
				---> (CODIFICANDO) completar o código de "ExpressionSearch".
								----> codificado mas nao testado metodo de encontro de operador compativel. A determinar
								como será a entrada caso o operando seja unario...
										----> se o indice do operador no search for menor que o indice de seu operando unico, será unario pre.
										----> senão. se o indice do operador no search for maior que o indice do seu operando unico, será unário pos.
										----> é preciso os tokens do search para complementar a codificação.
								----> codificação de "ExpressaoOperador"  feito, com amplas modificações, mas
									  mantendo o formato requerido na classe "EvalExpression".

_____________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.10:

	----> (codificado) complemento de "ExpressaoSearch.PropriedadesAninhadas", para compor com multiplas propriedades aninhadas, e multiplas chamadas de objeto.

	----> codificado "ExpressionSearch" para:
				----> expressao operador.
				----> expressao objeto.
				----> expressao numero.
				----> expressao nill.
				----> expressao propriedades aninhadas.
				----> expressao chamada de metodo.
				----> expressao literal.
				----> expressao instanciacao.
				----> expressao entre parenteses.

	----> testes para "ExpressionSearch":
				----> (feito) testes "simples" passou.
				----> (fixado) teste de expressao complexa, com chamadas de metodo como parametros de outra chamada de metodo,
							---> (fixado) alguns erros no cenario de teste, fixado.
							---> (fixado) expressão sem tipo definido, fixado, para expressão chamada de método.
							---> (fixado) falha de operadores, operador igual estava como "Binario" (igual), e "Unario" (atribuição),
							retirado o operador igual "Unario".
							
							
							---> (fixado) está retornando sem lançamento de exceção, mas está cortando o primeiro operando de uma expressão operador.

							---> antiga classe de "Expressao", método "Expressao.ExtraiExpressoes", está retornando
								 erros quando não encontra tokens de expressão.
					
							---> Epílogo: um erro no tipo de expressão de ExpressaoChamadaDeMetodo,
							de tipo como objCaller.GetTipo(), quando o tipo é metodo.tipoRetorno, 
							causou a falha no processamento do operador compativel, que
							estava retornando operador compativel= null..., foi criado
							o lançamento de erro quando operador compativel = null,
							mas como a expressão do teste está correto, os operadores compativeis não é null.



	----> feito testes simples, complexo, implementar a "ExpressaoSearch" como um metodo de Expressao.
	Retirar os metodos das Expressao, VerificaSeEhExpressao, GetSubExpressao, que é propenso a erros devido a muitos
	linhas de codigo, o que vai simplificar e tornar coisas como expressoes chamadas de metodo como parametros
	de expressoes chamadas de metodo, possivel. Expressoes chamadas de metodo como parametros de expressao
	chamadas de metodo é o que se encontra nos "WrapperData", em seus metodos "GetElement()", e "SetElement()".


	
					
_____________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.10:

	----> implementar em "Expressao", uma instanciação de "ExpressionSearch", para retirar "Expressao"s,
		  via expressoes regex.
							----> (feito) retirar os metodos de todas Expressao: VerificaSeEhExpressao, e ObtemSubExpressao,
							que foram aumentando em linhas de codigo devido a cases encontrados,
							e que não era possível a complexidade encontrada em "ExpressaoSearch",
							e que é necessário para as classes "WrapperData"...

							----> (feito) no construtor de "Expressao", adicionar uma expressão container, para compatibilizar
							com execução de expressoes na classe "EvalExpression". E para expressao operador,
							não adicionar um container: a expressao operador já vem em um container...

							----> (a fazer) codificar o metodo "Expressao.InitExpressao()", faltando instanciar a expressao currente.


			---> fixar o metodo "Processador.Matchsequencias";
							---> não está reconhecendo uma expressao: "a=4;".
							----> o erro não tem nada a ver com a migração para "ExpressaoSearch" no processamento de "Expressao".
							----> o erro está em: "Expressao.ExtraiUmaExpressaoSemValidar()".
							----> regressão para testes de "SearchByRegexExpression",
								  não está formando o pattern resumed correto.
										----> o operador "=" não está na lista de operadores. uma
										falha na lista de operadores, que foi modificada eliminando o operador 
										de atribuição...
														----> operador "=" estava sendo eliminado da lista de operadores!. 
														como havia dois operador "=", a eliminação anterior eliminava um dos operador "=",
														mas ficava um operador "=", por isso os testes passavam.
																				----> mantendo o codigo com a retirada do operador "=", houve testes > 5 que não passaram
																	----> fixado, teste simples passou.
																			---> todos menos 1 teste passou. teste falho em "ExpressaoInstanciacao",
																			com pattern resumed para "exprss = exprss", o esperado era "id id = id ()".
																			----> o operador "=" em outro metodo não estava sendo retirado. "SearchByRegexExpression.GetNomesOperadores()".
																			----> OPERADOR "=", não é um operador, matematico, ou condicional, booleano, mas faz parte de Expressoes,
																			que pode-se considerar um operador no PROCESSO de avaliação de expressões.
																			
																	----> todos testes de "SearchByRegexExpression" passou.


			---> (fixado) quebra de codigo de "MatchSequencias" continua.
							----> método "new ExpressaoInstanciacao" está quebrado... por conta do conceito de "container" de expressão.
																	----> retirar o metodo de instanciar "container", e "ExpressionSearch".

							----> método "ResumeExpressoes" continua quebrado. E faz parte 
							do novo "modelo" de processamento de expressões.
							----> investigando, o conceito de incluir um container para "Expressao",
							parece que está errado.
																	----> o metodo "ResumeExpressoes",
																	pode ser substituido por um "patternResumed?".
																	----> o metodo "ResumeExpressoes" não
																	foi feito para funcionar com "ExpressaoInstanciacao"!,
																	o codigo quebra porque não há previsão para este tipo de expressao...

																	----> (FIXAR COM CODIFICAÇÃO) o codigo no teste resultou exatamente no case deste tipo
																	de expressão, em que há nenhuma sub-expressao na expressao a ser resumida...
																						----> FIXADO com "codigo cola", que resolve
																						este case, mas não há garantia que vá funcionar em
																						outros cases de expressao de instanciação.
																						----> continua com nao instanciação de objetos.
																						----> parece que o codigo anterior de "Expressao"
																						instanciava objetos em seu processamento...
																									----> CONFIRMADO, o codigo anterior de "Expressao" instanciava 
																									objetos, em seu processamento.
																												-----> fixado com codigo de "ExpressaoInstanciacao"
																											para instanciar o objeto se não já houver ter sido instanciado.

	----> INSIGHT: pode-se substituir o metodo "ProcessadorID.ResumeExpressoes", com "TextExpression.FormaPatternResumed"?,
		  porque o método "ResumeExpressoes" é muito complexo, e qualquer adição de tipos de expressoes, não faz o processamento...
								-----> é possivel, utilizando "SearchByRegexExpression",
								eliminar tokens de expressoes, de acordo com o tipo de expressao.
													----> o pattern reduzido não processa muito bem sequencias
													de tokens com palavras-chave que não pode ser simplificado.


	----> justamente a expressao que não acrescenta um container-expressao, e que não tem previsao no metodo
	"ProcessadorID.ResumeExpressoes()", é que quebrou o teste inicial de "ExpressaoSearch", após
	a "migração" do processamento de "Expressao" via "ExpressaoSearch".
								----> o container no metodo "ExpressaoSearch.ExtraiExpressoes" não está correto.
												-----> retirado o container para formar expressoes.
			----> o compilador não está compilando as instruções dos métodos....
								---> o resume expressoes não está executando um termo-chave como "ID".

	----> testes estão passando, mas está demorando muito para completar.
	talvez seja melhor codificar e seguir em frente, como se a integração "ExpressaoSearch"--->"Expressao",
	estivesse fluindo normalmente.
						---> é alguma propriedade estática que aumenta com o processamento.
										----> verficação de classes: 
													----> classe "SearchByRegexExpression" está com tempo de processamento já verificado anteriormente.
													----> classe "ProcessadorID", onde está o compilador, está demorando demasiadamente.
																----> fixado alguns erros, está com tempo de execução melhor.
																----> estava incializando os headers todas vez que terminava uma compilação,
																a idéia era preparar para um proximo teste, mas a compilação era
																feita internamente muitas vezes, não uma unica vez no cenario de teste.
						---> (fixado) inicilizava os headers toda vez que terminava uma compilação,e
						tb os seachers de "SearchByRegexExpression".

	---> seguindo os testes da migração de busca de expressoes, uma simples instanciação
	causou muito tempo para fixar, um erro em instanciar/não instanciação de um objeto, em "ExpressaoObjeto".


	---> DEFINITIVAMENTE, EXPRESSAO COMO container de sub-expressoes, alinhou o codigo de "Expressao" com processamento via "ExpressaoSearch",
	foi o que resultou resultados esperados. INCLUSÃO do container em Expressão.
	
	---> boas e mau: a classe "Expressao" está com containers, como era na classe "Expressao" anterior,
	espera-se que a adpatação do código, no processamento de expressoes, seja "suave".
	MAS está gerando erros de natureza desconhecido...




	---> (reescrevendo) UMA IDEIA que ocorreu É ESCREVER MENSAGENS DE ERRO QUE POSSA LOCALIZAR O LOCAL DO CODIGO EM QUE OCORREU O ERRO,
	P. EX., SE O ERRO OCORREU em ExpressaoObjeto, um erro neste metodo teria que ter a mensagem "erro interno na classe ExpressaoObjeto, etc...".
							----> instruções que disponibilizam mensagens de erro (sintaxe, falta de tokens chave, expressoes invalido,etc...),
							reescritas para sinalizar de onde gerou a mensagem de erro, erro do programador que utiliza a linguagem.

________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.10:

	
	----> Resumo: testes para Expressao, com processamento via ExpressaoSearch, e SearchByRegexExpression.
			  com os testes feitos, pode-se senão já, codificar o planejado para WrapperData, de inicio,o Wrapper "Vector".
								----> inicio codificação "Wrapper" Data.


	----> o codigo do WrappeData "Vector" está meio confuso, refatorar para melhor legibilidade e robustez a erros.
								----> codificação do wrapper estava confusa tb., recodificada.

								----> (2 tipos) tipo de elemento em vector pode ser uma expressao, ou um object genérico,
								como numeros,strings, bools, etc...
											----> há a possiilidade de retornar um valor constante,
											ou de uma avaliação do elemento expressao.

								----> CONSTRUÇÃO DA EXPRESSÃO CHAMADA DE METODO para anotação de "Setar o Elemento", em "WrapperDataVector".
												---> a expressao a construir em "setar elemento" tem que ser uma "ExpressaoInstanciacao", não
												uma expressão chamada de método... legal ver que o conceito de substituir uma notação abstrata
												num acesso a um metodo wrapper, continua valido mesmo se mudar o tipo de expressao de retorno...

								----> (VERIFICAR URGENTEMENTE) VERIFICAR SE A INSTANCIAÇÃO, COM EXPRESSÕES COMO ELEMENTO, SÃO CALCULADAS UMA VEZ SOMENTE, 
								POIS SE DEIXAR COMO EXPRESSÕES-PARÂMETROS, SERÁ CALCULADO SEMPRE OS ELEMENTOS ATRAVÉS DESTE EXPRESSÃO.




	----> (codificando) codificar metodos de manipulação de objetos classe "Vector", como "size","resize","push_front","push_back","pop-back", etc..
				---> metodos:
						---> size;
						---> resize;
						---> insert
						---> remove;
						---> push_back;
						---> pop_back;
						---> push_front;
						---> push_back;
						---> Get;
						---> Set;


	----> (verificado) verificar se é melhor unir a classe "Vector" com a classe "WrapperDataVector",
	      pois outros "Wrappers" terão, opcionalmente, dividir também em duas classes para implementar um "Wrapper".
						----> melhor deixar em duas classes, a classe "Vector" contem também metodos que
						relacionam com a classe "Vector" somente, ficando extenso e com responsabilidades amplas demais....



	----> casting de parametros em chamadas de metodos:

			----> para metodo UtilTokens.GetCompatibleMethod(), para metodo de encontrar metodo compativel com os parâmetros de uma chamada de método.
							  se os parâmetros do método for "double", "float", E o tipo de expressão-parâmetro for "int", faz-se
							  o "casting". pois um int pode ser calculado como double ou float...

			----> (a fazer) para tipos com herança, implementar o casting para tipos herdados.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.10:

	----> testes para classe "Expressao":
				----> (fixado) foi preciso recodificar a compilacao de metodos, em "ProcessadorID".
				----> (FIXAR POSTERIORMENTE)Expressao "ExpressaoEntreParenteses" está quebrado...
				----> regressao para testes da classe "ExpressaoSearch", não está reconhecendo uma expressao "ExpressaoInstanciacao".

				----> o codigo de "ProcessadorID.MatchSequencias" e "ProcessadorID.ResumeExpressoes" quebraram!!!
									----> (fixado) advinha quem quebrou? A nova "ExpressaoInstanciacao",
									que não estava obtendo corretamente a expressao de retorno,
									e nomes de objeto e classe do objeto...
				----> (FIXAR) o codigo de "ProcessadorID" e "ExpressaoSearch" estão demorando demais...
									----> estranho mas os testes da classe "Expressao" demoram
									menos que "ExpressaoSearch", mas "Expressao" chama "ExpressaoSearch", e então...
				
				----> a paranoia está atacando...


			


	----> analise: é possível, com o mapeamento feito no compilador "ProcessadorID", retirar expressões regex! que simplificariam
	enormemente o codigo, que tem um "calcanhar" no metodo "ProcessadorID.ResumeExpressoes", com muito codigo que mapeia, mas dificulta
	a extensão de mais metodos "tratadores de mapeamento". Faz tempo que se deseja retirar este metodo e sub-jacentes, visto a complicação
	"Aristotélica", e não "Logica Matematicamente pensando"...
							----> vendo o codigo, dá para fazer! utilizando o mapeamento feito, mas calculando "pattern resumed" com
							poucas modificações (como "id" em lugar de "ID"), ou acresimos (como "BLOCO"= "{ <exprss>* }" ).
							
							----> não retirar o codigo anterior, mas fazendo um novo metodo "MatchSequencias", e substituindo o metodo currente...
							se não houver complicações, aí sim pode-se retirar os metodos chamado por "ProcessadorID.ResumeExpressoes"..
							
							----> BOAS NOVAS! TESTES COM PATTERN RESUMED vindo do ProcessadorID.InitMapeamento(),
							RECONHECEU O pattern da instrução "for"!, é possivel tornar o compilador
							mais robusto, pois o metodo "ProcessadorID.ResumeExpressoes()" está
							muito complexo, e sujeito a erros não detectáveis....



	----> analise: um ponto critico talvez seja encontrar um metodo compativel com os parametros de uma
	chamada de metodo. valores que nao mudam retornam o valor antigo, mas para manter as caracteristicas
	de programação orientada a objetos, é preciso encontrar um metodo compativel a todo momento...
						----> otimizar o metodo "FindCompatibleMethod", como p. ex.: guardar em uma variavel,
						o nome e tipo do metodo que faz a chamada de metodo, evitando chamar o metodo de compatibilidade,
						se não houver mudança de objetos que fazem a chamada...
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.10:

urgente:
				------>(feito)  DIFERENCIAR ENTRE EXPRESSAO ENTRE PARENTESES DE EXPRESSAO CHAMADA DE METODO: na extração de parâmetros,
						não está capturando expressoes entre parenteses: parametros pedem um id antes do parenteses, e expressão entre parênteses não...
								-----> FIXAR O METODO DE EXTRAÇÃO DE PARÂMETROS, EM "SeachByRegexExpression", para diferenciar de expressao entre parenteses e-virgula
								expressão de chamada de metodo, verificando o token anterior do parenteses "("....
												----> (feito).
								-----> (feito) para validar a diferenciação de expressoes entre parenteses, testes
								para "SearchRegexExpression".
												-----> falha em reconhecer "ExpressaoInstanciacao".
														----> match patterns não tinha previsão de igualdade de "number" e "exprss".
												----> para propriedades aninhadas, o codigo entrou em loop infinito!
												----> condição de "ExpressaoEntreParenteses" mal resolvido,
													  fixado.
												----> todos testes passou.



	-----> (CURIOSIDADE) volta para testes "Expressao", não está reconhecendo uma expressao entre parenteses.
		----> volta para a velocidade de processamento esperada...
		   	  POR QUE???

				
				-----> (feito) ESCREVER UMA EXPRESSAO PARA ATRIBUICAO, DISTINGUINDO de  "ExpressaoInstanciacao",
					    de "ExpressaoAtribuicao"... expressao nova: "ExpressaoAtribuicao", que não instancia objetos.
												----> testes em "ExpressaoSearch", para "ExpressaoAtribuicao", feita.



	----> feitos nesta semana:
					-----> nova expressão: "ExpressaoInstanciacao".
					-----> nova expressão: "ExpressaoAtribuicao".
					-----> distinção entre "ExpressaoEntreParenteses" e "ExpressaoChamadaMetodo",
					no metodo "SearchByRegexExprssion.GetParameters()", pois estas expressoes
					tem parenteses em seus tokens.






					----> (feito) O CONCEITO DE PROPRIEDADES ANINHADAS, MAS DE 1 PROPRIEDADE, NÃO ESTÁ CERTO, é preciso carregar as propriedades
					da classe no objeto caller, e então testar se a 2a. ou mais propriedade aninhada está como campo do objeto caller.
					
								------> (feito, na propria classe "Objeto") codificar em "UtilTokens", o carregamento das propriedes de uma classe, para um objeto desta classe (objeto parametro do metodo).
					----> (feito) a validação dos parâmetros, na "ExpressaoChamadaDeMetodo", do
					metodo "ExpressaoSearch.PropriedadesAninhadas", está sem validação...

					




____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.10:

	-----> (fixado) fixando com testes classe "Expressao".
					----> fixado, expresssoes com operadores unarios.
					----> fixado, propriedades aninhadas, chamadas de metodo aninhadas.
									----> codificado metodo para processamento de mais de uma propriedade aninhadas numa expreessao.
									----> codificado metodo para processamento de mais de uma chamada de metodo numa expressao.
									----> fixado a extracao de propriedades aninhadas seguidas de propriedades aninhadas ou chamadas de metodo.

												----> fixar a classe "EvalExpresssion", para processamento de mais de uma chamada de metodo numa mesma expressao.

			
					----> (fixado, dentro da classe "FileHeader", que remove classes de codigo orquidea, mas mantem classes base da linguagem) o repositorio de classes, apos mais de um cenario de testes, não está sendo atualizado!!. 

					----> (constataçao, sem erros ou quebra de codigo) o codigo se autocorrige mesmo nao instanciado num Expressao.Initheaders!=null.
						  o repositorio é atualizado,  se removermos as classes do codigo orquidea. 
												----> as classes no repositorio sao atualizadas quando na construcao de uma nova classe, substituindo
												versões anteriores, mas insistiram que o codigo estava incorreto, porem houve a preocupacao
												na instanciacao de verificar versao anterior antes de instanciar uma classe.


	-----> (fixado) codificar em "ExpressaoChamadaDeMetodo", o case "funcao(a,b)", sem o objeto e o operador dot.



	----> CONTINUAR A IMPLEMENTAÇÃO da classe "WrapperData.Vector".
						----> testes para "WrapperDataVector",
									(fixado) a classe "TextExpression", pois utiliza-se operadores "[", "]", que fazem parte da expressoes regex, nao sao operadores normal.
									(fixado) o pattern resumed de wrapper data vector.
									(fixado) o metodo "Expressao.ExtraiExpressoes", que não estava
									processando uma lista de expressoes, mas uma so expressao, com os tokens de todas
									expressoes parametro do metodo.




						----> teste para instanciacao de vetor sucedido.

			-----> (fixado) o conceito de elementos de um vetor, como expressao, está incorreto:
			se não, toda vez que o codigo executa o acesso, a expressao do elemento é avaliada,
			o que é temerário...
					----> (fixado) a definicao de um vetor está correta: é do tipo "object", nao "Expressao".
					então a modificação tem que ser na instanciação "WrapperDataVector"...


		----> (verificado) verificar se operadores: "<",">","{", "}", fazem parte de pattern regex,
		que aí tem uma anotação a mais, para operadores que fazem parte de expressoes regex...
					---> todos operadores, incluindo ".", foram reconhecido no processamento regex...

		----> refatorado o codigo de formar pattern regex, em classe "TextExpression",
		para tonar mais facilmente expandivel os operadores que fazem parte de patterns regex,
		como +,-,[, ]. Se houver algum operador não previsto, insere-se na lista de operadores presentes
		em sintaxe regex, que exige um texto "\\" a mais...



_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.10:

		----> (fixado) fixar o metodo "Vector.GetElement".
					----> testes para "Instantiate", "Vector.GetElement" feitos.
					----> teste para "Vector.GetElement", dois testes ainda, feitos.
					----> teste para "WrapperDataVector.GetElementToMethodCall" feito.

		----> (fixado) test  para "WrapperDataVector.SetElementToMethodCall" feito, porém os dados do objeto
   			  caller não estão sendo setados.
					----> (fixado) precisa preencher o nome do objeto-vetor a setar, e o parametro indice,
					só está setando o valor, faltando o indice.
								----> (fixado) um erro na formação do texto, util para depuração, está duplicando
								o indice-expressao. ----> formacao de "Expressao.ExtraiExpressoes", devolve
								uma lista de expressoes, e cada expressao esta em um container expressao.

	    ----> (feito) testar com expressoes_valor, em SetElement, com objetos formando a expressão_valor.
							

		----> completado metodos de obter um texto informativo nas classes "Expressao", util para depuração.						

		----> (codificado) fixar a classe "EvalExpresssion", para processamento de mais de uma chamada de metodo numa mesma expressao.
							-----> atualizado também, o processamento de propriedades aninhadas adicionais, com chamadas de metodo dentro da expressao aninhada.
					-----> atualização segundo a nova "Expressao", que comporta mais cases, inclusive, chamadas de metodos adicionais, e propriedades aninhadas adicionais.
					-----> TESTES SERÃO FEITOS QUANDO NA AVALIAÇÃO DE EXPRESSOES, MAIS A FRENTE.


		----> próximo WrapperData a codificar: JaggedArrays!
					----> criação da classe base; codificado metodos essenciais, e Setlement, e GetElement,
					para serem utilizados em "ExpressaoChamadaDeMetodo".

		----> (feito) não se esquecer de importar para classes base orquidea, todos metodos de "WrapperData" Estructures.
					-----> não se equecer também de incluir o escopo currente para as chamdas de metodo
					que requerem um objeto escopo...
								----> mudança necessária: tipo de parametros de chamada de metodo,
								mudado de tipo "Expressao" para "object". para inserçao de objetos escopo,
								em metodos que requerem escopo.
												----> testes novamente para classe "Expressao", com a mudança
												de tipos dos parâmetros da função.


		----> (feito, sob testes) MODIFICAR URGENTEMENTE OS METODOS WRAPPER Structures (JaggedArray, Vector), de 
		parâmetros "Expressao" para "object", a fim de compatibilizar o modo como uma chamada de metodo
		é executada: os parâmetros da chamada são avaliadas quando na execução do método,
		não é preciso avaliar os parâmetros dentre do método da chamada...
						-----> manter como parâmetro da expressso chamada de metodo, as expressoes extraidas
						quando na conversão de uma anotação "wrapper", para chamadas de metodo.
		-----> (feito) voltar o tipo de parametros de chamada de metodo, de "object" para
		o tipo inicial "Expressao", pode haver problemas na conversão de parâmetros de classes herdeiras
		para a classe base "Expressao". uma Expressao não é sub-classe, mas toda sub-classe é Expressao.
		Além do que os metodos que exigiam "Escopo" como parâmetro, não precisam mais, dado a mudança de parâmetros, de "Expressao" para "object",
		nos metodos "GetElement" e "SetElement". testado com a classe "Expressao", que utiliza as listas de parametros-expressao.




____________________________________________________________________________________________________________________________________________________
Daily Scrum 28.10:
		
		----> (feito) testes feitos para "Vector", "JaggedArray", nas funções essenciais.
							----> fixado e codificado modificações classe "JaggedArray", para evitar incongruências,
							como inserir um valor em indices nao validos, preenchimento com valores 0 na inicialização do array.


		----> (feito) codificacao da classe "WrapperDataJaggedArray", que cuida da transformmação de uma anotação wrapper, para expressoes chamada de metodo.
							----> testes para esta classe:
											----> instanciacao, teste passou.
											----> construção de chamada de metodo "SetElement" passou.
											mas continua havendo o erro de texto representativo da expressao chamada de metodo.
															-----> fixado, a classe "Expressao" estava retornando um texto duplicado, com tokens e com sub-expressoes.
											----> construcao de chamada de metodo "GetElement" passou.
						
						

					
													
		----> (verificado) VERIFICAÇÃO DA EXTRAÇÃO DE EXPRESSOES, está retornando um nivel a mais de sub-expressoes de expressoes.
		verificado em "WrapperDataVector".
							----> não está retornando não, é que toda "Expressao" tem um container da classe
							base de "Expressao", e sub-elementos que é o tipo de expressão extraida.
							O fato é que na validação de testes, anteriormente, verificou-se que 
							a avaliação de expressoes, ao ver o texto representativo, chegou-se a conclusão
							erroneamente que a "ExpressaoChamadaDeMetodo" estava incorreta. Mas na
							avaliação de "Expressao" por "EvalExpression.Eval()", a expressão é avaliada
							pelos sub-elementos. Se há erro nesta classe ao avaliar ExpressoesNumero, é outra parte,
							a fixar.
										----> era isso mesmo, a expressao indice estava certa, mas o texto
											  que representa a expressao, precisa ser verificada (ToString()),
											  pois está retornando um texto que não está de acordo com a realidade.
														----> fixado o metodo "Expressao.ToString()", estava retornando
															  um texto duplicado, feito com tokens e tb sub-expressoes.


		---> codificacao "WrapperDataStructure" DictionaryText.
							----> codificado metodos:
										-----> construtor.
										-----> GetElement.
										-----> SetElement.
										-----> size
										-----> GetKeys.
										-----> GetValues.


		---> inicio codificacao "WrapperDataDictionaryText", que cuida das chamadas de metodo wrapper, e da instanciacao de dictionary text, em anotação wrapper.


___________________________________________________________________________________________________________________________________________________
Daily Scrum 31.10:

		----> codificado classe  "WrapperDataDictionaryText".
						-----> testes para classes "DictionaryText", "WrapperDataDictionaryText".
										-----> (feito) testes para "DictionaryText" passou.
										-----> (testando) testes para "WrapperDataDictionaryText",
														----> precisão em incluir operadores ":", "{", "}", porque fazem parte da sintaxe de expressoes regex,
														e nao estavam listados como operadores da sintaxe regex.
																		----> operador "=" não reconhecido em expressoes regex.
																					----> pesquisar internet o case de operador "=".
																					----> obtido com pesquisa na internet os caracteres que participam 
																					da sintaxe regex, o operador "=" é um caracter normal. Mas
																					os operadores "{" e  "}" fazem parte da sintaxe regex....

														----> o cenario de teste estava errado na expressao texto de instanciação. aí não quer nada, né?

						 ----> (feito) testes para "WrapperDataDictionayText", passou, mas a instanciação de Expressao Literal
						 da chave do dicionario nao foi testada nos cenarios de testes.
										----> a expressao literal da chave foi formada!, legal ver o codigo funcionando, quando especificado...



		----> (codificado) instrucao "GetModule", para implementar uma biblioteca.
						---> a instrução "Module" carrega para o escopo o Type especificado, e também para o Repositorio de classes.
										----> parada para pensar: e se a classe do modulo nao tiver no repositorio de classes?,
										importa de um arquivo, ou tem um arquivo texto contendo os nomes dos modulos???
										----> incluido a opcao de carregar de arquivo .dll, o modulo.
											  Houve erro anterior de tentar carregar um arquivo .dll da classe "PromptConsole.dll".


________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.11:

		----> para fins de testes, foi criada uma biblioteca .dll para importação de classes ao repositorio de classes,
			  ante ao cenario de testes para importar "PromptConsole" não funcionou muito bem... o que deu errado
			  é que este Assembly só tinha metodos estáticos, o que não foi importados pela classe "ImportadorDeClasses".
										----> immportador de classes operacional, pode-se criar bibliotecas .dll
										para construção de modulos da linguagem..



		----> (feito) codificando o wrapper estrucutre "Matriz"
					   ---> verificado o product backlog, uma wrapper estruture listada, é uma matriz.
					   ---> estudos posteriores para funções de matriz, pois só há: GetElement, SetElement, e Inverse.


		
		----> (feito) para facilitar o codigo, codificar um metodo em "WrapperData.isWrapperData",
		para direcionar o processamento Wrapper mais prontamente.

		----> (A FAZER) codificar o gerenciador de wrappers objects, a ser incluido no construtor de expressao,
		se for um wrapper object na expressao, é chamado o gerenciador, que constroi a expressao de
		chamada de metodo, e seta como a sub-expressao no construtor "Expressao".
										----> parada para pensar: se o objeto for uma estrutura wrapper, em
										que linha de codigo terá que analisar a expressão wrapper?. na expressao objeto?
										ou no analizador wrapper?

					
		----> (codificado) (prioridade baixa) implementar os pattern regex, para os tratadores em "ProcessadorID",
  			   com o textos de "ProcessadorID.InitMapeamento".
										----> mapeamento de sequencias regex codificado.
										----> handlers de sequencia agora com variavel "Regex" feito.
										----> MatchSequenciasRegex codificado, para validacao de sequencias via expressao regex.
														-----> MatchSequenciasRegex irá substituir o "MatchSequencias", feito por mapeamento de IDs.


		----> (codificado) parada para pensar como testar o match sequencias regex. em arquivo próprio?
										----> testes serão feitos em arquivo proprio de testes.
										----> ante a extensão dos testes a serem feitos, pausa para pensar demais cenários de testes.
														---> faltando definir se um patternResumed com/sem "bloco" dará certo.
																			----> processamento de blocos é feito a parte do match,
																			retirado das definicoes de pattern resumed o termo "bloco",
																			com excessao de "if-else" que requer um bloco apos o "if".




		----> (feito) (importado, na classe Linguagem Orquidea) NÃO ESQUECER DE IMPORTAR AS CLASSES WRAPPER DATA ESTRUCTURE, PARA UTILIZAR SEUS METODOS
			  NO CODIGO DA LINGUAGEM.



______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.11:


		----> (codificado) terminar o codigo de testes de match sequencias por rg expressions.
						----> testes, alguns cases validaram, mas 2 outros "passaram longe do esperado."...
									----> (fixado) testes para "while" foi o que mais impressionou na imprecisão.
									----> validado a expressao "while (x<1)", com pattern resumed "while (exprss)",
									com testes na classe "TextExpression".
									
						----> (fixado) o resultado esperado continua equivocado!!!
									----> mudança no ordenamento das instruções, melhorou, tem-se 1 case sem match esperado.

						---> integrado o novo metodo de match sequencias, e eliminado um bocado de metodos
							 sujeitos a erros desconhecidos, e muito dificil de expandir os cases, com novos tipos de instrução.
							 É desejo faz muito que se queria remover estes metodos...

						---> retirada total de todas sequencias mapeadas, metodo antigo... muitos metodos, dificultando
						a manutenção aditiva de novas sequencias, devido ao processamento de "ProcessadorID.ResumeExpressoes".


						---> (implementado, testes com instrucoes, nao sequencias de id somente, sucedido) uma novo tipo de grupos regex: termos-chaves! com termos-chaves, não é permitido
							 mudar para id, um termo-chave.
												----> a lista de patterns resumed precisa testar primeiramente sequencias que contém termos-chave...
												----> construcao de pattern resumed automatizada, e com distinção de tokens termo-chave.
													  todas sequencias contendo termos-chave, como: "if","else","while","create","for", etc...
													  foram reconhecidos. sequencias contendo somente ids não retornou exatamente, mas está
													  dentro das instruções mapeadas.

												----> quanto às sequencias apenas de ids, a falha é estrutural do processamento de expressoes regex:
												uma sequencia de tokens resumidos menor match num pattern resumed com tokens resumidos maior.
												está match porque a sequencia para match cabe no pattern resumed maior.



		----> (feito) CODIFICAR os tipos de expressao, para as expressoes chamada de metodo de metodos "Wrapper"s.
												----> (A FAZER) codificar no metodo de ValidaParametros, o tipo "coringa"
												"object", que aceita qualquer coisa, como na linguagem base c sharp.


_________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.11:

		----> testes com classes da linguagem, para a compilação via classe "ProcessadorID.Compilar()".
												----> (fixado) há demora nos testes, porque a lista de handlers está sendo
												instanciada a cada inicio de um cenario de testes.
															
		----> (feito) inicio testes com "ProcessadorID" para compilar instruçoes de codigo da linguagem orquidea.
								----> testes para instrução atribuição "simples" passou.
								----> (fixado) falha na compilacao de uma classe... nao está compilando metodos e propriedades.
												----> falha nos headers, não está inicializando.
														----> regressao para testes de headers, todos testes feito sucedido.
					
												----> os headers nao estavam sendo inicializados, apos alguma mudança no codigo.
													  Agora toda instanciação do compilador "ProcessadorID" inicializa os headers com o codigo das classes a compilarem.

												----> compilação de uma classe inteira passou, com metodos, propriedades, construtores..
																	---->instanciaçoes de instruções de metodos sendo feita.
								----> testes de todos cenarios de teste foi feito, sucedido, com varias classes,
								instruções fora das classes (programação estruturada).
												----> a migração de mapeamento foi sucedida...



										
		----> (CODIFICANDO) codificar o gerenciador de wrappers objects, a ser incluido no construtor de expressao,
		se for um wrapper object na expressao, é chamado o gerenciador, que constroi a expressao de
		chamada de metodo, e seta como a sub-expressao no construtor "Expressao".
										----> parada para pensar: se o objeto for uma estrutura wrapper, em
										que linha de codigo terá que analisar a expressão wrapper?. na expressao objeto?
										ou no analizador wrapper?


										----> migracao da variavel boolean "isWrapperObject", dos Wrappers
										para Objeto, facilitando a codificação.

				----> o gerenciador funciona como segue: intercepta os tokens da expressao, e se for
				get/set element wrapper, substitui os tokens da expressao currente pelos tokens das chamadas de função.
										----> (feito) vai ser preciso um método para obter os tokens da anotação wrapper "getElement",
										antes do processamento da chamada de metodo.
														----> os wrappers retorna uma lista de tokens raw antes do processamento
														de anotação wrapper.
										---> (A FAZER) não seja necessário, mas retornar uma lista de tokens raw, para
										anotação wrapper "SetElement";
		

				
				
		----> (CODIFICANDO, pronto o get/set elements) o gerenciador funciona como segue: intercepta os tokens da expressao, e se for
				get/set element wrapper, substitui os tokens da expressao currente pelos tokens das chamadas metodo.7
				a rigor, os tokens em anotação wrapper, são substituidos pelos tokens das chamadas de metodo set/get Element.
								----> para modificaçoes posteriores, e para evitar de esquecer o processamento de tokens consumidos,
								os metodos set/get Wrapper contem uma lista de retorno de tokens processados.
											----> (A FAZER) tarefas adjacentes:
															----> (feito) retirar a lista de tokens em WrapperData.
															----> fazer o codigo de obter tokens processado, nos metodos get/set wrapperData.
															----> (VALIDAR) o codigo do Gerenciador De Wrappers.
						


		
		----> demais atividades:
						----> (codificado) fazer o codigo de obter tokens processado, nos metodos get/set wrapperData.
						----> (codificado) (VALIDAR) o codigo do Gerenciador De Wrappers.

						----> (codificado) OBSERVAÇÃO; a rigor, na prática, não é bom retornar uma expressao
							  chamada de metodo, mas sim os tokens desta chamada de metodo,
							  pois o "GerenciadorWrapper" trabalha interceptando tokens, não construindo expressoes.
									----> (codificado) sendo assim, modificar os get/set element dos wrapper data,
				  						  para retornar uma lista de tokens, melhor que uma expressao chamada de metodo.
								

		----> (codificado) codigo de "GerenciadorWrappers" está dificil de expandir, para adicionar mais
						Wrapper Data Estructures. Codificar com uma lista de "WrapperData", que são do tipo abstrato
						"WrapperData", e fazer o processamento segundo esta lista. 
									-----> modificar o codigo do "GerenciadorWrapper" para compor processamento
										   com uma lista de "Wrappers", ficando assim muito mais fácil,
										   bastando codificar a estrutura wrapper, a classe WrapperData, e inclusão
										   do WrapperData na citada lista. 
													----> é preciso um metodo abstrato de "WrapperData" que sinalize
														  que trata de uma determinado tipo  de "WrapperEstructure" (o nome do objeto WrapperData).




						----> com essa modificação mais fácil fica o processamento de muitos tipos wrappers,
						pois a modificação está concentrada numa adicao da lista de wrappers disponiveis, na
						"GerenciadorWrapper". O codigo ficou também mais claro, mais enxuto...


		----> (codificado) se necessário, os metodo get/set elements gerando chamadas de metodo, teriam
						que devolver uma lista de tokens com os tokens da chamada de metodo, pois
						o "GerenciadorWrapper" trabalha com lista de tokens interptados, e depois substitui
						os tokens inteceptados, e uma lista de tokens que fazem a chamada de função,
						e poder ser interpretado como uma Expressao.


___________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.11:


	

		----> (feito) retestar todos wrappers, ante a modificação no codigo.
				-----> testes atualizados para escrever na tela os tokens das chamadas de metodos, para fins
					   de verificação se os algoritmos estã fazendo o esperado...
								----> testes fixado, sucedido, com atenção nos tokens de retorno e tokens retirados....


		----> (feito, testado com cenarios de teste da classe "Expressao") Verificar e codificar, se necessário, a obtenção de tokens para cada tipo de expressao,
			  na classe "ExpressaoSearch", pois pode falhar o codigo de obter tokens de uma chamada de expressao,
			  no "WrapperData" classe. 
						----> no metodo "FactoryExpression", é possível obter tokens,
							  vindo da "SearchByRegexExpression".


		----> (feito, testes com cenarios de testes da classe "Expressao") codificar no metodo de ValidaParametros, o tipo "coringa"."object", que aceita qualquer coisa, como na linguagem base c sharp.
		


		----> (codificando) 4 tipos de WrapperData Estructures é pouco: codificar o wrapper data "List".
						----> novo WrapperData de valor agregado: ListElement: Uma lista que pode conter Listas, e elemento de listas.
						      (semelhante a listas lisp).
											-----> começo de codificação do wrapper estructure "MultList".



		----> (a fazer) uma library para leitura/gravação de arquivos: text, bytes, feita em C#, em biblioteca .dll
						---> lembrar que o retorno dos bytes/textos lidos deve ser feito com um "object", 
						representando um "ArrayList", para poder converter em um "Vector" contendo os dados lidos.

_________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 06.12:

		----> refatoração dos metodos "Metodo.ExecuteAMethod", para otimizar ao maximo metodos
			  de classe importadas, que não precisam importar escopos, copiar propriedades para escopo, etc...
			  sendo mais rápido o procedimento.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________								
Daily Scrum 10.02:

-----> (feito) WrapperData [JaggedArray], [Matriz], [DictionaryText], agora com definição de instanciação tipada, mais fácil de processamento.

	-----> (feito)  WrapperData Vector agora com 3 tipos de definição: por "[var] id", por "[Vector] id", e "type[] id[exprss]".
				----> (feito) testes para novas formas de instanciacao, [WrapperDataVector].
				----> (feito) testes para novas formas de instanciacao, [WrapperDataMatriz].
				----> (feito) testes para novas formas de instanciacao, [WrapperDataJaggedArray].
				----> (feito) testes para novas formas de instanciacao, [WrapperDaaDictionaryText].
							----> todos [WrapperData] codificados, utilizando [Regex] para reconhecimento de forma de instanciação, e get e set element.


	----> Resumo do andamento do  Projeto:
			-----> mais tipos de [WrapperData] possiveis, se escalar industrialmente o conceito.
			-----> (feito) implementando novos tipos de definição de instanciação de WrapperData.
			-----> (feito) testes para os [WrapperData] codificado, verificando se gera um texto de expressao por chamadas de metodo.
			-----> (codificação) da [GerenciadorDeWrapperData],em [Expressao], que foi o passo parado, anteriormente, por falta de tempo hábil.
			-----> verificação de eval expression, para chamadas de metodo.
			-----> testes para bibliotecas de [string], de [double] (Bibllioteca Matematica), e de [file] (Arquivos), e escrita/leitura de caracteres [Prompt].

________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.06:
		-----> (constatação) uma expressão de instanciação de um objeto wrapper data é uma expressão inteira!
		-----> (verificado) verificar se a obtenção de objetos wrapper, estão retirando os token processado na expressão,
		e a inserção do código wrapper na expressão.
		-----> (codificado) codificado para wrapper object, para extrair os tokens de anotação, do texto da expressão original.
		-----> (feito) eliminado os metodos de entrada de wrapper object, com uma lista de tokens.


		----> (codificado, em testes) codificar no metodo [WrapperData.ExtraiTokens], a inserção dos tokens consumidos, na expressão de retorno,
		facilitando o processamento do [WrapperManager].

		-----> (feito) em fase de retestar os WrapperData, a fim de verificar se a expressao retornada está sem os tokens consumidos.
					----> [WrapperDataVector] testado.
					----> [WrapperDataMatriz] testado.
					----> [WrapperDataDictionaryText] testado.
					----> [WrapperDataJaggedArray] testado.


		----> (codificado, a testar) o codigo do [WrapperManager].



Resumo:
		-----> testes para [WrapperData.ExtraiTokens], com: Matriz,JaggedArray,DictionaryText. 		

		-----> em fase de testar o [WrapperManager], que está com código completo.
					----> com o [WrapperManager], é possível para prosseguir com o projeto.
		-----> codificação de [WrapperDataMultList].


________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.06:

[WrappersData]:
		-----> codificar os outros tipos de instanciação WrapperData.
					----> WrapperDataVector feito.
					----> WrapperDataMatriz feito.
					----> WrapperDataJaggedArray feito.
					----> WrapperDictionaryText feito.



[WrapperManager]:
		-----> (feito) integrar com a classe [Expressao].
		-----> (pensado) pensar como retornar a expressao, quando instanciado um wrapper data objeto: retorna os tokens, ou apenas
			   registra o objeto no escopo?
					----> metodo de registro de objeto wrapper feito, retorna true apos uma instanciação de objeto wrapper.
					
[Expressao]:
		-----> Testes de integração com o gerenciador de wrappers, no reconhecimento de expressao [WrapperData]:
					----> com expressao sem [wrappers data], validou sem alterações.
				    ----> problema na instanciação das expressões regex do WrapperData: numa 
					  	  segunda chamada ao [GerenciadorWrapper], as expressões regex não estão sendo instanciadas!


_________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.06:

Atividades:


[WRAPPER DATA] (todos):	
		----> (feito) eliminar a expressão regex de instanciacao: [var], está causando confusão de reconhecimento de tipos de
		WrapperData, e também não deixa claro que tipo de wrapper data é.
				-----> (feito) modificações nos cenarios de teste, com instanciacao com [var].


[Expressao]: 

		Testes:
				----> (feito) testes de instanciacao de objetos wrappers, com todos tipos de expressao regex, feito.
				----> falha acontecido acima, devido a não instanciação das expressoes regex, num dos wrappers.
	
				----> (fazendo) codificar testes para expressoes [GetElement], [SetElement], com expressoes de objetos em anotação wrapper data.
						
							----> WrapperDataVector, instanciacao, setElement , getElement, feito (teste simples).
							----> WrapperDataMatriz, instanciacao, setElement, getElement, feito (teste simples);
										----> (fixado) WrapperDataMatriz, getElement entrou em loop infinito. setElement não resultou na chamada de metodo SetElement.
							----> WrapperDictionaryText, instanciacao, setElement, getElement, feito (teste simples, parametro simples).
							----> WrapperJaggedArray, instanciacao, setElemento feito (teste simples).
										----> (fixado) getElement resultou em codigo duplicado.
			
			
				----> (feito) faltou o processamento de operador ";", principalmente no metodo setElement.
							----> setElement aceita expressao com/sem operador ";".

[GerenciadorWrapper]:

		----> (feito) teria que retirar os tokens consumidos em [GetElement], [SetElement].
					-----> o codigo de extração dos tokens consumidos é complexo.
		-----> (fixado) expressao [SetElement], feito. expressao [GetElement], falha, para [Vector].
					---->(fixado)  erro de logica de programação. e não está "consumindo" os tokens dos parametros, em GetElement.
		-----> (feito) testes de instanciacao, getElement, setElement, para WrapperDataVector, feito!



FIXAR:

		-----> (fixado) fazer o processamento correto, das chamadas de metodos getElemebt, setElement, porque é expressçao.Elementos[0] é que deve ser processado, e nao expressão gerado!
					-----> (fixado) testes, falha no reconhecimento da expressão chamada de elemento, para GetElement, SetElement.
								-----> o problema está no codigo anterior aos WrapperData objetos.
												----> no metodo de encontrar metodos compativeis: no Vectorr[i:object], deveria Vector[i:int].
					----> (fixado) testes com geracao da expressao chamada de metodo, GetElement,SetElement operacional! validou as chamadas de metodo!!!! ultimo estagio desta tecnica.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.06:

[Testes WrapperDataObjects]:
		-----> testes para outros wrapper data, nos cenarios mais simples. Porque ficou faltando a extracao da expressaoWrapper.Elementos[0], e nao expressaoWrapper.
		-----> continuar testes com cenarios mais complexos, como expressoes parametros para wrapperData objeto.
						-----> OS TESTES PODERIAM SER FEITOS EM [GerenciadorWrapper], ou em cada [WRAPERDATA], parece mais senso.
		-----> testes complexos:
						-----> (fixado) falha no processamento de um [ExpressaoOperador]. (depois de tantas modificações no codigo, causou quebra em outras partes do codigo).
						-----> (fixado) falha em [Expressao.ExtraiExpressoes].
										-----> a expressão de parâmetro está sendo processado, mas perdeu-se as expressoes
										de chamadas de função, pois não reconheceu o objeto wrapper...
										-----> para expressões parâmetro complexas, não há processamento,
										continua a falha no metodo Expressao.ExtraiExpressoes().
														----> houve confusão esta manhã: na tentativa de fixar o codigo, quebrou o codigo [Expressao.ExtraiExpressoes],
														alem é claro, da falha no processamento de [ExpressaoOperador], que para operadores binarios, não tinha setado o operador e os 2 operandos na ExpressaoOperador.
						
						-----> (feito) está retornando uma instanciação complexa, com variaveis dentro do parametro de tamanho do vetor!
						-----> (fixado) falha no metodo EvalExpression.Eval(), não está retornando o número esperado...
										----> ante a confusão, foi perdido o processamento de uma expressao operador,
										que agora carrega os operandos dentro da propria expressao operador,
										e nao como anteriormente os operandos eram guardados como expressoes dentro da expressao container....
										-----> operandos e operadores setado corretamente...
														----> (fixado) um erro terrivel, terrivel, terrivel! um metodo que retornaria o tipo do operador,
														não está retornado o tipo de operador [Binario], [Unario]!!!.
						-----> (feito) por experiencias anteriores, é melhor guardar os operandos como elementos na expressao de retorno,
						afim de guardar mais de um operador na [ExpressaoOperador].
										----> acontece que andei tendo umas aulas de lógica de programação, que não foi bom anteriormente.

						-----> testes complexos, classe [WrapperDataVector], feito.

	----> (fixado) fixar [ExpressaoOperador], não está retornando o ultimo operador, de uma expressao com muitos operadores.
						-----> erro gravíssimo, em método de procura de operadores: não estava verificando o nome do operador, parametro desse metodo.
						-----> erro de logica de programação, codigo feito hoje: a ordem de adição de operandos e operadores estava errado.

DEMAIS TESTES EM EXPRESSAO:
				----> há testes com importação de + 170 classes do proprio programa [ParserOrquidea], o 
				que demora devido a importação de +170 CLASSES da linguagem base, C sharp.
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.06:
[WrapperDataObbjects] [Testes]:
				-----> cenarios de testes complexos para:
							------> wraper data matriz;
											----> os metodos GetElement,SetElement para WrapperMatriz não estavam avaliando
											os indices e valor de um elemento da matriz!

							------> wrapper data jaggedArray.
							------> wraper data dictionary text.


				----> VERIFICAR URGENTEMENTE os metodos getElement,setElement, de todos WrapperData,
				observando se há construção de expressoes parametros, e expressao valor de elementos.
							------> parada para pensar o proximo codigo a fixar.



[WrapperDataMatriz]: erro no processamento de expressoes a+b, em indice do elemento da matriz.
				----> não há previsão para operadores [,]!
				----> falha em [TextExpression]: os tokens não estão sendo calculados corretamente, nos indices
					  de tokens delimitadores... uma parte não fixada anteriormente, justamente porque não houve expressoes
					  com tokens delimitadores!!
								----> nao havia previsoes de variaveis [id] com nome composto com numeros, e
								os indices de tokens estavam sendo calculados no texto de entrada, nao nos tokens
								obtidos no texto de entrada.
								----> erro na lista de tokens retorno em WrapperDataMatriz.SetElement: estava
								adicionando os indices, sem virgula delimitadora...



				----> a logica de programacao nao estava clara: os indices, e o valor de WrapperMatriz não podem
				ser avaliados, retornando um valor fixo, antes de executar o programa! Os tokens das expressoes
				de indices, valor, devem ser armazenados, e somente executados quando o programa for executado!!


				-----> sabotagem! O SERIAL KILLER ATACOU MAIS UMA VEZ!!!! Depois, dizendo-se abusado, volta o onus da culpa,
				PORQUE ELE ASSASSINOU SIM, E NÃO FOI UMA VEZ, MAS TRES E CONTANDO (disse que queria ganhar de presente de natal,
				um prato de comida: arroz, feijão, carne: marcou com alimento as familias das vitmas)! JUSTIFICATIVA? FALAR QUE MATOU
				PORQUE FOI FRUSTRADO!!!

	Todos [WrapperDataObject]:
				-----> retirar a avaliaçao de indices, valor, dos metodos WrapperData.SetElement, WrappeData.GetElement,
				substituindo pelos tokens das expressoes de indices, valor...

				[WrapperDataVector]: metodos GetElement, SetElement, fixados, quanto a não avaliação de expressoes indices, valor. (mas testar).
	
	
______________________________________________________________________________________________________________________________________
Daily Scrum 10.07:


[WrapperData]:
			-----> (falha) foi encontrado uma falha na instanciação: está sendo feito em tempo de compilação, e os dados
			de configuração tem ser constantes, o que não é o desejado...
								-----> criar um metodo abstrato [TipoDoWrapperData.Create], como uma chamada de metodo,
								como [SetElement], [GetElement], que faz o processamento de instanciação com expressões avaliado
								em tempo de execução.

			-----> (codificado) codificado metodo de construção de chamada de metodo para instanciar objetos wrapper.
			-----> (codificado) codificar o metodo nos objetos wrapper que instancia, a partir da chamada de metodo estática.


[Metodo]:		
	-----> (codificado) é preciso incluir como parâmetro, o objeto Escopo, em Metodo.ExecuteAMethod,
	porque é preciso para registrar o objeto instanciado.
			-----> previsão para inclusão como um dos objetos sendo do tipo [Escopo].
			a verificação é feito pela analise dos [Funcao.ParametrosDaFuncao], mas como incluir
			uma expressao objeto como um do tipo [Escopo]?

	-----> (A FAZER) codificar a otimização planejado quando o metodo é da classe base nativa, não
	precisando passar os dados do objeto caller.

	[TESTES]: quando no cenarios de testes para execução de chamadas  de metodo.



[WrapperDataVector]:
			-----> [WrapperDataVector]: instanciação com valores em lista: m=[1,2,3,5,7]. Precisa implementar na instanciação.
			foi cortado quando a instanciação com var foi eliminado...
								-----> verificar se o operador de igualdade estiver presente na instanciação,
								extrair o elementos-expressao, e inserir na chamada de metodo.


[WrapperManager]:
			----> (A FAZER) incluir a nova expressao chamada de metodo [Create], no processamento de objetos wrapper data.

[NOVAS INSTRUÇÕES ORQUIDEA]:
			-----> (A PLANEJAR) um insight: instruções em forma de uma chamada de função! Entrada o objeto que chamou a instrução-função, e saída
			o objeto modificado pela função. Evita escrever toda vez que criar uma instrução, um novo método na VM...
________________________________________________________________________________________________________________________________________
Daily Scrum 11.07:


[WRAPPER DATA]:
			----> testes da criação de chamada de metodo [TypeWrapper.Create].
						[WrapperDataVector]: testes feitos, nas duas vias de instanciacao.
											 testes volvendo atribução em lista, foram retirados, pois houve corte do codigo eliminando esta funcionalidade.
						[WrapperDataMatriz]: (fixado) um do templates de instanciacao nao havia sido passado para o metodo Create.
											 testes feitos.
						[WrapperDataDictionaryText]:
										      testes feitos.
						[WrapperDataJaggedArray]:
											  testes feitos.



[WrapperDataManager]:
			----> (codificado) fazer o processmaneo de instanciacao atraves de chamada de metodo [Create].



A FAZER:
[WrapperDataVector]: instanciacao com atribuicao de uma lista de elementos iniciais.
		-----> funcao de retirar elementos codificada, mas retorna uma lista de expressoes: como inserir como
		elementos atribuidos na construcao do vector? Gerando x chamadas de metodo SetElement?.
						-----> codificado metodo de construcao de chamadas de metodo SetElement, 1 para cada elemento atribuido.
										-----> a integrar no metodo [WrapperDataVector.Create], se houve um operador de igual.

		-----> (TESTAR) testar: houve falha na construcao de chamada de metodo [WrapperDataVector.SetElement], estava igual a [WrapperDataMatriz.SetElement],
		com 1 indice de endereço a mais.


_____________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.07:
		
		-----> testes para geração de chamadas de metodo [Create], de [WrapperData].
		
[WrapperDataVector]:
			-----> (fixado) falha no processamento de metodos estáticos.
			-----> (nao falhou) falha grave de processamento de expressoes dentro do codigo... mas não comporta operacoes aritimeticas na definicao
				   de indices.
			-----> a chamada de metodo está um nivel a mais que nas chamadas SetElement,GetElement: não se extraiu os tokens da chamada Create.
								-----> (fixado) codigo para retirar os tokens consumidos na chamada de metodo create, falhou.
								-----> (fixado) o nivel a mais, retornando uma chamada de metodo create igual as chamadas de metodo SetElement, GetElement.
									   (neste interim, fixou-se o processamento de chamdas de metodo estatica).

[WrapperDataMatriz]:
			-----> falha na criação da expressao chamada de metodo [Create].
								-----> falha na construcao da chamada de metodo Create, dentro de [ExpressaoSearch]. Nao é sabotagem,
								é que na busca de metodos compativeis, não está processando parametros como numeros, textos, que são constantes.
[UtilTokens.GetMethodCompatible]:
			----> não é sabotagem: mas os parametros de Matriz.Create nao estão sendo processados.
								----> falha desconhecida está impedindo de retirar todos parametros da chamada de metodo create, Matriz.Create().
								----> o wrapperDataMatriz está com um sinal de =, para definir os parâmetros: não deveria, fixar aqui...

			----> a obtenção de parâmetros em [ExpressaoSearch] quebrou!!! Não está extraindo os tokens de Expressoes, como ExpressaoObjeto, ExpressaoChamadaDeMetodo, ExpressaoNumero.
_________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.07:

[WrapperData]:
			----> ante a falha de ExpressaoChamadaDeMetodo, alguns fatos foi decidido:
						----> retirado dos metodos [WrapperDataObject.Create()], o parametro [Escopo], estava causando erros quanto ao processo
						de instanciacao de objetos wrappers.
											----> registro em tempo de compilação, de objetos wraperData, para processamento de expressoes.

						----> retirado os metodos [WrapperData.Instantiate], que criava objeto wrapper completo, em tempo de compilação,
						o que faltava era os parametros instanciados em tempo de compilacao, inviabilizando a instanciacao com variaveis e expressoes.

[Expressao]:
			----> conforme o observado, as expressoes chamada de metodo não estão sendo construidas, e um
			dos metodos GetMethodsCompatible() está quebrado...
			----> vai ser preciso um novo tipo de expressao: expressao de tipo, ante a inclusao de metodos wrapper que contem um tipo de dado como expressao.

[ExpressaoSearch]:
			----> (fixado) esta retornando expressao chamada de metodo, e nao expressao objeto!
					----> foi codificado e testado, mas está gerando erros nao esperado, que nao tem pe nem cabeca sendo testado centenas de vezes o
					mesmo algoritmo.
			----> (fixado) falha no metodo [ExpressaoSearch.FactoryExpressoes].			
			----> (fixado) falha na [ExpressaoNumero].

			----> (fixado) (falha em [ExpressaoSearch.FactoryExpressoes()]);
						----> em Expressao.ExtraiExpresoes(), nao está reconhecendo tokens nomes de classes!

[ExpressaoSearch.ExpressaoObjeto]:
			----> falha conceitual anteriormente nao se preveu uma lista de expressoes objetos, estava processando
			o primeiro token objeto. quando há um grupo de parametros, só se processava o 1o. parametro..
			----> fixar em [ExpressaoObjeto], processamento de listas de objetos.
	
[ExpressaoSearc.BuildExpressions]:			
			----> estava retornando diretamente, sem mais processamento, a expressao vindo de [FactoryExpressao].
			----> A FAZER: processo de mais expressoes...Tem que retirar os tokens, em [ExpressaoObjeto].
							----> validar a retirada de tokens em [ExpressaoSearch.FactoryExpressoes].

					
__________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.07:

	----> (verificado, os ids e exprss de ExpressaoSearch não possue tokens de virgula, e demais tokens estruturais) VERIFICAR SE HÁ PASSAGEM PARA TODOS TOKENS, NO PROCESSAMENTO DE ExpressaoSearch: está havendo falta de tokens virgulas,
		  no separamento de tokens de parâmetros, em ExpressaoSearc.ExpressaoChamadaDeMetodo;
	
			----> (a conclusao da verificacao) Conclusao sobre processamento regex:
							----> moral da estória: expressoes regex são boa para PRIMEIRA TRIAGEM, mas para validação de tipos de expressões, da extrações de expressão,
							é melhor o uso de analise de tokens, como eles vêem do código, não "pasteurizados" vindo da expressão regex!
										----> para evitar surpresas, tem que "contabilizar os tokens processado na expressão", retornando os tokens utilizados,
										e dando a possibilidade de processar os token restante...
										----> a ideia de grups de parâmetros, resultando na simplificação de ids, chamadas de funções, que diferencia:
													a(b,c)+d---> a+d, permite a extração de expressões que utilizam operadores, é (foi) uma boa idéia...
												
			----> (resumo da utilizacao de expressoes regex) regex expressions estão sendo utilizadas:
						----> para validar tokens que formam um instrução (comando da linguagem).
						----> no processamento de expressoes, com ressalvas que deve se valer dos tokens, apos a primeira triagem.
										----> em expressoes, é um processamento mais aprimorado na 1a. triagem, capturando expressoes
										como: a(1,5)+b--->exprss+id, a diferenca entre uma variavel e uma funcao é o uso de parenteses
										contendo mais dados. se voce tira o que está entre parenteses, e os parenteses,
										o processamento é "facil": resulta numa expressaoOperador: a(1,5)+b--->exprss+id.



[ExpressaoSearch.ExpressaoChamadaDeMetodo]:
				------> volta com processamento de lista de tokens, e nao de dados de expressoes regex. Expressoes regex são boas na 
				triagem de tipos de expressoes, de tipos de instrucoes, mas na validacao e construcao da expressao final, é falho.
				------> fixado a obtencao de expressoes parametros, com a utilizacao de processamento de tokens.
				------> como era experado, o metodo de obter funcao compativel falhou: foi modificado recentemente, e gerando resultados
				inconsistentes, e adiado até a correcao de processamento com tokens, e nao por expressao regex.

		-----> tem que diferenciar um nome de objeto, de uma string: o metodo create deveria ser 1o. parametro o tipo [Objeto], e não string (nome do objeto).
				-----> nao tem jeito: terá que substituir em Create, de string para tipo de objeto.
								-----> modificado os metodos create de [WrapperData], para compor como primeiro parametro o Objeto Wrapper.

[ExpressaoSearch.ExpressaoObjeto]:
				------> volta com processamaneto de lista de tokens, [ExpressaoSearch] não está retornando, e complicando, o 
				processamento de uma expressao objeto.
								----> extensao: mais um case de uso em ExpressaoObjeto: um token de objeto que é o nome de um tipo de classe.



[WrapperData.Create]:
				------> (fixado, faltou somente em [Vector], que tem tipos de elemento do vetor)
				faltou um "pequeno detalhe": no processamento de wrapper data, há um parametro que é o tipo de elemento	do wrapper data.

				-----> confusao: o tipo de elemento nao pode ser identificado!.
								----> parada, devido a impossibilidade de passar a informacao ao tipo de elemento.		
								----> uma solução: vetor guarda qualquer tipo de objeto! O metodo Create nao contem mais o tipo de elemento do vetor.

parado, ante a sobrecarregamento de problemas no codigo: estava funcionando, mas com a generalização com regex expressions,
para tb processamento de validação de tipos de expressao. bm para triagem de expressoes complexas, mas confusão quanto
ao retorno dos tokens da expressao, e tb modificações que deixou "inoperante" o processamento com ids de [ExpressaoSearch].

[Vector]:
				----> (codificado)  incluir em tempo de instanciacao dentro de wrapper data vector, o tipo de elemento, mas NÃO ESPECIFICAR EM Vector.Create.
				o controle fica em tempo de compilação, com [WrapperDataVector].
		
_______________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.07:

[Vector]:
	----> (feito) concentrar a validação e lançamento de exceção de tipo de elementos, em [Vector], em um unico metodo.
	----> (feito) caso particular de tipo de elemento: tipo [Objeto], de qualquer classe instanciada orquidea. neste caso, fazer o casting para [Objeto], e obter
			o tipo do elemento com obj.GetTipo().
	
	
[WrapperData]:
	----> (feito) wrapper data object instanciado,  diretamente do wrapper data object, não criação de Objeto,  e inserção no escopo.
	----> (feito) favor verificar se todos construtores de Wrapper Data estão registrando como tipo o nome do objeto wrapper data.
					-----> um dos construtores de [Vector] estavam sem definir o tipo do objeto wrapper!..


[Expressao]:
	-----> Expressao.ExtraiExpressoes() remove os tokens processados das expressoes, para possibilitar mais processamento,
	além do tokens consumidos.
	-----> PASSOU, para UM TESTE, é insuficiente, e pega o caso de uso meio simples.
	----> (fixado) Extração de Expressoes está "demorando demais", e o gargalo está em [Expressao].(estava retornando 2 processamentos, para uma mesma expressao).
	----> (esta processando sim, corretamente) fixar [ExpressaoAtribuicao], não está processando corretamente a expressão.


[ExpressaoSearch]:
	-----> (fixado) varios metodos estavam sem definir o tipo da expressao, gerando inconcistencia ao tentar encontrar metodos compativeis com as expressoes parametros, que alguns
	estava sem tipo de expressao definido.
	----> a "bagunça" em [ExpressaoSearch] está até onde se pode ver, está arrumado...
			


[ExpressaoSearch.ExpressaoChamadaDeMetodo]:
			-----> (feito, graças) refatorar esse metodo.
							----> casos de uso para expressao chamada de metodo:
										----> COM OBJETO Caller, seguido do nome do metodo, mais parenteses abre.
										----> COM OBJETO Caller, mas o nome da classe do token do objeto, como objeto caller.
										----> SEM OBJETO Caller, com o nome de uma função como token do objeto caller.

			----> fixar o processamento de [SetElement].
					----> (fixado, o tipo de curinga é "Object") metodo de encontrar metodo compativel nao esta processando direito parametros [object]!
					----> (fixado) quase lá está faltando setar o nome do objeto em chamadas de metodo [SetElement].

			----> descoberta que tipo object para parametros de classes reflexao é "Object".

_________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.07:

prioridade:
			(feito)[ExpressaoSearch.ExpressaoChamadaDeMetodo]:
						----> (nao vai falhar, nao há teste de lista vazia dos tokens parametros) se não houver parametros na chamada, vai falhar: não há previsão quando a lista de parametros for vazia: retorna null!


			(feito)[UtilTokkens.GetMethodCompatible]:
						----> (nao vai falhar, porque há metodo de casting para classes base) se o metodo na busca, for de uma classe importada da liguagem de base, vai falhar com tipo [int], pois na linguagem base, é Int32,Int64, não int!



			
(feito)[ExpressaoSearch.ExpressaoOperador]:(fixado) casos de operadores unarios "+","-". 
			----> faz tempos que há a preocupação: há operadores que são binario E unario ao mesmo tempo! Como ("+", "-"). tem que diferenciar quando é um quando é outro.
			está impedindo de coisas "simples" como "-1"...
						----> codificado, mas não está reconhecendo a expressao de atribuição, no codigo do teste.
			----> por nao ter previsao na classe que implementa operadores,na havia como operador unario: -1,+1, é preciso incluir explicitamente em RegexExpressions, o caso de "- exprss", "+ exprss", como expressao atribuicao.
						----> e tb em ExpressoesOperador, incluir um caso exceção de objeto com operador "+" ou "-";
		
			----> exclusivo: IMPLEMENTADO metodos importados para operadores unarios "-","+".

			----> modificacao do codigo, para encontrar operadores binarios e unarios ao mesmo tempo.
						----> retirado o codigo anterior, que estava explicitamente e exclusivamente para operadores unarios "+","-",
						mas que nao cobria os casos de objeto com numero negativo, positivo.



(feito)[ExpressaoSearch.ExpressaoOperador]:
			----> (feito) fazer teste com operador "-","+", funcionando como binario.
						---> descoberto neste teste falha no processamento de operador binario, devido a codigo recortado, 
						mas em caso operador unario, devendo ser operador binario.


(fixado)[ExpressaoSearch]:
	----> (fixado com o avanço do projeto, corrigindo varias falhas em [ExpressaoSearch],
	que utilizava expressoes regex, que não é adequado, como se concluiu dias atrás) falha em expressoes com indices como m[x+1,y+5];

____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.07:

[TextExpressions]			
	----> retirada de operadores de classes importadas, e em Expressao.Headers, para guardar em [TextExpressions].

[SuiteclasseTestes]:
	----> PESQUISAR URGENTEMENTE COMO FRAMEWORKS DE TESTES UNITARIOS SÃO FEITOS... um teste apenas é insuficiente,por mais complexos que seja.
				----> encontrar um codigo para a classe [SuiteClasseTestes] com meio resumido de setar parametros para testes...

______________________________________________________________________________________________________________________________________________________________________________________________
[SuiteClasseTestes][SuiteIITestes]:

Planejamento:
		----> novas funcionalidades:
					----> colocar um try/catch envolvendo o metodo invocado na malha. se falhar, escrever no log "o metodo falhou, e lançou uma exceção",
					isto possibiita faz todos os testes na malha de testes, sem se preocupar se a assercao possa quebrar.
					----> uma funcao importada, que invoca a funcao de resultado, com: "nomeDaClasse","nomeDoMetodo", do teste,
					devendo fazer em tanto metodos normal, quanto construtores. utilizar a API reflexão.
					----> um objeto estatico que guarda o resultado da funcao de valor resultado.
					----> testes: assercao.isTrue(nomeClass, nomeFuncao, comparacaoResultadoEsperado, lista variavel de parametros para o metodo em teste).


[SuiteIITestes]:
		-----> classe de testes com: construtor test, method test, funcao de validacao, prevenção contra exceções no teste provocando a parada de testes,
		e obter caso precise o objeto de retorno do teste.


		-----> (fixado) confusao, testes com construtores, tem que ser outro metodo.
		-----> (feito)(verificar a possiblidade) é melhor passar a validação como uma condicao: true/false, diretamente para o metodo teste. elimina
			   um metodo a mais envolvido no testes, e pode ser que processe corretamente lançamento de excessoes, a ser feito dentro do metodo teste da classe de teste.
		-----> (A FAZER) é preciso testes com um método testar, não construtor (já feito).
________________________________________________________________________________________________________________________________________________________________________________________________
Proxima Daily Scrum:

[ExpressaoSearch.FactoryExpressao]:
				-----> em [ExpressaoSearch.FactoryExpressao], tem que remover de [serchTokens], os tokens da expressao formada, pois há previsão de que
				se restar mais tokens na saida do metodo, havera mais Expressoes (guardado o lugar com um comentario, sem implementacao), em [ExpressaoSearch.BuildExpressions].
									-----> para acontecer, as expressoes extraidas devem conter os tokens da expressao, verificar se em [ExpressaoChamadaDeMetodo], ha
									a extracao dos tokens consumido...
[Testes]:
				-----> pelo fato de planejar testes unitarios, ve-se o plano maior, com verificaçao visual de casos extremos...
___________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.07:


[ExpressaoGrupos]:
	-----> novo insight levou a classe [ExpressaoGrupos].		
		-----> Expressao Complexa: testes para extração de expressao sem tokens entre parenteses, feito um teste.
		-----> metodo de extracao de EXPRESSAO OBJETOS, CHAMADAS DE METODOS ESTATICAS OU NAO ESTATICAS, PROPRIEDADES ANINHADAS ESTATICAS OU NAO ESTATICAS, codificado.
		-----> no mesmo metodo, extracao de EXPRESSAO NUMERO, EXPRESSAO LITERAL, codificado.
		-----> no mesmo metodo extracao de EXPRESSAO OPERADOR.
		----> codigo feito para extração de expressoes parametros, a partir de grupos de parametros.
		-----> codigo feito para  encontro de metodo compativel com as expressoes parametos.
		-----> (feito) nao esquecer de codificar as mensagens de erro, quando retorna null.


		-----> (feito) em grupos, extrair o primeiro parenteses abre, e o ultimo parentes fecha, afim de econtrar os parametros. Vai se preciso tirar as expressoes parametros da expressao container.			
		-----> (A FAZER) faltando a extração de EXPRESSAO ATRIBUICAO.
		-----> (A FAZER) faltando o processamento de propriedades aninhadas com mais de 1 propriedade aninhada.
						----> codificado processamento a mais, para propriedades aninhadas estaticas.
						----> parado ante exaustão.

		-----> (A FAZER, PLANEJAMENTO): processamento de chamadas de metodos aninhadas.
		-----> (A FAZER) processamento DE WRAPPER DATA OBJECTS.	



[ExpressaoGrupos.Testes]:
		-----> teste trivial feito.
		-----> esperando completar o codigo de [ExpressaoGrupos].


[Analise da classe ExpressaoGrupos]:
		-----> a ideia é muito boa, resume uma lista de tokens variantes, para uma lista de tokens que nao varia muito. 
		uma lista de tokens de expressoes pode conter expressoes dentro de expressoes, tornando dificil o processamento.
		com a retirada de lista de tokens entre parenteses reduz para uma lista de tokens "facil" para extração de expressoes.
		No primeiro teste confirmou que o codigo pode ser composto de tokens entre parenteses (grupos de parametros), de 
		tokens não variantes quanto a expressao. e foi um teste complexo, com um codigo extremamente dificil de extrair expressoes,
		com o codigo de [ExpressaoSearch], que utiliza expressoes regex, não adequado para Expressoes, para instrucoes da linguagem,
		e resumo em certas condições de compilação...
		-----> um porem é que o codigo está muito dificil dar manutenção, pois segue extritamente a lingaguem de programacao utilizada.
	

[UtilTokens.GetOperatorCompatilble]:
			-----> a testar:  previsão de um dos operandos for nulo.
_____________________________________________________________________________________________________________________________________
Daily Scrum 24.07:

[ExpressaoGrupos]:
	
	[ExpressaoGrupos].ExpressaoOperador:

	----> (feito) retirar os parametros-expressao extraidas da lista de expressoes, para formar uma expressao operador: problemas de
	prioridade não consistente com avaliação pos-ordem.
					----> funcao de atualizacao de indices de insercao de operadores, codificado.


	[ExpressaoGrupos].ExpressaoAtribuicao:
				-----> (feito) faltando a extração de EXPRESSAO ATRIBUICAO.
				----> (fixado com chamada recursiva, ja feita antes tb), na extracao da expressaoValor da expressao.

				
	[ExpressaoGrupos].ExpressaoOperador:			
				Testes:
							----> para um operador unario [-], nao está registrando a expressao operador.
												----> (fixado) fixar: metodo [GetNomesOperadoresBinariosEUnarios()].
															-----> confusao de extracao de tipos de operadores. operadores tem classificação: operador unario e um tipo,
															 binario outro tipo, mas nao ha classificacao unario e binario ao mesmo tempo, tem que filtrar os operadores
															 binarios e operadores unarios.
															 ----> fixado: FALHA DE LOGICA DE PROGRAMACAO! listas de operadores [binarioEUnarioAoMesmoTempo] 
															 sendo instanciadas a cada classe de operadores. deveria ser na lista de todos operadores binarios e unarios.

							----> (fixado) falha apenas para operadores [binario e unario ao mesmo tempo], nao encontrando operador compativel.

							----> feito para operadores binarios, binarios e unarios pre, unario pre.
							----> (FIXAR) falha para operadores unario pos.
										----> (A FAZER) é preciso mais casos de utilizacao de operadores unarios.
										(caso falha: 1oOperando: indice [0], operador: indice[1], 2oOperando: >=0: nao ha previsao para este caso: os 2 operandos com indice>=0);
							----> algo que foge a logica feita, é que operadores unarios é uma expressao com 2 tokens: o operador unario e o operando.
							mesmo com expressao entre parenteses, ao processar, reduz primeiro a expressao parenteses, caindo no caso de operador unario e um operando.
										----> (implementando) sem previsao para operadores unario pre. 


	[OperadoresNativos.OperadoresUnarios]:

			----> (codificado)verificaçao simples: se o 1o. operando é operador unario, ou o 2o, operando é operador unario.
						----> se for PRIMEIRO operando é 1 OPERADOR UNARIO: o operador unario é pre.
						----> se for SEGUNDO operando é 1 OPERADOR UNARIO, o operador unario é pos.
						----> se for os 2 operandos, erro de codigo retorna null.

	[ExpressaoGrupos.PropriedadesAninhadas]:
				-----> codificado segundo o visto no codigo anterior, que estava em falha.


	[ExpressaoGrupos].Testes:
		---> (fazendo com adaptação da classe de testes anteriores) concluido a codificacao, codificar com testes unitarios em massa, com a classe [SuiteTestII].
____________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.07:

Atividades:

[ExpressaoGrupos][OperadoresUnarios][Testes]:
			----> (feito).

[ExpressaoGrupos][PropriedadesAninhadas]:
			-----> (codificado) previsão para uma chamada de metodo no final da propriedade aninhada. duas entradas: propriedades aninhadas estaticas e propriedades aninhas nao estaticas.
			----> testes para propridades aninhadas.
			[Testes]: codificado o codigo geral para testes unitarios em massa.
						----> extração de propriedades aninhadas, sem atribuicao, feito.
						----> extracao de expressoes propriedades aninhadas com atribuicao, feito:
										-----> (feito) vai ser preciso resumir mais os tokens resumidos, para retirar tokens que vem depois de operador dot.

										-----> a experimentacao de nao extrair metodos para nao duplicar o codigo, permitindo
										uma melhor visibilidade do codigo, e sem entrar em metodos quando em testes, 
										nao é melhor: para fixar o codigo duplicado, tem que fixar em 2 ou + trechos de codigo..

						----> (feito) propriedades aninhadas, com uma chamda de metodo aninhada no final.
										-----> (feito) seria bom se o metodo aninhado tiver parametros, para testes de chamada de metodo.

			[Testes]: A IMPORTANCIA DE TESTES UNITARIOS EM MASSA!

[ExpressaoGrupos][ExpressaoOperador]:
			---->(nao precisa, os indices de operadores sao calculados em termos de posição de expresses na lista expressoes)
			(FIXAR)verificar caso de operadores com propriedades aninhadas, como "propriedadeA.propriedadeB+propridadeC.proppriedadeD", 
			pois foi preciso em expressao atribuicao, corrigir o indice do operador: seria bom se o [DataOperator] fosse feito com tokensResumidosSemOperadorDot!,
			aí simplifica mais: a.b+c.d ---> b+d, o que convém, pois o indice do operador combina com instanciacoes de expressoes parametros de operador!!!
			
											
[ExpressaoGrupos][object_caller]:
			----> (FEITO, VERIFICACAO VISUAL) verificar a instanciacao de Expressao.objCaller, para chamadas de metodo (estaticas ou nao estaticas), objetos, propriedadesAninhadas (estaticas ou nao estaticas),
			funcao sem objeto caller (um objeto caller ficticio).


[ExpressaoGrupos][ExpressaoAtribuicao]:			
			----> (ESTA SEM VERIFICACAO)verificar em [ExprressaoAtribuicao], se verifica o tipo de expressao combina entre o objeto que recebe a atribuicao, e a expressao valor da atribuicao.
			----> (feito, com testes unitarios em massa) validacao do tipo do objeto que recebe a atribuicao, com o tipo da expressao valor da atribuicao.
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.07:
(volta a [ExpressaoGrupos] para acrescentar [ExpressoesEntreParenteses], que pode modificar a pos-ordem da expressao formada).



(feito)[ExpressaoGrupos][ExpressaoEntreParenteses].:
				----> implementar a [ExpressaoEntreParenteses].
				-----> (feito) codificado a extracao de grupos, sem extrair expressoes entre parenteses.
				-----> codificado o caso de expressao entre parenteses.
				-----> (feito)[Testes]:
							-----> (fixado) uma das mais complexas expressoes planejada, dando validação:
							Expressao de Atribuicao+ ExpressaoEntreParenteses+ExpressaoOperadores.
							(os 3 testes de expressao entre parenteses foi validada visualmente e via codigo automatizado).
							-----> são expressoes que se encontram em app reais: com parenteses, chamadas de metodos, propriedades aninhadas,
							operadores binarios, unarios.
				-----> expressao entre parenteses instanciada, nao uma expressao container.
		

			
(feito)[GruposEntreParenteses]:					
				-----> (feito) retirar de [TextExpression], o metodo´isID(),isNumber(), isLiteral()  para verificação de determinacao de expressao parenteses, pois há outros tokens como [,],(,),
				que nao sao operadores, mas tb nao sao id (objeto, funcao, metodo, propriedade).
			
			
(feito)[ExpressaoGrupos]:				
				-----> (feito) incluir no metodo que determina se há operandos validos para operador unarioEBinario, o tipo de [ExpressaoEntreParenteses].
						
						

(feito)[ExpressaoGrupos][ExpressaoAtribuicao]:
			---> codigo mais compativel quanto a retirar tokens de operadores = e demais, token [=] nao estava corretamente associado, daí a volta extraindo mais tokens resumidos.
			---> retirado a funcao que retira mais tokens de uma lista de tokens resumidos.
						-----> observado em codigo de versoes anteriores, que o indice do token [=] não era em termos de contador de expressoes de retorno,
						mas o indice da malha de token, o que falha se há propriedades aninhadas, chamadas de metodos, que tem mais de 1 token constituinte.
_______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.07:

[ExpressaoGrupos][WrapperDataManager]:
			-----> (A FAZER) processamento DE WRAPPER DATA OBJECTS, chamando o [WrapperManager] antes do processamento dos tokens da expressao nao resumida.
							----> vai ser preciso modificar a classe [Expressao], para extrair Expressoes atraves de [ExpressaoGrupos],
							e também acrescentar o [ManagerWrapperDataObjects] primeiramente para criar expressoes chamadas de metodo de objetos wrapper.
							----> é complexo, a operação: retirar [ExpressaoSearch], e colocar no lugar [ExpressaoGrupos].
[ExpressaoGrupos]:
			----> faltando a extração de multiplas expressoes, independentes entre si, como uma lista de expressoes parametros.
			----> (codificado) foi preciso obter os tokens de cada tipo de expressao.
							----> extracao de expressoes independentes estao sendo feito, mas nao aparece na expressao de retorno.
[ExpressaoGrupos][lista de Expressoes independente]:
			----> é uma EXTENSAO DE FUNCIONALIDADE: permite extrair multiplos grupos de expressoes, independentes.
			----> codificado novo codigo para extrair expressoes independentes.
			----> utilizando os tokens sem processamento.
			----> extraido para outro metodo, um metodo para extrair multiplas expressoes independentes.
			[lista de Expressoes independente][Testes]: (feito);
							.

[ExpressaoGrupos][ExpressaoChamadaDeMetodo]:
							----> está processando o token virgula dos parametros da chamada de metodo, resultando em falha...
							----> a funcionalidade de expressoes independentes quebrou o codigo!.... entra em loop infinito.
							
							----> o testes, passou, mas a extração de tokens para cada expressao foi feito sem teste,
							fixou para chamada de metodo aninhada, mas para outras expressoes chamada de metodo precisa ser verificado.

________________________________________________________________________________________________________________________________________________
Daily Scrum 28.07:

Atividades:


[ExpressaoGrupos]:
			
			----> (feito) retirar a extracao de tokens resumidos de expressoes. Tokens resumidos nao eh o ideal, seria bom os tokens originais.

			----> (feito) (melhor fazer, para futuras ocorrencia) alternativa: em cada classe de expressao, é possivel extrair os tokens de expressoes.
							-----> enxugando para compor os tokens, reduzindo o numero de construtores com dados insuficientes para obter os tokens da expressao.
										-----> ExpressaoPropriedadesAninhadas.
										-----> ExpressaoObjeto.
										-----> ExpressaoAtribuicao.
										-----> ExpressaoInstanciacao.
										-----> ExpressaoOperador.
										-----> ExpressaoNILL.
										-----> ExpressaoChamadaDeMetodo.
										-----> ExpressaoNumero.
										-----> ExpressaoLiteral.
										-----> ExpressaoEntreParenteses.
										-----> ExpressaoElemento.

			-----> o codigo do compilador está quebrado, justamente pela codificacao dia anterior, para compor com [ExpressaoGrupos],
			no entanto, o metodo [Expressao.ExtraiExpressoes] utiliza ainda [ExpressaoSearch], que foi substituido por [ExpressaoGrupos].
			isso tornou o compilador inoperante...
							-----> houve modificacao no codigo para retornar tokens de todos tipos de Expressoes, e em razao disso quebrou o codigo com
							a instanciacao feita mais posteriormente no codigo em [ExpressaoGrupos.ExtraiExpressoes()].

			-----> testes de propriedades aninhadas, expressao atribuicao, expressao operador, expressao objeto feitos.

			-----> foi no momento de instanciar a propriedade aninhada: colocou-se no codigo o registro de propriedade aninhada, depois
			da malha de verificacao de mais propriedades e chamada de metodo aninhados, e em razao, perdeu-se (mas fixado) a logica de programacao.


[ExpressaoGrupos][ExtraiExpressoes]:
			----> (feito) VERIFICAR URGENTEMENTE a extração de tokens para chamadas de metodos, pois a extração de tokens foi feita posteriormentem
			com o novo metodo [ExtrairMultiplasExpressoesIndependentes()].


[Expressao]:
			----> (codificado) completar, compondo o metodo [Expressao.ExtraiExpressoes()], para chamada de [ExpressaoGrupos.ExtraiMultiplasExpressoesIndependentes()].
			----> [Expressao] estava sem retornar a expressao container, codificada justamente para adequar [Expressao] com [ExpressaoGrupos],
			mas nao estava retornando tal container! fixado com a adição de expressoes encontradas em [ExpressaoGrupos] como sub-expressoes da 
			expressao currente. ai sim se adequou a expressao container (a propria expressao currente), com as expressoes encontradas.
			-----> Planejamento de testes unitarios em massa, para expressoes, e wrapper data object.


_______________________________________________________________________________________________________________________________________________
Daily Scrum 31.07:


Atividades:

(feito)[ExpressaoGrupos][ExpressaoChamadaDeMetodo]:
			----> testes para chamadas de metodo, classe [ExpressaoGrupos].
			----> sem previsao de testes unitarios para [ExpressaoChamadaDeMetodo]! 1 teste codificado em testes de [ExpressaoPropriedadesAninhadas],
			há dificuldade justamente porque o compilador em [ProcessadosDeIDs], está possivelmente inoperante.
			----> codificado testes unitarios, na "esperança" que o compilador esteja funcionando.
						-----> compilador operante, e funcionando!

			----> mas, falha na construcao de objetos int no compilador.
			----> para os testes, foi feita a insercao dos objetos faltantes, e os testes passaram..
			
(feito)[Expressao][ExpressaoWrappers]:
			----> codificado metodos [ToString], para cada tipo de wrapper, para fins de visualizacao em testes.
			----> atualizado [WrapperDataVector], [WrapperDataMatriz], [WrapperDataJaggedArray],
			[WrapperDataDicitonaryText], quando extracao de parametros de indices, para compor com 
			a nova classe [Expressao], com [ExpressaoGrupos].


		[Testes][WrapperDataVector]:
			----> unificado num so metodo, todos testes unitarios...
			----> testes feitos.

		[Testes][WrapperDataMatriz]:
			----> unificado num so metodo, todos testes unitarios...
			----> falha em expressao de atribuicao.
		[Testes]:
				refazer os testes, ante a modificação na malha de tokens em [ExpressaoGrupos],e [Expressao].




[Expressao]: vai ser preciso revisar o processamento de token, na malha de token em [ExpressaoGrupo]: em que incluir se o objeto é um wrapper data object...
			----> codificado no processamento de tokens em [ExpressaoGrupos], uma entrada para processamento de wrappers data,
			metodos get/set element.
						
			[ExpressaoGrupos][Testes]: validado a instanciacao de objetos nao wrapper, mantendo o resultado de testes antes da inserção
			de processamento de get/set objetos wrapper.

		

[Expressao]:
			----> mais testes unitarios, e fazer os testes (que nao foram unitarios em massa) de WrapperData Object.
			----> testes anteriores, com codigo de expressao desatualizado.
							-----> (feito) atualizar os metodos [WrappersDataObject.Create], e os metodos [WrapperData.Create];
							-----> menos repeticoes:
											-----> unificados todos metodos de [Vector], para evitar construcao para apenas 1 teste unitario.
											-----> unificados metodos de [Matriz].
			-----> (codificado) no processamento de metodos set/get de objetos wrapper, é preciso obter os tokens consumidos, afim de remover na malha de tokens
			em [ExpressaoGrupos].

[Expressao]:
			----> (feito) removido testes repetidos, de [WrapperDataDictionaryText],[WrapperDataJaggedArray].



[PROJETO]:
			----> RESUMO e analise:
							----> classe [Expressao] foi modificada para compor com [ExpressaoGrupos], e adicionado um metodo
							de processamento de objetos wrapper, com chamada de [WrapperManager].
											----> (feito) codificar em [Expressao.ExtraiExpressoes], para extração
											com o metodo [ExpressaoGrupos.ExtraiMultiplasExpressoesIndependentes].
											----> (feito) nao esquecer de envelopar a [Expressao()], com um container, para compatiblidade do codigo.
							----> (em testes, testes unitarios codificados)classe [ExpressaoGrupos]: pendente a verificação de tokens em chamadas de metodo.


					----> uma conclusao sem ilusao é que o processamento de Expressoes, vale mais pelas expressoes chamada de metodo,
					o restante é que é importante para tipos como numeros, strings, que tem operadores binarios, unarios.
					Pode-se extender os operadores, com a instrucao [operador]...Porem, os nomes de operadores pode ser de livre escolha,
					não há restrição além de nomes de operadores aritmeticos, condicionais, logicos... o nome pode ser o que se quer...


					-----> com o teste de [Expressao], seguir com bibliotecas para a linguagem. Já há biblioteca: leitura/escrita em console,
					matematica (na classe double), strings, alem dos tipos base: int,string,char,double,float, e wrappers data object.
____________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.08:

	
[Expressao]:
			-----> (fixado) Expressao.ExtraiExpressoes está retornando um nivel Elementos a mais, pois está empacotando cada expressao num container.	

[Expressao][Testes]:
			----> refazer os testes de expressoes wrapper data object, ante a modificação na malha de tokens de [ExpressaoGrupos],[GerenciadorWRapper].
			----> [Testes][WrapperDataObject]: 
											-----> [WrapperDataVector]: testes GetElement/SetElement/Create chamadas de função, para [Vector], feito.
											-----> [WrapperDataMatriz]: erro na extracao dos indices, metodo [Expressao.ExtraiExpressoes] nao
											está retornando todas expressoes.
											-----> atualizado a nova situação de [Expressao], [Expressao.ExtraiExpressoes] para:
														-----> [WrapperDataJagggedArray].
														-----> [WrapperDataDictionaryText].
											


		

[GerenciadorWrapper]:
			----> (feito) testes para verificacao de lista de toknes consumidos em anotacao wrapper set/get element.


[ProcessadorID.Compiler]: verificar se objetos [int] estão sendo instanciados.
			----> com a migração de [ExpressaoSearch] para [ExpressaoGrupos], foi preciso modificar o metodo [Expressao.ExtraiExpressoes()],
			e estava com erros de logica de programação, retornando apenas 1 das expressoes, dentro de uma lista de tokens.


Hoje, A FAZER:
			-----> (feito) mantido a validação de todos testes unitários de [ExpressaoGrupos], o que permite passar para
				   os testes de [WrapperDictionary], e [WrapperJagged].



			[WrapperDataDictionaryText]:
						
			[WrapperDataJaggedArray]:
					-----> (FIXAR) falha na instanciacao de objeto jagged array. o indice pode ser vazio, dai a falha.	
[Projeto]:

			----> apos fixar com testes de anotações wrapper set/get element, em [ExpressaoGrupos],
			dar continuidade com: avaliação de expressoes em [EvalExpression.Eval()].
			-----> com o teste de [Expressao], seguir com bibliotecas para a linguagem. Já há biblioteca: leitura/escrita em console,
					matematica (na classe double), strings, alem dos tipos base: int,string,char,double,float, e wrappers data object.
_______________________________________________________________________________________________________________________________________________________________________________________________
[PRATICAS DE PROGRAMACAO]:

[Testes]:
			[Depuração do codigo]:
					-----> a grande verdade! utilizar o depurador só enfraquece a compreensão do código, e onde os erros se locailizam.
					a cada erro, procurar "ver" onde está o codigo que falhou, atraves de lançamentos de exceções, isolando os testes que falharam...

			(feito) [funções de assercao]:
					-----> uma facilidade: rodear com um bloco try/catch a função que verifica a validação dos resultados do teste,
					podendo ir diretamente à condição que se quer testar, sem medo de quebrar a execução dos testes subsequentes.
					FACILITA A IMPLEMENTAÇÃO DE ASSERCÕES, que é chato, cansativo, "indo direto ao ponto" do que se quer testar...
								----> falha no prosseguimento dos testes, lançou uma exceção e paralisou o codigo dos testes.
								(PESQUISAR) na Internet se há uma configuração para tratamento de exceções lançada, em
								modo de depuração.
											-----> verificando na Internet, as exceções não tratadas para a execução, o depurador para a execução do código,
											então se codificar um catch para tratar a exceção lançada, o depurador não parará a execução.
											
_________________________________________________________________________________________________________________________________________
[Projeto]:
			
			----> a ideia de [ExpressaoGrupos] é muito melhor que [ExpressaoSearch], permite extração de expressões complexas,


		
[EvalExpression]:
			----> propriedades aninhadas: em eval expressions, a medida que segue a malha de objeto aninhados,
			se o campo for null (nao instanciado), instanciar e ligar ao objeto caller, por referencia..
			pode-se discutir se o campo teria que já estár instanciado, lançando uma exception quando utilizar o campo com valor null.
________________________________________________________________________________________________________________________________________________________________________________________________											
Daily Scrum 02.08:

[Expressao]: unificado testes unitarios de [Expressao], para inserir eventualmente codigos mais detalhados casos nao simples.
[Depuração do Codigo]: funcionou a simplificação de funcoes de assercao, cerdada por blocos try/catch. mais facil e permite mais testes unitarios.

[WrapperDataObjects]:
			-----> testes para [WrapperDataJaggedArray], [WrapperDataDictionaryText], as chamadas de metodo set/get/create.
							-----> (fixado) está falhando [create], pois o indice no teste está vazio, e nao há previsão para indices vazios. É apenas um indice para compatibiliar com o metodo [JaggedArray.Create()].
							-----> (fixado) os metodos create,set, get,  do objeto wrapper jaggedArray, estavam em notacao diversa da construcao das chamadas de metodo deste wrapper.

			-----> o metodo [ConvertParaChamadaDeMetodo] nao está retornando os tokens corretos!
							----> (fixado) o problema é que o metodo está esperando um sinal de igual, para converter a expressao set,
							mas [DictionaryText] nao tem set com operador igual!!
							----> (fixado) problema: um token é do tipo object, mas nao ha previsao de Objetos do tipo object!.
							----> (FIXAR) a instanciacao de expressoes wrapper data Create.

			-----> verificar se o compilador [ProcessadorID] está compilando todas expressões, dentro de uma lista de expressões.
__________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.08:

[ExpressaoGrupos]: 

			----> (feito) VERIFICAR OS BLOCOS DE IF/ELSE EM ExpressaoGrupos.ExtraiExpresoes(), é certeza que no bloco de OBJETOS WRAPPER, o aninhamento está errado,
pois ao mexer neste trecho do codigo, outras partes do codigo falharam... (ChamadasDeMetodo nao estatica).
			----> (feito) VERIFICAR TB AS FUNÇÕES ASSERT, para encontrar falhas em retornar true quando o correto é false.


[ExpressaoGrupos]:
		
		----> (fixado) a chamada de metodos nao estaticas.
		----> (feito) reorganização de extracao de expressoes de chamadas de metodos, para remover codigo duplicado, e fixar em apenas um trecho de codigo só.

		

		
		


[EvalExpression]:
			----> propriedades aninhadas: em eval expressions, a medida que segue a malha de objeto aninhados,
			se o campo for null (nao instanciado), instanciar e ligar ao objeto caller, por referencia..
			pode-se discutir se o campo teria que já estár instanciado, lançando uma exception quando utilizar o campo com valor null.
____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.08:

[ExpressaoGrupos]:

	[ExpressaoPropriedadesAninhadas]:
		----> (feito) para operadores com propriedades aninhadas.
		----> (feito) (validar o codigo, com as alterações do tipo de expressao setada, conforme relatado a seguir) codificado para parar em propriedades aninhadas, quando encontra um token que nao é id, como um operador.
		----> (feito) metodo [GetProperties()], precisa setar o tipo da expressao: 1- para o ultimo objeto do aninhamento. 2- se tiver uma chamada de metodo, o tipo da expressao
		   	  é o retorno da ulltima chamada de metodo. Por isso, operadores que precisam do tipo da expressao, nao esta sendo feito corretamente.


	[ExpressaoChamadaDeMetodo]:
		----> (fixado) está registrando expressao chamada de metodo como expressao propriedades aninhadas, e com uma expressao chamada de metodo adicionada no elementos da expressao aninhada.



[Expressao]:	
	----> retestar todos testes em [Expressao], para WrapperData object.
			----> (FIXAR) a instanciacao de expressoes wrapper data Create.
						----> (fixar) teste [DicionaryText] falhou.
						----> (fixado) teste [Matriz] falhou, em [SetElement].
								-----> (feito) tipos da expressao nao estao sendo setados para envelopes de expressao. deve voltar um tipo de expressao. 
											---> se for	um expressao operador, o tipo da expressao deve ser o do tipo de retorno do operador. 
											---> se for um expressao chamada de metodo, o tipo de retorno do metodo.
											---> se for uma propriedade aninhadas, os tipos relatado neste dia, anteriormente.
											---> se for uma atribuicao, o nome do objeto que recebe a atribuição.
								-----> (feito) falha justamente em indices como: x+1, y+x_5, onde há varias expressoes componentes, envelopadas numa expressao container.
											---> deve ser setado no retorno das expressoes, em [Expressao()].


[WrapperData Objects]:
			-----> (codificado) para associar um dado de matriz a um objeto, é claro o tipo do objeto item de matriz é double, e associado na atribuição a um double.
			-----> verificar a extração de wrappers data object, se houver mais de 1o. objeto wrapper na expressao, pode falhar.
			-----> a extração de tokens processado nao está validando para tokens de wrapper data matriz.
								-----> (fixar) a falha é justamente em expressao de atribição com objetos wrapper, no lado da expressao valor de atribuição.
											----> a verificação se é expressao set element/ get element é pelo operador igual [=],
											que não está verificando se o nome do objeto wrapper está antes ou depois do operador de igual [=],
											causando confusão entre tipos de chamada de metodo, se é chamadas de expressao: set element/ get element.
											----> em uma expressao get element, nao estava encontrando o nome do objeto wrapper da expressao,
											obtinha do indice=0, o que não é verdade se o objeto wrapper está numa expressao de atribuicao, p. ex.
											----> em uma expressao set element, pode-se "supor" que o token[0] contem o nome do objeto wrapper,
											porque set element é uma expressao inteira, abragendo expressao de atribuicao.


			----> teria que retirar os tokens consumidos, da anotacao wrapper, get/set element, para procura de mais e 1 objeto wrapper
			na mesma anotacao wrapper.


[WrapperDataMatriz]:
			-----> para expressoes set element, get element (somente o objeto wrapper), foi validado,
			mas em expressoes de atribuição, com get element diverso do tokensExpressao[0], falhou.
								----> uma expressao de atribuição, veja só, validou para uma atribuição com um objeto int como
								objeto a ser atribuido.
_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.08:		

[WrapperData]:
				(codificado)----> preencher com vazios o lugar dos tokens processados, por que? Em uma expressao: m1[1,1]+m1[2,6], o algoritmo de get element para o segundo wrapper
				vai para o primeiro wrapper! Preenchendo com vazios, o algoritmo vai para o lugar certo, ao processar o seuundo wrapper. Já havia essa
				preocupação, ao retirar os tokens processaods, da string notacao wrapper, mas não é esse o caminho, por que? Porque a string é reconstruida,
				perdendo a referência. Concentrar os esforços em notacao wrapper como uma lista de tokens, não uma string, não importa que isso leve a testes mais
				complexos...
				
[ExpressaoGrupos][ChamadaDeMetodoWrapper]:
				----> (fixado) VERIFICAR URGENTEMENTE O TIPO DA EXPRESSAO DA CHAMADA DE METODO WRAPPER, nao está como o tipo do elemento do objeto wrapper,
					  mas o tipo do wrapper, NAO elemento....
					  
				-----> (feito) SETAR o tipo do elemento de [Vector], em [WrapperDataVector], o tipo está descrito na definição da instanciação!!!
				
[ExpressaoGrupos]: 
				----> (fixado) fixar a atribuicao de vetores, como x=v2[5].
				----> (fixado) no ex., o objeto [x] está sendo registrado! deveria se retirado da lista de expressoes de retorno.

				[Matriz]: nao está retornando uma expressao de atribuição correta!!!.
								----> (fixar, mais seguinte)atribuicao sem operadores, validou.
								----> (fixado) atribuicao com operadores falha.

				----> (fixado) expressoes complexas, está retornando a chamada de expressao get/set element, verificar a validação de operandos, em operador binario/e unario.

[WrappersData]: (codificado) o problema está no setar o tipo da expressao chamada de metodo, não está com valor correto, retorna "null", no caso de matriz deveria ser "double";
				----> (fixado) verificar o [WrapperDataDictionaryText], é preciso verificar quando é um set element, porque nao se aplica o sinal de igual.
		


[ExpressaoGrupos]: fixar urgentemente, o codigo quebrou no processamento de objetos wrappers.
					(fixado) o codigo do metodo: ExpressaoGrupos.BuildCallingMethod() quebrou!
					(fixado) o processamento de operadores, quando já extraido os dados de operadores, em atenção a operador "=".

				   dividindo a funcao de extrair expressoes, facilitou porque nao é preciso percorrer centenas de linhas de codigo até encontrar onde está o codigo a fixar..


[ExpressaoGrupos]:
					(feito) é preciso retirar as expressoes operandos, da lista de retorno de expressoes, quando aparece um operador!.
					(fixado) o tipo de retorno de wrappers data objetos, está como o tipo do wrapper, nao o tipo dos elementos.
					
_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 08.08:
[ExpressaoGrupos][ProcessingOperators()]:
		----> (nao funciona) implementar o preenchimento com vazio os tokens nao resumidos, para previsão quando há mais de um objeto do mesmos tipos.


		----> (fixado) o operador após um atribuicao (operador igual), não está sendo inserido corretamente!
		----> (fixado) numa expressao de atribuicao, nao está aparecendo o objeto que é atribuido, ou é falha, ou não está a expressao sendo instaciada corretamente.
							----> parado no linha 459, [ExpressaoGrupos], verificar a inserção da expressao atribuicao, e a expressao operador.
							nao é certo que esvaziar a expressao de retorno, retorne a expressao correta.
										----> equacionamento visto, retorna o objeto que recebe a atribuicao + uma expressao operador igual+ uma expressao de atribuica.



[Testes ExpressaoGrupos]: (codificado) mais testes unitarios: com +2 operandos de objetos wrapper, operandos com indices compostos.
							----> (FIXAR)falha esperada: a localizacao de tokens nome de objetos wrapper falha...
							----> (fixado) o processamento de operadores.
											-----> foi preciso modificar a classe Objeto, que em expressoes objeto, retorna o tipoElemento, setado tipoElemento= tipo;
											nao modifica nada, mas para wrapper data objects, o tipoElemento é modificado para o tipo elemento do wrapper object.

							----> a retirada de operandos, no metodo [ProcessingInsertingOperators()] está falhando, porque a remoção do 2o.objeto wrapper nao está
								  sendo feita: operadores que nao o igual...
											-----> (fixado) o metodo: ProcessingWrapperDataObjects().
											-----> (feito) implementado o preenchimento com tokens "", para prevenir obter tokens de objetos wrapper sejam processado
											corretamente, obtendo o indice correto.


[Testes ExpressaoGrupos WrapperDictionaryTexts]:
							----> (fixar) fixar os metodos GetElement,SetElement, de [WrapperDictionaryText].
											-----> o processo estava td certo, mas quando encontrar o tipo da expressao, e um metodo GetTipoExpressao() desatualizado,
											causava a invalidacao.
							----> (fixar) fixar o metodo SetElement, de [WrapperDictionaryText].
											-----> fixar o metodo [gerenciadorWrapper.ConverteParaTokensChamadaDeMetodo()], não está processando o metodo DictionaryText.SetElement().
														---> ahhh, este metodo espera um token de operador igual (=) para fazer o processamento. modificar o 
														metodo WrapperDictionaryText.SetElement(), para o template {chave}=valor, e não {chave, valor}.


_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 09.08:

[WRAPPERDATA]:
		----> resolver o problema do retorno do tipo de elemento de um wrapperdata: nos testes, foi preciso setar manualmente o tipo de elemento,
		por alguma razão o construtor não setava correetamente o tipo elemento.
								-----> (verificado, havia sim) verificar se há 2 campos para tipoELemento, 1 de Objeto e 1 do WrapperData.
								-----> (feito classe vector) melhor sobrescrever os metodos GetTipoElemento, SetTipoElemento.
								-----> (fixado) os campos de objeto vector estão instanciados corretamente, no escopo,
									   mas não na expressao. observação do objeto vector do teste nao foi vista, mas o metodo que implementa a chamada.


[WrapperDictionaryText]:

	[Metodo SetElement]:
		---> (feito) melhor ter no construtor ter um tipo de elemento, pois assim poderá fazer operações como: {a1}+{a2}, se a1.tipoElemento for string, double ou int.
								----> a sintaxe para instanciação mudou, contendo um parametro entre os brackets, um token do tipo de elemento.

		---> (fixado): com subida do metodo [WrapperData.isSetElement] para abstrato, todas classes wrapper implementam
		este metodo, que no DicionaryText é diferente: não se guia pelo operador igual, mas a presenca de uma virgula entre os parametros.

[Expressao]:
		---> testes unitarios e de integração feitos.

[ExpressaoGrupos]:
		---> os erros estão concentrados na parte de chamadas de metodos, e expressoes entre parenteses, ou seja, grupos de tokens entre parenteses.

		---> (fixar) um monte de testes falhou! 
				[ExpressaoChamadaDeMetodo]:				
								----> (feito) convertido a extração de expressões, de [ExpressaoGrupos.ExtraiExpressoesIndependentes()],
								para [Expressao.ExtraiExpressoes()].
								----> (fixado) parametros das chamadas estão sendo adicionadas antes da expressao chamada!
								----> (fixado) problema na extração parametro de uma expressao entre parenteses.
				[ExpressaoPropriedadesAninhadas]:
								----> feito.

				[ExpressaoEntreParenteses]:
								(fixar) resultados tenebrosos.. sem expressões entre parênteses.
											----> (fixado) operadores da expressao principal nao estão extraidos corretamente!
											----> (fixado) expressao entre parenteses sem tipo de expressao.
											----> (fixado) operador igual sem processamento correto!

				[ExpressaoPropriedades Estaticas, Chamadas de metodo estatico]: propriedades, chamadas de metodos, estaticas dentro do trecho de codigo de funções sem parâmetros.
								verificar se fica no laço principal.
							----> nao esquecer de testes de propriedades, chamadas de metodos estaticos, que é dificil
							de codificar classes com propriedades estaticas.

				

		----> funcoes parametros! bastando incluir no metodo de encontrar funcoes compativeis, uma olhada no escopo,funcoes,
		se tiver, valida o parametro. em muitas linguagens: C++, C sharp, Javascript, tem funções parâmetros,e é
		um recurso valioso, permite configurações maiores, entre outro.
________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 10.08:

(feito)[ExpressaoGrupos]:
	
				
				(codificado) compor na extração de operador igual, a possibilidade de expressao que recebe
						     a atribuição, como uma expressao propriedades aninhadas..

				(feito): converte os testes de ExpressaoGrupos.TestesExpressaoPropriedadesAninhadas, para compor com [Expressao],
				e nao [ExpressaoGrupos];
								-----> (fixado) um dos testes unitarios falhou com exceção fatal!
				
				
				Observações:
						----> codificado metodo muito util: verificar se há algum metodo numa classe com nomes (nomeClasse,nomeMetodo), corta um bocado de codigo,
								e é mais eficaz.

						----> a ideia de instanciar variaveis com todos tipos que o token pode ter, facilita na arvore de if/else de procura 
								de qual tipo de expressao está ocorrendo.




(feito)[Expressao]:
			---> em razão (ou sem razão), o teste de operador unario e binario "-", quebrou, ante os erros fixados em [ExpressaoGrupos].
							----> é "certo" que as expressoes deste testes aparecem como [ExpressaoAtribuicao], então se for assim, o teste passa se 
							a expressão resultante seja [ExpressaoAtribuicao].
							----> a nova anotação para operadores, ficando a parte dos objetos, para compatibilizar com o EvalExpression.Eval(),
							desatualiazou os testes unitários neste cenário.


(A FAZER) [Projeto]:
		---> (em testes)começar e arrumar a classe EvalExpression, metodo Eval(), para executar chamadas de metodo, afim de testes das
		bibliotecas feitas: matemática (na classe [double]), processamento de texto (na classe [string]), escrita/leitura
		de console (classe importada Prompt), manipulação de arquivos (classe implementada, nao é lembrado o nome da classe,
		mas foi feita em C++ com ponte de codigo gerenciado). TODAS ESTAS CLASSES JÁ FORAM CODIFICADAS.

		---> (feito) verificar urgentemente o compilador em [ProcessadorID], não está compilando instanciações como: "int x=5;".

_________________________________________________________________________________________________________________________________________________
Daily Scrum 11.08:

(feito)[ExpressaoGrupos]:
				----> testes, sobretudo para [ExpressaoChamadaDeMetodo], com métodos codificados com a Linguagem Base, como int.Soma(x,y).
				----> classe [double] tem metodos estáticos! executar testes com metodos estaticos da classe [double].
								----> 1 teste unitario, validou para chamada estática, com um metodo da classe [double].
				----> alguns testes desatualizados, mantendo a extracao com [ExpressaoGrupos], que é uma classe
				de bastidores, o processamento é feito com [Expressao], mas com utilizacao da classe [ExpressaoGrupos].
				e tb, sem blocos try/catch para precisar o teste com a validacao especifica sem quebrar os testes.
			
				----> CONSTATAÇÃO: foi boa ideia inicializa o token currente com todas as possibilidades com variaveis
				auxiliares, dando melhor legibilidade do codigo para a malha de processo de tokens.
				e tb., metodo de verificação rápida de propriedade aninhada, melhorou a malha de tokens
				que não precisa entrar num dos blocos else para fazer o teste, fugindo da leitura com validação do tipo de token que é...



(em testes) [EvalExpression.Eval()]:
		
				----> testes iniciais, sem definir uma das variaveis, aí não queria mais nada hein, tinha que falhar..
				----> metodo [Expressao.PosOrdem()] operacional, só precisou atualizar para compor com [ExpressaoAtribuicao],
							que é uma expressao feita posteriormente a codificacao do metodo posordem, e faz tempo...
							Atualizado tb este metodo para casos de [ExpressaoEntreParenteses], que retira o aumentoo de prioridade
							de operadores em funcao de tokens parenteses.

				----> falha no calculo da funcao que implementa o operador do teste unitario.
				----> outra nova funcionalidade, o operador binario e unario ao mesmo tempo, invalidou a procura por 
				operadores no repositorio, obtendo como operador unario, quando deveria se binario.
				----> testes iniciais, operador binario e unario, e binario somente, feito com 3 testes unitarios.
				
				(A FAZER):
						----> testes de execução de expressao com metodos estáticos, como da classe [double].
				

(feito)[UtilTokens]:
		----> fixar em [UtilTokens] obter operadores unarios, binarios, o tipo de operador, do jeito que está está retornando apenas o primeiro operador com o nome parametro,
		sem verificar se o tipo do operador é unário, binário. Foi fixado para obter operadores binarios, fazer para obter operadores unarios (outro metodo).


(feito)[ProcessadorID]:
		-----> fixar a instanciação repetida de variaveis, quando se codifica o codigo da variavel duas ou mais vezes...


(feito) [Projeto]:
		---> (feito até o presente momento).Metodo [Eval(), e PosOrdem(), atualizados e validados com 3 testes unitarios]
		começar e arrumar a classe EvalExpression, metodo Eval(), para executar chamadas de metodo, afim de testes das
		bibliotecas feitas: matemática (na classe [double]), processamento de texto (na classe [string]), escrita/leitura
		de console (classe importada Prompt), manipulação de arquivos (classe implementada, nao é lembrado o nome da classe,
		mas foi feita em C++ com ponte de codigo gerenciado). TODAS ESTAS CLASSES JÁ FORAM CODIFICADAS.
						----> como registrado, metodos [EvalExpression.Eval()], e Expressao.PosOrdem()] fixados, e 
						atualizados com os novos tipos de [Expressao], como [ExpressaoAtribuicao].
________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.08:


[OperadoresNativos]:
		----> (feito) o codigo de instanciação de operadores nativos está confuso: tem que setar a prioridade com uma função especifica, engessando
		a adição de novos operadores: deveria ter um metodo como: AddOperador(MethodInfo, nomeOperdor, prioridadeOperador),
		e então adicionar operadores com um metodo facil de modificar, adicionando novos operadores...
						----> (feito) implementando. operadores de matriz precisam ser codificados novamente, usa [params] na interface de parametros, deveria se Matriz os operandos.
		----> operadores agora facil de extender: em OperadoresNativos.GetOperators(), adicionar o operador, com seu metodo importado
		da classe base. Muitas linguagens utilizar a linguagem C para seus codigos, nossa linguagem utiliza a linguagem C Sharp..



[ExpressaoGrupos]:
		----> (fixado) fixar o caso teste:  "objetoB.propriedadeB.metodoA(1,1);"; na parte de propriedades aninhada seguida de chamado de metodo aninhado.
						----> metodo de construcao do aninhamento já tinha previsão de 1 chamada de metodo aninhado,
						e tb extraia tokens parametros com a expressao grupo principal, o que acrescentava os parametros
						da chamada como expressoes de retorno.

[Metodo.ExecuteMethod()]:
		----> rever o codigo de execução de metodo, para validar expressoes chamadas de metodo feita em [EvalExpression.Eval()].


[EvalExpression.Eval testes]:
		----> (feito) fixar o processo de expressoes parametros.
						----> justamente a instanciação do objeto caller, para metodos importados...
										----> estava em loop infinito, a instanciacao com construtor importado, retornava
										para a classe de definição de operador. foi preciso instanciar o objeto caller
										de metodo importado, quando na execução do operador.

		----> (feito): execução de chamada de metodo, como: "double.abs(x)";
						----> fixar a obtenção de valores parametros, está retornando como valor de parametro com tipo string.
		----> (fixado) boas noticias: o tipo "float" está com nova represantividade, fixar em [ExpressaoNumero], a obtenção
						do tipo float, de "1.0" para "1.0f";

		----> 1a chamada de metodo feito.

		----> só havia previsao para valores de objetos, nao de tipos numeros, literais, que são constantes e não tem um
		valor de objeto, não havia ou estava falhando.
__________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.08:


[UtilTokens.GetMethodCompatible]:
		----> (feito) se um método com valor isToCountObject= true (o nome não é esse), a procura por metodo compativel falha,
		porque não há previsão deste atributo no referido metodo [UtilTokens.GetMethodCompatible()].
		fixando, será possivel: "a.abs()", em vez de "double.abs(a)", que é anotação VÁLIDA TESTADO...
					----> (estão)  além deste metodo, verificar se os metodos da classe [double.Math], e [string.metodos], estão
					com este atributo esteja = true.
		----> (feito) neste metodo, foi preciso adequar os tipos importados via reflexao, que tem nome longo: "Sytem.Double", é "double" nos tipos da linguagem orqidea.

[Metodo.ExecuteAMethod()]:
		é possivel simplificar a chamada de metodo quando o metodo é importado da classe base: escopo, objetos paremetros não precisam ser 
		armazenados no escopo.

					
(TESTES).[EvalExpression.Eval() testes][ExpressaoChamadaDeMetodo]:

		----> (codificado)tem previsão de armazenar o resultado para uma propriedade aninhada? codificar para isso.
						

		----> (feito) em Eval(), a previsão de numero em expressao sem elementos está desatualizada... fixar com a notação de [ExpressaoNumero]:
		diferenciação de [float] de [double].

		----> (fixado) testes com a notação reduzida, falha: apesar de reconhecer o metodo compativel, há problemas na adição do objeto caller nos parametros da funcao...
					----> fixado a anotação reduzida, mas falta a anotação estática. se for para incluir o objetocaller, incluir quando
					na avaliação da chamada de metodo perceber que a funcao não é estática e informe de incluir do objeto caller como parametro.
						O PORQUE DESTE MALABARISMO:
								----> é um requisito do product backlog, que pode-se escrever "double.abs(x)", para "x.abs()" em classes "double","string", que não
								são classes extensíveis via codigo: são metodos na linguagem base, importado.
								A FIM DE CUMPRIR ESTE REQUISITO, FOI FEITO A EXTENSÃO DO CÓDIGO. ambos codigo são validos.

		----> (fixado) o metodo Eval(), quando avalia exrpessoes com operador unitario "-",como "-1"						
								---->(fixado) um metodo getter estava retornando valor invalido! direcionado para o valor sem getter.

		-----> (fixado) fixar a anotação: "x.abs()"!!! (passagem por referencia de metodos, precisa clonar).
								---> funcao abs(), com campo [isToIncludeObjectCaller]= true..
												-----> (fixar) em algum lugar do codigo, perde-se dados de inclusao de objeto caller.
												-----> (fixado) os metodos estão sendo passados por referencia, perdendo propriedades setadas anteriormente! clonar o metodo,
												e com os valores setados.
								---> foi preciso clonar os metodos, pois há metodo com atributos particulares, como [isToIncludeObjectCaller],
								e [isStatic]..
			

[LinguagemOrquidea]:
			----->(ja esta setado, mas nao é aconselhavel, porque depende de como o codigo é escrito,
						setando ou nao este atributo) setar diretamente nos metodos das classes "double","string", o valor de [isToIncludeObjectCaller] nestes metodos,
						deixando visivel onde o codigo foi alterado.
			-----> mantido o processamento em [ExpressaoGrupos] (setar atributos de notacao), e [UtilsTokens.GetMethodCompatible] (clona o metodo).
			
			-----> ("rejeicao para a solucao, motivos desconhecidos") para manter legivel e econtrar este codigo, pode-se criar uma função que analisa os tokens da expressao,
			e seta de acordo, se for de classes "double","string", podendo escalar industrialmente para mais classes,
			este tipo de notação ("double.abs(x)", e "x.abs()");



____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 16.08:

[EvalExpression.Eval()]:
			----> (ja foi codificado) fixar o seguinte problema: numa expressao de atribuição, o resultado final não é setado ao Objeto/PropriedadesAninhada,
			isto foi anteriormente deixado para o processo operador "=", mas isto não é atingido: para na expresssão atribuição! (que é um novo tipo de expressão,
			implementada posterior ao código de EvalExpression.Eval()...).
					----> VERIFICAR SE HÁ ASSOCIAÇÃO DO VALOR AVALIADO PARA UMA PROPRIEDADE ANINHADA.
[Testes]:
			----> continuar os testes para as bibliotecas [Math.double],[string]...
			---> valores calculados e atribuidos a valor de Objeto, feito.


[Mudanças]:
			----> nova funcionalidade: multi-argumentos! Um metodo pode ter varios  multi-argumentos, desde que verificando que o próximo argumento (multi-argumentos ou nao)
				nao seja do mesmo tipo do argumento anterior, para nao incorrer de registrar um parametro multi-argumento, com o proximo parametro multi-argumeento ou não.
							----> (feito a remocao do codigo deste caso de uso) caso em que há passagem de parametros nao-multi argumentos, substituida pelos parametros-multi-argumentos, que são mais abrangentes, abarca este caso também.
							----> a implementação:
												----> (feito) em headers, acrescentar o operador: "!", que sinaliza que o arqumento é multi-argumentos.
												----> (codificado) em UtilsTokens.GetMethodCompatible(), verificar a passagem pelos multi-argumentos,
													   e transformação de multi-argumentos num array de Objeto!. isto soluciona, e muito...
												----> (codificado) validado em [UtilTokens.GetMethodCompatible], segue em [Metodo.ExecuteAMethod],
												a reunião dos grupos de parametros multi-argumentos em arrays do tipo [Vector].

												----> os parametros multi-argumentos DEVEM SER DO TIPO VECTOR.
							----> modificaões em: [FileHeader], [UtilTokens.GetMethodCompatible], [Metodo.ExecuteAMethod].
												----> em file header, a definicao de um parametro multi-argumento é: "tipoElemento[] Vector nomeDoParametro",
												segue a definicao de instanciacao de Vectors.

				[Expressao]:
							----> testes com metodo de classe com parametro multi-argumentos.
												----> (fixado) por isso a codificação de testes unitários em massa! um nome e classe de um parametro multi-argumento
												se perderam nos indices de tokens...


							---->(A FAZER) é preciso VALIDA CASO HAJA DOIS MULTI-ARGUMENTOS EM SEQUENCIA, E DO MESMO TIPO DE ELEMENTO: como diferenciar 
							em qual parametro multi-argumento um parâmetro de chamada de metodo pertence? tem que lançar uma exceção caso haja dois multi-argumentos
							do mesmo tipo de elemento.

				[Parametros multi-argumentos]:
							----> (fixado) falha no codigo do teste: lançou exceção porque não havia definido um dos objetos utilizados.
							----> (fixado) seguindo no teste, (fixar) falha no metodo [UtilTokens.GetMethodCompatible()].
							----> (fixado) (fixar a instanciação de parãmetros [Vector] que não está setando o tipo do elemento).
										-----> para fixar, vai ser preciso pensar um pouco.
										-----> uma solução inicial seria criar um campo [tipoElemento] em [HeaderProperties],
										e passar o valor do tipo de elemento do Vector. mas ai seria preciso
										trocar o processamento deste metodo, de repositorio de classes para header.classes,
										nao afeta, mas é preciso implementar..
													----> (feito) codificação se 1 campo para [tipoElemento] em [HeaderProperties].
										-----> codificado no extrator de metodos, 1 campo para captar o [HeaderProperties.tipoElemento].
										e no metodo [UtilTokens.GetMethodCompatible()], a verificação com o [parametro.tipoElemento].
										o teste passou.
							----> verificação se é parametro multi-argumento, em [UtilTokens.GetMethodCompatible()],
							é preciso verificar, os indices podem ter coincidindo...
______________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.08:
(IMPLEMENTAÇÃO DE parâmetros multi-argumentos):

(codificado)[Parametros multi-argumentos]:
		---->(codificado) é preciso VALIDAR CASO HAJA DOIS MULTI-ARGUMENTOS EM SEQUENCIA, E DO MESMO TIPO DE ELEMENTO: como diferenciar 
		em qual parametro multi-argumento um parâmetro de chamada de metodo pertence? tem que lançar uma exceção caso haja dois multi-argumentos
		do mesmo tipo de elemento.
					-----> modificação feito em [ExtratoresOO], [UtilTokens.GetMethodCompatible].
					

(fixado)[UtilTokens.GetMethodCompatible()]:
		----> (fixado) verificar a matemática de indices da verificação de parametros da função que são multi-argumentos.




(IMPLEMENTAÇÃO de parâmetros wrapper data objects):
[FileHeader]: (para possibilitar wrapper objects como parametros)

		----> (feito, mas observar o recorte de parametros, relatado em seguinte)
		implementar urgentemente a obtenção do tipo elemento quando for um wrapper data object.
		há um metodo abstrato em [WrapperData], que faz a verificação se é wrapper data object, mas para
		obter o tipo de elementos do objeto, não foi implementado.

	
		----> (fixado) testes com instanciação de wrappers data object em [FileHeader] resultou em recursao infinita!
					
[FileHeader]:
			----> (não será preciso) vai ser preciso recortar exatamente a definicao de parametros, em [FileHeader.Property].
			OU validar o match de tokens para tipos wrapper data.
					----> metodos de obter nome, tipo de elemento, e tipo de wrapper, não utilizam regex expression,
					ou se utiliam como o tipo de wrapper, é independente do resultado.
					----> Ah, regex expressions reconhece padrões mesmo sem recorte exato dos tokens! Mas 
					para obter o nome, utilizava-se posições fixas de tokens, o que não é valido quando
					não recorta os tokens.

			----> (codificado) vai ser preciso recortar os tokens wrapper data: por que? porque pode ter na mesma lista de tokens
			2 ou + definições de wrapper data objects parametros...

		


[WrapperData]:
		----> (feito) codificado funcoes de: obter nome, verificar se e um determminado tipo de wrapper object, obter o tipo de elemento do wrapper object, obter o contador de tokens
		de definição de wrapper object.
		----> (fixado) fixar a validação de nomes e tipos elementos, cenário de teste onde está retornando valores
		válidos para +1 tipo de wrapper data ao mesmo tempo.
		----> (fixado) a obtenção de nomes de wrapper data: matriz, dicitonaryText, jaggedArray.

[WrapperData]: codigo de nome, e tipo de wrapper, dependente de outros tipos de wrapper. acrescimos de novos
tipos de wrapper data será preciso revisar todos codigos de wrapper data object!





___________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.08:

(implementação multi-argumentos):
(feito) [Metodo.ExecuteAMethod()]:
		----> (se um unico teste cobre os casos, feito então) testes para parametros multi-argumentos.
		----> um unico senão é que não está havendo a validação de objetos multi-argumentos para parametros normais seguido de parametro
		multi-argumento, do mesmo tipo, deveria lançar um erro.

(a testar) (implementação wrapper data objects como parametros):
		----> (fixado)  a falha descrita acima está na falha de implementação de wrappers data objects em [FileHeader].
		----> (codificado) metodo de determinação se um parametro é objeto wrapper está errado, porque a lista de tokens não vem formatada
		para um parametro, mas numa lista de parametros.
		
		----> (feito) fixar os metodos wrapper [isThisTypeWrapperParameter()], [GetNameObject()], pois observou-se que 
		a lista de tokens não vem apenas com os tokens do objeto wrapper, mas uma lista de parametros,
		por sorte que há um index apontando para o começo dos tokens wrapper...


(feito, para processamento wrapper de parametros de funcao) [WrapperData]:
		----> (feito) reescrever todos metodos wrapper data. isThisTypeWrapperParameter(), porque a lista de tokens
		não vem com apenas os tokens do objeto wrapper, mas uma lista de tokens, sorte com um index que aponta
		para o começo dos tokens do objeto wrapper.
		----> (feito) adicionar um indice no metodo [GetNameWrapper], porque se tiver dois wrapper object do mesmo tipo,
		na lista de parametros, vai falhar.


(feito)[WrapperDataMatriz]: nao tem jeito: vai se preciso retirar o template classico e ficar com o template tipado. fica
até diferenciado de outras linguagens de programação. 
		

(fixado)[EvalExpression.Eval()]
		----> (fixado, mas erro em teste conforme o relatado seguinte) VERIFICAR SE HÁ ASSOCIAÇÃO DO VALOR AVALIADO PARA UMA PROPRIEDADE ANINHADA.


(feito)[ExpressaoGrupos.PropriedadesAninhadas]:
		----> (erro no cenario de teste, fixado) o codigo para atribuição de propriedades aninhadas quebrou! Foi uma modificação de processamento
		do operador "=" (igual); 

_______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.08:

(Implementação parametros wrapper data)
(feito)[FileHeader]:
				----> (feito) testes de parametros wrapper data.
							----> (fixado) a matematica de indices, e falta de padronização de como o parametro wrapper é escrito, gerou confusão.
												----> (fixado) wrapper vetor está reconhecendo como seu tipo, o tipo [Matriz]!.
												----> (fixado) e tb parametros nao wrapper está entrando na malha de processamento de tokens...
												----> (fixado): nao está reconhecendo como parametro [JaggedArray] e [DictionaryText]!
															----> (fixado) falha na contagem de indices.


							----> (fixado) o corpo do metodo 2 está sendo contado como um metodo a parte!.
												----> falha na escrita do teste.


							-----> teste o mais dificil possivel, com todos wrapper data objects como parametros.


				----> (fixado, erro de escrita no cenario do teste) teste em [Expressao] falhou para wrapper data multi-argumento.
												-----> teste falhou, está duplicando os parametros, quando wrapper data!
												-----> isolado o codigo: FileHeader.GetMethods()...


(Implementação de parametros multi-argumentos)
[Expressao]:
				----> (fixado) fixar o codigo, com o teste Expressao.Testes.TesteExpressaoOperadorVariosOperadores().
									----> compilador funcionando, todos objetos do teste foram instanciados.
									----> falha na escrita do teste, estava sem instanciar os objetos a,b, objetos de outra
									classe sendo utilizada como chamada de metodo de outra classe.

				----> (fixado) fixar o teste de parametros multi-argumentos.



(Planejamento e codificação função parametros)
[Funcoes Parametro]:
		----> (codificado) funcoes parametros! bastando incluir no metodo de encontrar funcoes compativeis, uma olhada no escopo,funcoes,
			  se tiver, e valida os parametros.
									----> testes mantido após a modificacoes de processamento de funcoes em get metodos compativel.
									----> criado um campo que sinaliza se uma expressao objeto, é uma expressao objeto-funcao, afim de dar o processamento
									de metodos compativeis.

		Mais planejamento:
			-----> (codificado na funcao de obter metodo compativel) como testar se um objeto na lista de parâmetros é um metodo-objeto? validar para o tipo de retorno do metodo-objeto?.

(Retirada classe antiga de vetor, não o wrapper data vector)
(feito)[Instrucoes]:
		----> (feito) favor retirar de todas instruções, o trecho de codigo da antiga classe [Vetor], que é subsituida pela
		classe [WrapperData Vector], cujo processamento é por expressoes de chamada de metodo. Isto descomplica quase
		todas instruções, que tem um codigo apenas para tratar [vetor]. O processamento será por ExpressaoChamadaDeMetodo.
									-----> notação: testes de instruções no metodo antigo, em que não há blocos try/catch para fazer a medição exata do teste.


(Pausa):
		pausa para pensar como testar chamadas de metodos com multi-argumentos. vai ser preciso instanciar metodos na linguagem orquidea, com parâmetro multi-argumento.

___________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.08:

(Implmentacao acessors para metodos):
{UtilTokens.getMethodCompatible()}:
			----> (feito) filtrar os metodos com acessores public/private. implementando POO, para acessor sera preciso o escop conter o nome da classe que está extraindo
			atributos POO.
							(feito)-----> será preciso também fazer o processamento de metodos private, mas é necessário
							saber em qual classe o escopo pertence...
							(feito) -----> se tiver fora de todas classes, é possível (há codigo que pode ser escrito fora de classes),
							serão metodos publicos.

[ExpressaoGrupos]:
			-----> (fixado) fixar no teste em que há propriedades aninhadas e chamada de metodo aninhada.





(cenarios de testes desatualizados):
[Instrucoes]:
		-----> (feito) passar as validações dos testes, para o jeito atualizado, com blocos try/catch.
							-----> é possível colocar todos testes num cenario somente, e nao esquecendo de gerar mais testes unitarios em massa.
		
	
[Codificacao Parametros Multi-Argumentos]:
		-----> (codificado) terminar o codigo de processamento de multi-argumentos, em [Metodo.ExecuteAMethod], extraindo parametros,
		e adicionando-os em um [Vector] parametro.


[Testes Parametros Multi-argumentos]:		
		-----> testes de chamadas de metodos com parâmetros multi-argumentos.
							----> (feito) processamento de parâmetros multi-argumentos, em teste passou.
							----> (codificado) codificar em [EvalExpression.Eval()] teste com parametros multi-argumentos.
							----> (fixado) o codigo em [Metodo.ExecuteAMethod()] quebrou, para expressoes em que se inclui o objeto-caller na lista de parâmetros!
											-----> falha desconhecida não está incluindo o objeto caller na lista de parametros.
											-----> a falha está em [ExpressaoGrupos], não está nem processando a expressao!
											----> investigando, o metodo que falhou: [ExpressaoGrupos.BuildChamadaDeMetodo()].
														----> fixado: o curioso é que apenas agora falhou, deveria ter falhado quando testes em [EvalExpression].


[Expressao]:
		-----> (fixado) fixar a expressao "-1", que não está resultando valor, quando avaliado em [EvalExpression].
							----> em teste antes do codigo de parametros multi-argumento, este teste passou. e o erro nao tem nada a ver com chamadas de metodo.
							----> a ordem das avaliações alteram o valor do objeto do teste! e também não previsão de objetos na expressao que nao são expressao objeto,
							ou expressao propriedade aninhada, apenas um objeto, sem estar em uma expressao.

		-----> (feito) foi preciso modificar a expresssao de atribuicao, porque em eval expression continha uma brecha em que o resultado do calculo de valor
		não tinha objeto a atribuir, ficando anteriormente um valor de objeto extraido do escopo. pode ser uma propriedade aninhada, o que não tinha previsão,
		e tinha mas não se chegava ao acesso da propriedade aninhada.

[codificacao e testes funcoes parâmetros]:
		-----> termino de planejamento, codificação de funções parâmetros.



(fixado)[FileHeader]:
		----->  os metodos não estão com seus acessors! estão com valores null!



Resumo do Projeto:
		-----> em fase de testes de funções parâmetros, e chamadas de metodo com parâmetro multi-argumento.
		-----> concluido, mais testes de avaliação de chamadas de metodo, função [EvalExpression.Eval()], ja iniciada, mas testar coisas como metodos classe [string].
		-----> testar novamente os cenarios de PROCESSO de instruções.
							----> colocar os testes em notação precisa com blocos try/catch.
		-----> implementação de mais classes importadas da Linguagem Base, como (por exemplo): graficos, um objeto imagem,  um motor de jogos.
_______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.08:

(feito)(Implementacao de parametros multi-argumentos)[EvalExpression Testes]:
		-----> (codficado) codificação do teste de parametros multi-argumentos.
							-----> (esta operacional) pausa para verificar se um metodo com instruções da linguagem está operacional, ante tantas modificações no codigo, ainda que estanques.

(a espera de execução de teste com template functions)(Implementacao metodos-parametros)
		-----> codificado a validação de metodo-parametro da funcao, em relacao a parametros-expressoes de uma chamada de metodo.
							----> se os metodos funcao e metodo da expressao parametro forem equivalentes, valida, e continua a validação dos parametros seguintes.
		-----> (codificacao) codificar teste para metodos-parametros.
							----> (incluido nas classes base) a verificar se um Metodo possa ser compilado como parâmetro. A nao ser que a classe Metodo esteja no repositorio de classes !!!.

		------> Testes:
					----> falha em [FileHeader]: o processamento do metodo parametro não está sendo feito.
							----> VAI SER PRECISO ESPECIFICAR O METODO PARAMETRO, NA SITUAÇÃO ATUAL o metodo parametro
							está sem qualquer definicao...
									----> a solução é adicionar parametros metodo, na lista de parametros de um metodo,
									então o metodo parametro já estará bem definido, e pode ser validado em obtenção de
									metodos compativeis.
			
							-----> é uma técnica: cria-se o metodo parametro, e entao utiliza-se 
							o metodo [Metodo.AddParameter] para adicionar o metodo parametro ao metodo principal.
							Não há como definir antes, porque em FileHeader deve-se estar tudo bem definido.
								
					-----> (codificado) fazer um cenario de teste para validação do metodo-parametro, atraves do teste
					com o metodo [UtilTokens.GetACompatibleParameter()].
					
					-----> elaborar uma simplificação de escrita da classe Metodo.



(nao, nao verifica) VERIFICAR URGENTEMENTE SE OS NOMES DE TIPOS DE OBJETOS, METODOS, PROPRIEDADES, SÃO VALIDADAS antes de definir, em [FileHeader]. se não for,
é possivel criar a classe TemplateFunction e passar como tipo de objeto em parametros de um metodo.

(Implementação de parametros-funcao):
					-----> codificado uma classe para tratamento de metodos-parametros: TemplateFunction.
					codifica-se uma classe-objeto desta classe, e que pode ser utilizada para validação de metodos-parametros.
								----> cada template function tem uma classe com seu nome! pode-se instanciar, ou utilizar como tipo de parametro..
________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.08:


(Implementacao metodo-parametro):
(feito)[UtilTokens.FindMethodCompatible()]:
		[Testes]:
			-----> (feito) foi possivel setar um parametro como [TemplateFunction], possibilitando o metodo-parametro.
						----> nao é possivel numa mesma classe, metodos com mesmo nome, mesma assinatura de parametros, e mesmo tipo de retorno. nao é nexessario
						validar o tipo de retorno.

			-----> SABOTAGEM! DE NATUREZA DESCONHECIDA ESTÁ TEIMANDO EM INVALIDAR O CODIGO DH HEADERS, RETIRANDO DOS METODOS DA CLASSE O ULTIMO METODO...
							----> VOCÊ VAI NO HEADERS, TODOS TESTES PASSAM.
			-----> (fixado) teste de insercao de template, em um metodo feito.
			-----> (fixado) testes para  metodos-parametro.
							----> (fixado) fixar o seguinte possivel erro: o parametro que o proprio template, pode resultar em desordenação na ordem dos parametros!
				

			-----> (feito) verificar o codigo, está sem validar o tipo de retorno do metodo-parametro.

			
			-----> (feito) fixar a ordenação dos parametros de template function.
					----> O NOME DO TEMPLATE PODE SER DIFERENTE, POIS PODE-SE SUBSTITUIR UM METODO POR OUTRO METODO NUMA CHAMADA DE METODO COM TEMPLATE FUNCTION.



[EvalExpression]:
		[ExpressaoPropriedadesAninhadas]:
				-----> mais testes unitarios em massa para calculo de expressao atribuicao com propriedades aninhadas.
							---> atenção na codificação dos testes: teste codificado erroneamente, causou falhas que se pensou ser
							um codigo quebrado: o teste é que estava incorreto.
							---> em teste, surgiu uma questão filosófica: o que fazer quando uma propriedade de um objeto é null? 
							Lança uma exceção, pois o programador errou, ou deixa passar setando um valor "neutro", para o codigo passar
							apesar da nulidade da propriedade do objeto...
							----> teste que falhou estava com expressao montada corretamente.
				-----> (fixado) codigo de propriedade aninhada estava um utilizando um campo da expressao aninhada, que não tinha
				sido atualizada, resultando em erro, pois ==null.


__________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.08:

(feito)[EvalExpression][ExpressaoChamadaDeMetodo]:
	-----> (fixado) fixar o teste para avaliação de expressoes chamadas de metodo, cujo codigo quebrou,
	ante a tantas modificações no código depois da realização do teste.
				-----> (nao é falha, o vetor multi-argument nao estava tipado seu tipoElemento) falha justamente em metodo com multi-argumentos.
	-----> (fixado) o tipo elemento de Vector tipado estava com token errado,
				-----> falha no codigo de [WrapperDataVector]: o tipo elemento estava um token a frente.
	-----> (feito) completar o teste de chamada de metodo com função com parametro multi-argumento.
					------> (fixado em Metodo.ExecuteAMethod(), parte parametros multi-argumento) um fato surgiu: o tipo de elemento do vetor seria "int", mas no processamento, está como "Object".
								-----> fixado se o parametro do metodo for "Object", deixa passar o parametro da chamada currente, sem verificação: o ´parametro do metodo é curinga, aceita qualquer coisa....



UM PROTESTO! Mudando de lugar os testes, gera-se exceções no teste seguinte!!! Foi verificado, não há como um teste
interferir em outro, os objetos, funcoes e expressoes nao sao estaticos... VAI FALAR O QUE? QUE NÃO ESTUDOU, E SÓ FICA NO PROJETO?



(fixado)[WrapperDataVector]:
	-----> (fixado) fixar o calculo do tipo de elemento, em [FileHeader], com [Vector] com tipo de elemento.	


(feito)[UtilTokens.FindMethodCompatible()]:
	-----> mais testes unitarios em massa para validar e não validar metodos compativeis, testando os acessors (public, protected, private).
					----> (fixado) falha em testes de falha: a logica de programação está deficitario! reescrito o codigo deste metodo.
	-----> testes para este metodo:
					----> (UM PROTESTO) A SABOTAGEM CONTINUA INSISTINDO: UM PARAMETRO DE FUNCAO QUE DEVERIA SER UM TEMPLATE FUNCTION, NÃO É TEMPLATE FUNCTION!!! ATÉ QUANDO ESTA PROVAÇÃO?


ANOTAÇÃO: a maldição de herança em POO: campos com mesma função, ou duplicam o codigo, ou esconde da leitura do codigo o campo desta função, proposito.



(Andamento do projeto):
		----> nesta semana foram implantados:
				----> parametros multi-argumentos.
				----> parametros Wrapper Data Object.
				----> parametro-metodo (TemplateFunction).
		----> atualizado classes [FileHeader], e o metodo [UtilTokens.FindMethodCompatible()], reponsável pela validação de metodos entre expressoes.

		----> mais testes unitarios para avaliação de expressoes: chamada de metodo, chamada de metodo com multi-argumento, expressoes propriedades aninhadas: com operador,
		com atribuicao, sem atribuicao.

		----> proxima fase:
					----> testes de avaliação de outras classes, como [string], que tem metodos como a classe [double] (funções matematticas).
					----> testes de instruções, feitas exaustivamente anteriormente, mas ante a modificação do código...
					----> teste de execução de programa VM, com instrucoes.
					----> mais bibliotecas de suporte.
_______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.08:

(feito)[substituicao de TemplateFunction]: UtilTokens.FindMethodCompatible():
					---> retirado a classe TemplateFunction, pouco pratico.
					---> pausa para planejamento: o metodo-parametro vem de uma expressao chamada de objeto? Parece ser a maneira mais simples
					de simplificar a definição dos parametros da chamada.
								-----> codificado uma solução em que o metodo parametro é definido por uma chamada de metodo. contem o nome, a classe, e os parametros
								do metodo-parametro.
											----> (feito) a ideia é boa, foi validada, mas falta colocar na construcao de metodos, em [ExtratorOO], o caso em
											que o parametro é um metodo, nao objeto.
											----> (feito) é preciso de um codigo que carregue os dados do metodo-parametro vindo
											da definicao da classe, para então comparar se os metodos sao equivalentes.

					----> esclarecer o seguinte fato: na definição, não há a classe do metodo, apenas o nome.
					é preciso encontrar o metodo, fazendo uma busca em todas as classes: como validar os parametros
					do metodo resultante desta busca, em relação aos parâmetros da chamada?
											----> é meio estranho: os parâmetros do método-parâmetro vão dentro da
											chamda de metodo utilizado para especificar o relatado método-parâmetro.
	
			
[EvalExpression][Testes]:
					----> testes de execução de expressoes, com funções string.
					----> fixar o teste de metodo [Contains].
											----> o metodo [EvalExpression.Eval()] está tentando setar o resultado para um valor de Objeto de retorno.

					----> fixar o teste de avaliação de parametros multi-argumentos.			

[ExpressaoGrupos][Testes]:
			------> (feito) fixar no teste de [ExpressaoGrupos], os casos: (feito)("objetoB2.propriedadeB.propriedadeA;"), e
					(feito)("chamadas de metodo", como "obj2.metodoB(1,1)").
								----> me desculpe, mas é mais uma sabotagem! O cenario de testes de chamadas de metodo, dito falhou,
								trocando de lugar, o teste passou! Até quando?
								----> me desculpe, de novo, mais sabotagem: no outro cenario de testes de propriedades aninhadas,
								dito "entrou em loop infinito", trocando de lugar, o cenario passou. Até quando?


________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.08:

(feito)[Metodos Importados classes base]:
		-----> metodos importados não estão com [UtilTokens.Casting()] em seus parametros! Por isso os parametros estão com [System.]
		em seus tipos!
					----> inserir o Casting, para parametros de metodos importados.

[Classe String; metodos][Testes]:
		-----> (fixado) falha na execução de um metodo string: Contains(): um dos parametros não está sendo avaliado como
		[ExpressaoLiteral], mas como [Expressao]. levando a erro em tempo de execução do metodo importado.
					----> o codigo da expressao estava com o nome da variavel como texto, deveria estar com o CONTEUDO da variavel...
					então o nome da variável estava contando como valor-parametro, e não era string...

		-----> fixar em [ExpressaoGrupos] uma expressao com atribuicao para um objeto boolean. está gerando exceção fora do limite de array.
					----> a expressao chamada de metodo esta sendo construida?
								---->para 1 expressao está. mas para a expressao seguinte do teste, não está reconhecendo o metodo estatico.
											----> pasmem, o extrator de tokens entre parenteses nao está funcionando para este caso!.

					----> falha na compreensao de metodos para incluir o objeto caller como 1o parametro...
								----> desabilitando esta funcionalidade, o 1o. teste passou, mas o 2o. teste falhou...
								uma duvida é deve-se deixar para incluir o objeto caller como 1o. parametro, ou
								deixar como classe estatica nas chamadas?

					----> deixar para incluir objeto caller nos parametros, em caso: 1- a chamada nao é estatica, E 2- as classes
					sao double ou string...
								----> (feito) diferenciacao quando a chamada é estática ou não estática, no construtor de chamadas
								de metodo em [ExpressaoGrupos].
								----> (feito) consulta na linguagem quais classes podem ter o objeto caller como 1o. parametro: classes double, string,
								em chamadas não estáticas.


					-----> moral da estória: ~5 horas para identificar o erro no codigo, corrigiu-se outros erros, mas
					o tipo da expressao literal não estava setada, resultando em nao encontrar metodo compativel com parametros-expressoes
					sem tipo definido (que é string).

					-----> o codigo "ficou melhor": há uma entrada para especificar a inclusão do objeto caller como 1o. parametro,
					em certas classes, especificadas num metodo consulta que retorna estas classes.

		----> outro erro: o tipo da expressao com uma constante numero, tem que ser exatamente double ou exatamente int,
		não há casting, resultando em falha por esperar double quando o numero foi expresso como int...



(fixado) [EvalExpression][Testes][parametros multi-argumento]:
		---->(feito) (FALHA NA CONCEPÇÃO DO TESTE: TINHA QUE FALHAR, O CENARIO INVALIDAVA AMBOS TESTES) fixar no teste de parâmetro multi-argumentos...
						----> os multi-argumentos nem estão sendo verificados, no metodo get method compatible!!


[EvalExpression][Testes]:


[nota triste]: é um país que passa por cima feito trator nos direitos do cidadão, e como se não bastasse, interrompem trabalhos
que florescem e trazem esclarecimentos em áreas que não entendem...


[UtilTokens.FindMethodCompatible()]:
----> (está) VERIFICAR URGENTEMENTE SE OS PARAMETROS MULTI-ARGUMENTOS ESTÃO SENDO definidos o campo: [isMultiArgument= true].
					----> é um abuso de otoridades: o teste feito na classe [FileHeader], sinaliza corretamente o multi-argumento, já no teste em [EvalExpression], não passa...
					SABOTAGEM! e não adianta a lavagem cerebral que é para "aprender melhor", acontece que minha graduação TCC foi sob testes, não havendo como escapar do ensinamento
					aprendido na faculdade...
________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 30.08:

(feito)(implementacao casting de parametros de funcoes)[UtilTokens.FindMethodCompatible()]:
		----> (fixado temporariamente, com explicitação dos números, diferenciando double de int, por notação: "1.0" é diferente de "1")
		----> (feito, testado com parametros multi-argumento, que contém tb este casting) CODIFICAR UM CASTING PARA QUANDO OS TIPOS NÃO BATEREM, SE FOR INT E DOUBLE, validar (somente aparecendo em numeros constantes
		explicitos)...

		
(anotação): os testes mudam de lugar, passam, porem nem todos, sendo na posicao anterior estes testes que falharam tinham passado! SABOTAGEM terrorista...


[EvalExpression][Testes metodos classe string]:
		----> (feito)explicitar os resultados esperados, nos testes de metodos string...
		----> (fixado) o codigo para funções string, apenas uma observacao é que é preciso retirar as aspas das constantes. para parametros variaveis string,
		----> (feito) os metodos funcionam, porem se for constantes string, que contem aspas, nao passam. Implementar modificacoes de retirar aspas, nas funções de string.
		----> (feito) testes em 3 funcoes string, codificar mais 3 testes unitarios, para cobrir outras possibilidades.
		----> (feito)testes 9 funcoes string, com tb na forma reduzida, e no ultimo teste detectou uma falha no indice de parametro-expressao, dai a importancia de muitos testes,
		      unitarios e em massa...

		----> (feito) teste para retorno da execução da funcao, para um objeto, como [n=texto.IndexOf("Terra")];
					----> fixar o valor de retorno apos uma expressao de atribuicao, em vez de retornar um valor, retorna o tipo da classe.
					----> um errinho no processamento de operador de atribuicao, em vez de todos tokens, para a expressao, estava calculando com tokens resumidos,
					passou porque o tokens resumidos e tokens nao resumidos sao iguais para proprieades aninhadas e objetos, mas nao para chamada de metodo.


(codificado) [Metodo.ExecuteAMethod()]:
		-----> (inserido um hook para processamento de metodos-parametro, em [ExecuteAMethod]) VERIFICAR URGENTEMENTE SE UMA FUNCAO-PARAMETRO
		ESTÁ SENDO INCLUIDA NO ESCOPO DO METODO PRINCIPAL. ultima parte da função-parâmetro.


(feito) [FileHeader]:
		  (feito, implementação está sem erros, tanto para propriedade quanto metodo protected) (SEM PRIORIDADE)(Implementação de acessors para propriedades de classes: está sendo feito, mas quando uma propriedade é protected, o codigo falha e nao obtem metodos ou propriedades da classe).

_________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 31.08:
[Andamento]:
		----> testes de biblioteca matematica e de processamento de strings praticamente feitos.
		----> tao logo esta parte seja concluida, proceder com testes (já feitos, porem ante a modificacao no codigo...), para as instruções da linguagem (programa virtual).


[mudanças aprovadas]:
		----> (feito) uma função string.split é cruscial! retorno na forma de um vector(string).
						[Testes]:
								----> (fixado) fixar o retorno de eval expression para um objeto wrapper.
								----> (feito) o teste fixou o codigo pertinente,
								----> mas (fixar) o codigo de [Vector.SetElement()].
											----> (constatacao) a construcao da expressao SetElement está funcionando, mas está setando
											um valor null, como elemento do vetor. legal ver que a notacao wrapper "m[0]=1" está funcionando.
											----> (fixar) o problema é com constantes char, que não tem previsão. e está como " ", deveria se ' '.
														----> (fixado) reconhece numeros, tanto é que a expressao-parametro tem sub-expressao para numero,
														mas nao está reconhecendo um char vazio...
														----> (fixado) fixar: a chamada de metodo vector.SetElement(), que está setando
														um valor null.
														----> (fixado): o valor calculado em set-element não está sendo repassado para o vector.
																	-----> (fixado) os valores dos objetos do escopo nao estao sendo passados para o escopo de volta!!!
																				----> há criação de objetos a mais no escopo vindo da execução da função, com valores objetc como parametros...
																							----> (notação) que eu me lembre, havia na codificacao primeira do metodo [ExecuteAMethod],
																							previsão de objetos modificados e eram atualizados, mas depois de tantas modificações
																							no código, este trecho de codigo foi removido...
																							----> (fixado) o valor do Vector separador não está sendo repassado!
						
								----->	valor do vetor parametro setado atraves de um vector.setElement!, o codigo dos wrappers funcionando..
								-----> o objeto caller está com tipo nao fixado!.
														----> falha nao equivocada: em ExpressaoGrupos, está setando 
														o objeto caller estático, porém o valor deste objeto está como [object],
														nao [string].
														----> fixado o objeto caller estático, que somente é essencial quando
														o metodo é de uma classe importada. chamada a um construtor do objeto caller,
														com parametros de construtor, vazio.


	  -----> (feito) apenas para "praticar", reformular a função [string.SplitChar], com algoritmo proprio, nao uma chamada da classe importada.
								----> o algoritmo para separadores string, nao char, é mais complicado do que se pensou. mantido
								o algoritmo da linguagem base.

	   -----> (é possivel na forma reduzida) verificar urgentemente se é possivel ter como objeto de retorno de uma função, um wrapper data object. possibilitando funções que retornam arrays, vetores, listas,...		

[classe Vector]:
	   -----> novas funcoes, para melhores resultados.

(implementando)[classe string.metodos]:
	   -----> novas funcoes;

__________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.09:


[Metodos String]:
	-----> novas funcoes string:
			-----> Ocurrencies(text, searchText): retona indice de todas ocorrencias de [searchText] em [text].
			-----> FisrtOcurr; (feito): obtem o indice da primeira ocorrencia de [searchText] em [text].
			-----> LastOcurr; (feito): obtem o indice da ultima ocorrencia de [searchText] em [text].
			-----> CountOcurr; (feito): obtem o indice  da i-esima ocorrencia de [searchText] em [text], contando a partir de 1.
			-----> RemoveFirstOcurr; (feito): remove a primeira ocorrencia de [searchText] em [text].
			-----> RemoveLastOcurr; (feito): remove a ultima ocorrencia de [searchText] em [text].
			-----> RemoveCountOcurr(countOcurr); (feito) remove a i-esima ocorrencia de [searchText] em [text], contando a partir de 1.


			(progrmaçao responsiva, com cuidado com objeto nulo, mas talvez seja preciso fazer testes que falhem).


			-----> CutWords (feito):
						-----> encontrar todas ocorrencias de separadores.
						-----> formar um tabela hash, e inserir os indices das ocorrencias (numero de insercao: quantas caracter tem o separador desta ocorrencia);
						-----> caminhar caracter a caracter, se encontrar um indice!=0, formar uma nova palavra,.
						-----> saltar para o caracter[pos+indice(Ocurr)];
						-----> continuar até chegar ao ultimo caracter.
					----> (feito) testes com separadores chars feito.
					----> (fixado) testes com separadores string, está incluindo o separador no vetor de palavra.

[Metodos String][Testes]:
			----> mais testes em [CutterWords], com varios separadores string, feito com 1 separador string.
					----> (FIXAR): está recortando corretamente, mas a ultima palavra está truncada.

			----> (FIXAR): está recortando corretamente, mas a ultima palavra está truncada.
			----> uma questão pertinente, é se encontrar uma palavra vazia, devido a localização dos separadores, deve ser removido,
			ou não? Na versão currente, palavras vazias não são removido.
						----> indices de separador, na tabela hash, está certo: começa em 1, então para obter o indice do separador,
						deve-se indiceSeparador= tabelaHash[indexChar]-1;
						-----> deve-se ordenar os separadores, de acordo com a ordem de aparecimento no texto total.
						----> (fixado) indice de separador da ultima palavra fixado, mas se o separador ocorrer no começo do texto, nao registra corretamente.
						----> (fixar) fixado o separador do texto, mas se a ocorrencia for no 1a. entrada da tabela hash, nao
						funciona corretamente a extração.
									----> pausa para pensar: o que fazer se a primeira ocorrencia for em tabelaHash[0]?
									
						----> (fixado) tem que obter a letra anterior do separador currente, no incremento da malha.
										-----> melhor visao do algoritmo, na ideia de tabela hash: a palavra currente é atualiza a
										cada iteração da malha de caracteres, não precisa remover o separador: apenas saltar os caracteres
										do separador, formando o indice de começo da palavra seguinte...
			

[Instrucao][Testes]:
		-----> verificar os testes em [ProcessadorID], e não em [ProcessamentoInstrucoes].
					-----> atualizado os testes em [ProcessadorID].
		-----> os testes estão em [ProcessamentoInstrucoes] e [ProcessadorID], com restrição ao que se está testando.

_______________________________________________________________________________________________________________________________________________
Daily Scrum 04.09:

[Implementacao][FileHeader2]:

		----> codificacao da classe FileHeader2;
					-----> codificado novas classes substitutivas: headerHeader, methodHeader, propertyHeader, objectHeader.
					-----> testes:
								----> (fixado) está extraindo e formando funcoes (acessor, tipo retorno, nome, parametros);
								----> (fixado) a malha de tokens: há tokens ponto-e-virgula nao contados no calculo de atualizacao da malha de tokens.
								----> (fixado) a contagem de tokens na extracao de metodos, propriedades, está correto, mas nao há passagem 	para o offset da extração de todas as classes.
								----> (fixado) extração de propriedades, c/s atribuicao, c/s acessors.

		---> fixado obter metodos e propriedades normais, c/s acessors. só aí livrou de um monte de codigo obscuro na classe [FileHeader], dificil de extender,
		como foi visto quando adicionar metodos-parametro.


		----> esta implementação permite acrescentar novas funcionalidades, como funcoes-parametros, e wrapper objects - parametros, ou propriedades.

---->(codificando) implementar propriedades/parametros [WrapperDataVector]: já há uma função para validar [WrapperData Object], importado da classe [FileHeader] anterior.
					----> reutilização de codigo, de [FileHeader], para processo de wrapper data object.
					----> integração do código reusado na estração de propriedades de class, sem efeitos colaterais.
					----> integracao do codigo reusado na extração de parametros wrapper object, de metodos, sem efeitos colaterais.





(planejamento de metodos-parametro)PLANJAMENTO: nova classe [FileHeader]:

	-----> a classe [FileHeader] está com codigo regex, e está complicado: nao da para extrair parametros-metodo.
				-----> algoritmo:
							-----> se encontrar um acessor, reserve como acessor de classe.
							-----> se encontrar um token "Classe", reserve como a classe currente. guardar o nome (proximo ID), e o acessor reservado.
										-----> extrair os tokens da classe: o operador "{,}" tem que ter a pilha=0.
										ao chegar com pilha=0, os tokens foram extraidos.
													----> com os tokens da classe:
															-----> se encontrar um acessor, reserve como acessor de propriedade/metodo.
															-----> se encontrar dois IDs em sequencia:
																		---> se o token apos os IDs for ";" ou "=", é uma propriedade: guarde como propriedade da classe.
																		---> se o token apos os IDs for "(", é um metodo: guarde como metodo e extrais os tokens do metodo, como a extracao dos tokens da classe.
																		---> (a pensar): se o token dos IDs não forem ";" , "=" , ou "(",
																		os IDs fazem parte de um WrapperData Object.
																						----> se for wrapper object: encontrar tokens ";","=", ou "("
																						mais proximos: entre este token e os tokens IDs em seguida,
																						forma uma propriedade wrapper object, ou lançar um erro.
															 ----> se não encontrar 2 IDs seguidos apenas 1 ID, verficar se eh um metodo sem tipo de retorno: se o proximo caracter apos o ID for "(", fazer o processamento de extracao de metodo.							
															
															-----> se nao encontrar 1 ID pelo menos, lançar um erro...
															
																
													-----> com os tokens do metodo:
															----> extrair a interface de parametros:
																		----> extrair a interface: tokens entre parenteses, ate  que a pilha de parenteses=0;
																		----> remover os parenteses fronteiriços.
																		----> caminhar pelos tokens: se encontrar uma virgula, e se a pilha de operadores "()","{}", e "[]" for=0,
																			  reserve como um parametro:  observe que o parametro pode ser uma interface de metodo-parametro, ou wrapper data object!
																			  em caso geral, o parametro tem numero de tokens igual a 2 IDs, 
																			  mas se for wrapper object, ou assinatura de metodo, contera mais de 2 tokens.  (primeiro passo é testes com parametros gerais);
																			  
																		-----> ao atingir o final dos tokens da interface, não esquecer de registrar o ultimo parametro.
															----> guardar os tokens do corpo do metodo: apos o ultimo token da interface, encontrar o operador "{",
															extrair tokens entre os operadores "{,}": ha funcao em [UtilTokens] para isso.
													-----> extraindo as propriedades, e metodos, o header da classe está formado.
													
																		
	
_________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.09:

(Implementacao)[FileHeader2]:
			----> (feito) codigo reusado extração de herança/deserança, em [HeaderClass].
							-----> (fixado) a inclusao da interface de heranca/deseranca quebrou a lista de tokens de classe.
			----> (feito) testes de operadores.  
			----> (feito) testes de parmetros/propriedades wrapper objects.
							-----> (fixado) o indice da malha de tokens, após processamento de 1 wrapper object.
							-----> testado forma classica e forma reduzida de wrapper object, tanto para propriedade quanto parametros de uma funcao.
			----> (feito) testes com parametros multi-argumentos.				

[FileHeader2]: até aqui, o código faz o que a classe [FileHeader] anterior fazia, com alguns incrementos: 1- parametros de metodo com objetos wrapper; 2- corpo de instrução de operadores extraidos;
			----> (codificado) implementar o tipo de parametro: metodo-parametro.
			----> (fixado) modificação no codigo, para compor parametro-metodo, e tb extração do ultimo parametro, que pode nao ser normal, conforme previsto no codigo anterior,
				  quebrou o codigo de MethodHeader!
							---> fixado a contagem de tokens para parametro-normal com atribuição.
							---> o extrator de parametros de metodo quebrou! (caso nao previsto de nao haver parametros, quando obter parametros wrapper-object, e parametros-metodo).

			----> testar parametro-metodo.
							-----> ATUALIZAR A CONTAGEM DE TOKENS de um metodo-parametro, para compor com tokensMetodo.Count, pois não há previsão de tokens como virgula, e operadores de bloco...
							


__________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum:06.09:

(fixado)[FileHeader][FileHeader2]:
		[codificando] fixar urgentemete, em [FileHeader], [FileHeader2], as propriedades redundantes, há mais de uma propriedade para name,p.ex,
					-----> é preciso estar sincronizado, as duas classes [FileHeader][FileHeader2], os mesmos nomes, para a migração
					de [FileHeader], para [FileHeader2].

		classe [FileHeader2] com sintaxe mais clara, mais facil de adicionar novas funcionalidade (coom o propertyMethod),
		e sem utilização de expressions-regex, que torna confuso o codigo, apesar da ideia de expression-regex é validos.
		-----> MIGRAÇÃO DE CLASSES: sem muito a fixar, apenas o metdo de extrair [HeaderClass] de tipos base do orquidea, ficou faltando.
		-----> (codificado) o codigo [ExtractClassesOrquidea], vindo da classe [FileHeader] anterior.
		-----> insercao de todos testes da classe [FileHeader] anterior.


		-----> (fixado) a extracao do [Vector.tipoElemento], em [FileHeader].

(feito)[FileHeader][Testes]:
		 -----> (feito) testes com metodos-parametros.
		 -----> (fixado) fixar os testes reutilizados de parametros multi-argumentos.
		 -----> (fixado) os metodos estavam sem o acessor! 	

(feito)[Metodos String][Testes]:
		[funcao CutWords()]:
			-----> finalizar com todos testes.



(fixado)[Expressao][Testes]:
		(prioritario)[FALHAS em sequenciamento de testes]:
			-----> (esta sem atualizar!) VERIFICAR URGENTEMENTE se os headers estão sendo processado a cada teste, podendo daí resultar em falhas desconhecida no codigo.
			-----> os headers nao estavam sendo resestados (quanto a classes do codigo dos testes), o que levava um erro: [classeA] de um cenario anterior nao era atualzado para [classeA] seguinte.
			-----> Testes: 
						(fixado) a expressao chamada de metodo nao estatica: um codigo "estranho", em [UtileTokens.FindMehtodCompatible()], estava retirando metodos se nao fossem do escopo global!
						(fixado, mas): parametros multi-argumentos como [Vector] com tipo definido, o teste passou, mas com [Vector][com tipo object (indo da instaciacao de wrapper object a rigor),
						o teste falhou.
									----> (fixar) wrapper data object com notação rigor, não está setando o tipo elemento!.
									----> (codificar) verificando, a notação rigor foi apagada, numa das modificações de [WrapperDataVector.Create]!
									estava funcionando porque instanciou o vector como uma propriedade/parametro normal.
			-----> O ultimo teste a fixar: e surgiu uma lacuna: mas instaciacao de objetos wrapper parametros deveria ter o tipo do elemento.
						----> o tipo de elemento Vector tinha previsão! Checar os [FileHeaders].
			-----> (fixado) a extracao do [Vector.tipoElemento], em [FileHeader].
									----> (fixado) DictionaryText.tipoElemento, Vector.tipoElemento.
									
			-----> (fixado) JaggedArray.tipoElemento, Matriz.tipoElemento.

			-----> (fixado) A extração de tokens de metodo, nao está sendo feita, com operadores [{,}] no DictionaryText.
									----> falha justamente com operadores: {, }, nao reconhece como metodo com estes operadores.
									----> (fixar) o wrapper object está reconhecendo com object, quando a situação é de um metodo sem tipo de retorno! 
									----> (fixado) codigo antigo no [WrapperDictionaryText] estava causando o erro a fixar.

			-----> (fixado) falha na determinacao de 1 parametro multi-argumento.
									----> depois de fixar, ficou melhor, pois um erro de setar um parametro multi-agrumento para um WrapperObject foi fixado tb.



[ExpressaoGrupos][Testes]:
			----> inserir o codigo de reinicialização de Expressao.headers=null, como em [Expressao][Testes].
		

[Expressao][Testes]:
	-----> retestar, ante a migração de [FileHeader].
	-----> (anotação) a medida de anular o Expressao.headers=null resultou em resultados esperados: nao há confusão
	de classes de testes seguidos, com o mesmo nome de classe...

[Expresssao]:
			-----> (fixado) parece mesmo que o teste de propriedades aninhadas entrou em loop infinito..
							----> isolado o codigo, em [ExpressaoGrupos.BuildAninhamento], trecho exprssParametros= Expressao.ExtraiExpressoes().
							----> o loop infinito foi fixado, porém o aninhamento está incorreto: deveria haver duas propriedades aninhadas.
							----> (fixado) falha em instanciar a propriedade de um objeto.propriedade: é sempre null, nao foi instanciado!
			-----> (fixado) a lista de operadores unarios, binarios, unarioEBinarios nao foi contruida!! 
							(fixado)---->(A MEDIDA DE reinicializar os header, está anulando tb os headers de classes base)!;
							----->  NAO há falha em [FileHeaders]!, nao está extraindo operadores de classes base!.
							-----> falha nos headers de classe base causou o erro de expressao chamada de metodo.

_________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.09:

[Expressao], [ExpressaoGrupos] [Testes]:
	-----> retestar, ante a migração de [FileHeader].
					(fixado) [PropriedadeAninhadas]:
							-----> (fixado) o teste com propriedadesAninhadas seguido de chamada de metodo. está entrando em loop infinito.
							-----> (fixado) a chamada de metodo aninhada nao está sendo construida!
					(fixado) [ChamadasDeMetodos]:
							-----> (fixado) uma chamada de metodo com parametros entre parenteses nao esta funcionando!!
					(fixado)[ChamadasDeMetodosEstaticas]:
							-----> (fixado) na funcao de obter o metodo compativel, o casting de numeros estava mal codificado.



[EvalExpression.Eval]:
	[Casting Objeto]:
	-----> (codificado) lembrar de verificar atribuicao de Objeto, tem que ser no Objeto, e nao no valor do Objeto! Com isso, sera possivel fazer: Vector v1=ExpressaoChamadaDeMetodo(), de utilidade sem par, ou impar..
							-----> (feito) cada wrapper object faz a conversao do campo valor para o objeto wrapper.
				-----> (fixado parcialmente)  a copia de valor nao está sendo repassada para o objeto a atribuir!!
							-----> (feito) VAI SER PRECISO UM CASTING ENTRE OBJETOS, engessando os tipos.
										-----> o casting se falhar retorna o valor do objeto, sem comprometer.
										-----> (fixado) está copiando os valores para o campo valor!

				----> (feito) aplicar o mesmo resultado para todos WrapperData object.

				-----> para deixar um codigo mais claro e facil de manter e extender, foi codificado em cada Wrapper um casting entre um object e um WrapperDataObject;
							-----> ficar mais facil de extender, já que a extensão tem que conter os metodos de conversao object--->wrapper.


				-----> estudo para uma factory de Objetos Wrapper para conversao. Do jeito que está é dificil extender o codigo de wrapper objects;
				-----> (A FAZER) codificado, implementar em Objeto esta factory.
	
	




___________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.09:

[EvalExpression][Testes]:
	-----> (fixar) modificações no codigo quebrou o codigo de EvalExpression.Eval()!
			----> [string.Split]: codigo de setElement nao está funcionando!
					----> (verificado) falha em outro trecho de codigo: nao tem a haver com atribuir valor a objeto, que foi a questao do dia.
					----> (fixado)(verificado, o objeto caller está com valor null) falha no objeto caller de uma expressao chamada de metodo.
									-----> (fixado) falha no setar um valor para objeto caller. voltou-se a [ExpressaoGrupos].
												-----> (fixado) confusão: entre o objeto caller e o valor de objeto caller: o valor do objeto caller é igual ao objeto caller.

			-----> (feito, mas acrescer mais tipos) tem que criar uma factory de objetos!
			-----> (fixado) em algum trecho do codigo, o valor do objeto simulado perde seu valor, e é setado para o próprio objeto.
									-----> (fixado) o valor é alterado antes de sair do processamento da expressao chamada de metodo estática!
									-----> mas continua a falha de chamada de metodos.

			-----> FALHA DESCONHECIDA ESTÁ IMPEDINDO O CORRETO FUNCIONAMENTO do metodo Invoke; ja foi visto os parametros, o objeto destino, todos
			tipos, inclusive de retorno.
									-----> o curioso é que um metodo SetElement anterior, foi executado sem falhas.

			-----> indo para cenario de teste diferente, 1o. teste validou, mas 2o. teste houve falha: os parametros nao estavam corretamente setados.
									----> (constatacao) BOAS E MAS NOTICIAS:  chamada sem a inclusao do object caller, há falha;
									MAS a forma classica, com [string.funcao()], está funcionando.
													-----> (fixado) porque com o objeto caller incluso, há falha? (o objeto caller estava sem o valor correto!);
													-----> fixado para chamadas estaticas e nao estaticas!
													
			-----> (fixado) FIXAR, DEFINITIVAMENTE, a avaliação de expressoes chamadas de metodo com o objeto caller como 1o. parametro.
			Não está gerando exceção, mas os resultados nao e invalidado!
									-----> codigo para obter o valor do objeto caller, não afetou os resultados.
									-----> o objeto caller perdeu seu valor! 
													----> o valor do objeto caller da chamada de metodo, é o valor do objeto currente.

			-----> inserir em cada teste onde há compilador, o codigo de reset dos headers, funcionou!


(a fixar quando fixar o ProcessadorID (compilador))[EvalExpression][Testes][ParametrosMulti-argumentos]:
			----> (fixar): teste está falhando.
									-----> está falhando porque nao está havendo compilação das instruções do método! Resolver
									quando fixar o compilador, que nao está construindo as instruções orquidea, corretamente..


(fixado)[EvalExpression][Testes][CutWords funcao]:
			-----> fixar cenarios de teste: multi-argumentos, split.
									-----> (fixado) teste multi-argumentos NAO FALHOU, porque há um Casting em FindMethodCompatible
									que converte numeros de acordo com os parametros do metodo.
									-----> (fixado) teste split: o vetor de texto separador não está sendo setado corretamente!
									-----> (fixado) OS VALORES APOS O METODO SER EXECUTADO, NAO É REPASSADO PARA OS OBJETOS DO ESCOPO!
													----> o valor de caller do metodo set element é o vector resultante de SetElement!
			-----> o problema do teste nao está no teste, mas na funcao split [CutWords]! Não está funcionando corretamente.
									-----> no teste de funcoes string, a funcao cutwords funciona, mas no teste de eval, nao funciona!
									A diferença? Na funcoes string, os textos nao estavam removendo as aspas, e no teste eval expression,
									havia aspas, que nao estavam sendo removidas na funcao [CutWords]!.





(feito, na extracao de instrucoes de corpo de metodos)[ProcessaddorDeIDS][Testes]:
			-----> compilacao nao esta retornando nenhum dos metodos! ou propriedades!
									-----> (fixado) falha sabe na onde? No novo [FileHeader]!, nao está extraindo os tokens do corpo do metodo!
									-----> (fixado) (Regressao para testes de FileHeader): isolado o problema: os tokens nao estao sendo extraidos!!
									-----> a sintaxe clara desta classe permitiu a instanciacao de um extrator de tokens dos metodos.

			-----> (feito) construir as instrucoes do corpo do metodo, instanciando um [ProcessadorIDs] para compilar as instruções orquidea do metodo...
									-----> o curioso é que isto foi uma das primeiras implementacoes de classes, e que se perdeu ante modificações no codigo do [ExtratorOO].



____________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.09;

(feito)[Implementacao de acesso ao escopo do metodo, quando em ExecuteAMethod].
	----> incorporado a funcao [Metodo.ExecuteAMethod], sem danos colaterais, testes feitos para obter o escopo de um metodo, feito.

(feito sem danos colaterais)[Sem prioridade]: incluir nos metodos compativeis, classes e interfaces de heranca, tornando mais flexivel e certo a lista de metdos compativeis, do jeito que
está, aceita apenas onde a classe é a classe com o metodo...

(codificado)[Sem prioridade]: implementar em [UtilsTokens.FindMethodCompatible], a verificacao de um parametro-metodo.
			-----> lembrar que o parameetro-metodo tem que ser incluido no escopo currente.			

(feito)[EvalExpression][Testes]:
	----> criar testes de casting entre [Matriz],[JaggedArray],[DictionaryText], com expressao "wrapper1= wrapper2"; 
			-----> a importancia de se testar todo o codigo: em JaggedArray.Casting(), nao estava obtendo os valores do object do casting.

[ProgramaVM][Testes]:
		-----> codificar testes com algoritmos inteiros em [ProgramVM], em arquivo texto de entrada, ou não, e observar os resultados.
						-----> compilador nao está reconhecendo a instrução [create()]!.
						-----> falha no compilado, match sequencias: a expressao regex nao está correta!
						-----> modificações no codigo quebrou o compilador! Esta foi uma das primeiras implementacoes de match sequencias.
									---->(fixado)  é certeza que o operador [=], está sendo tratado como [id] em regex, entao falha
									porque os tokens do tratador contem [=], mas deveria conter [id]...  tanto é que
									na sequencia de atribuicao, é reconhecida como id id id exprss, e nao id id = exprss!
									----> (feito) cuidar para a ordenacao coloque 1o que o codigo de atribuicao.
									----> (fixado) esta falha foi porque se incluiu o operador [=] como [id].
												---->(feito) o codigo de obter operadores foi modificado! incluiu-se agora o operador [=].

		-----> Vários cenarios de testes, passaram! Mas... Prompt do "hello, world", foi escrito na tela..
						----> (fixar) a instrucao [Atribuicao], está com expressoes setadas erroneamente. 
									----> expressao Atribuicao totalmente equivocado!.
									----> regressão para testes da classe do compilador.
												----> (fixado) comprovado, a instrucao [Atribuicao] está quebrada! A expressao de retorno é de apenas o valor do objeto.
																-----> (função declarativa de flags, nao está setando uma expressao de cabecalho) uma funcao de setar o cabecalho da expressao está quebrada!
																			----> todas funcoes de instrucao que utilizam a funcao declarativa, revistas.

						----> a verdade é que a instrucao [Atribuicao] está precisando de uma refatorada..

_________________________________________________________________________________________________________________________________________________
Daily Scrum 14.09
:
[Instrucao][InstrucaoAtribuicao]:	
		----> refatorar a instrucao Atribuicao: está com um codigo dificil de ler, e com muitas potencial falhas.
						-----> (nao esta falhando) está falhando porque o escopo currente nao é o escopo da classe do objeto! Se fosse, o objeto do cenario seria != null, e o processamento 
						seria normal.
										-----> (A FAZER EM [Escopo]): resolução com a criação de uma variavel na classe Escopo, contendo o nome da classe currente que se está processando.
										Escopo.classeCurrente= nomeDaClasseEmProcesso. então, se não houver tipo definido, verificar na classe currente se 
										a propriedade da instrução de atribuição está instanciada.
										-----> (A FAZER NO COMPILADOR) é uma extensão de atribuição não mapeada! caso em que não há tipo definido na variavel, justamente porque é uma
										atribuição de uma propriedade, dentro da classe...


						----->(feito)  a refatoracao é clara: 1- verificar se é objeto individual/ propriedade aninhada, avaliar a função de atribuição (se houver),
						e então setar no escopo currente a variavel com o novo valor...
										-----> não há necessidade de flags de [eh_definicao], [eh_modificacao], é sempre [eh_modificacao],
										porque as variaveis são sempre criadas em tempo de compilação, neste projeto de linguagens...
										-----> e se a variavel tiver valor null, setar para o novo valor, sem pestanejar..

						-----> (fixado) Instrucao [Atribuicao] funcionando, porém no programa VM executado, nao houve atribuicao na propriedade;
						mas a propriedade está listada no escopo, o que é bom.


[ProcessamentoInstrucoes][Teste]:
		----> continuar os testes de programas VM.

				----> fixar no cenarios: 
				        (fixado) [casesOfUse]: casa resultado do caso de uso vem com entre parenteses, que nao estava sendo retirado,
						resultando num nome de objeto incorreto. falha no compilador, nao no programa VM.

						(fixado)[if/else]: havia um caso a mais: o de tipos base, que nao sao objeto, ou propriedade aninhada! criou-se uma
								   funcionalidade para este caso, e setando o valor, validou.


						(fixado)[while] entrou em loop infinito;


						(fixado, setando os headers=null, para compor com a classe criada no teste)[create]:
							(fixado) instrucao create estava clonando o objeto [Escopo]! os valores nao eram repassados ao escopo currente.			
							(fixado): a instrucao atribuicao nao está prevendo o caso de propriedade sem tipo!, pois já foi instanciada!
											-----> o curioso é que foi constatado que haveria este caso, e que precisaria
											do escopo da classe, mas por outra razão...



						(fixar)[for]:
								(fixar): o codigo de extracao de expressoes, tanto [Expressao], quanto [ExpressaoGrupos], quebrou!
								[Expressao.ExtraiExpressoes]:
											-----> (fixado) modificacoes no codigo quebrou o codigo de [Expressao.ExtraExpressoes]!
								(A FAZER) [ProcessadorIDs][instrucao for]:
											------> é preciso criar uma expressao para o valor inicial da variavel de malha, do
											jeito que está, apenas valores de numero constante, está sendo validado.
											------> instrucao [for] tem previsão para uma expressao no valor inicial da variavel de malha.

								[Instrucao][InstrucaoFor];
											------> (fixado) break da malha um contador a frente.






(verificado)[Expression.headers=null]:
				----> (NAO, NAO ESTA HAVENDO PROCESSAMENTO EXTRA) verificar se está havendo processamento extra quando se inicializa os headers: está demorando muito os testes..


___________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.09:


Resumo do Projeto:
		-----> apos testes unitarios em massa de [Instrucao], prosseguir com eventuais bibliotecas sem importacao, como acesso a arquivos...


(nao eh preciso) [ProcessadorIDs][instrucao for]:
				------> é preciso criar uma expressao para o valor inicial da variavel de malha, do
				jeito que está, apenas valores de numero constante, está sendo validado.
				------> instrucao [for] tem previsão para uma expressao no valor inicial da variavel de malha.
				-----> nao é preciso porque se extrai as expressoes da instrucao, incluindo a expressao de atribuicao da variavel de malha.



[Instrucao][Testes]:
				----->testes unitarios em massa, para cada tipo de instrucao, pode haver lacunas de funcionalidades nao previstas...
				----->(fixado) instrucao [for] falha quando o numero é negativo no valor da variavel da malha!
								-----> (fixado com utilizacao de uma expressao container)o problema está na constituicao do valor com operador -, ou seja, numero negativo.
								-----> (fixado) falha na funcao [Expressao.PosOrdem()]!
										-----> está retornando o valor negativo esperado.
								-----> (fixado, mais um caso de uso: valores de Objeto tem que retornar objeto.valor, se for objeto, na atribicao) a avaliação de variaveis negativas está quebrada.
				-----> (feito) instrucao [casesOfUse], testes unitarios.

				-----> (fixar) instrucao [create()], falha em testes unitarios que instanciam a propriedade em questão com valores do parametro do construtor.
								------> (codificado) o escopo do metodo construtor nao contem os objetos parametros....
								------> (FIXAR) fixar em metodo.construtor, o escopo.
											----> (fixado) o metodo construtor não está processando os parâmetros! teria que estar no escopo,
											os parametros, porém nao está havendo passagem dos parametros...
											----> os valores nao estao sendo repassados!
											----> (fixado) a instanciacao do objeto caller.
											----> (fixado) o metodo [Metodo.ExecuteAMethod] nao está setando corretamente os valores do construtor.
								------> falha na construcao da instrucao [Atribuicao]: a expressao de valor da atribuicao nao esta bem construido. 

(fixado)[ExpressaoGrupos][ExpressaoOperador]: (ExpressaoOperador continuará com varias sub-expressoes, incluindo expressao operador, e operandos);
				-----> vai ter que encapsular a [ExpressaoOperador] com uma expressao container, para avaliacao em eval, que processa o elemento[0] da expressao.
				-----> falha grave, as expressoes com operadores nao funciona em eval expression: ou encapsula em [ExpressaoGrupos],
				e refaz todos testes, ou modifica [EvalExpression.Eval()], para calculo nao a partir do Elemento[0],
				quando tiver uma expressao operador...
				-----> alteração em [EvalExpression.Eval()], nao afeta a instanciacao de Expressao, ExpressaoGrupos,
				interessante porque uma funcionalidade é acrescentada, com um codigo adicional, sem afetar outras funcionalidades..



(fixado)[ProcessadorIDs]: verificar se os handlers não forem estaticos, está demorando para compilar a cada compilacao.
				-----> verificado, todos tratadores sao recalculados toda vez que se compila, apesar de estarem numa lista estática, porém no compilador havia uma instrucao
				que esvaziava a lista de tratadores, resultando em perda de desempenho, e muito....
				-----> aumentou em muito o desempenho do compilador! Se compilar so uma vez, nao se percebe, mas 5,6 compilacoes, a lista inteira de tratadores e sequencias id eram instanciadas novamente...


(fixado)[Instrucao.Atribuicao][InstrucaoCreate][Testes]:
				-----> (fixado) fixar a expressao de atribuicao. É uma funcionalidade nova, antes somente havia um calculo de numero constante...
								-----> (fixado) nao da para instanciar a expressao de atribuicao, quando na formacao da instrucao. Terá que ser feito na execucao da instrucao, no programa VM, [Instrucao.Atribuicao].
				-----> aparentemente, a instanciacao da expressao de atribuicao nao afetou o codigo de outras instrucoes testadas.

_________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.09:

(feito)[ProgramaVM][Testes]:
				-----> continuar os testes unitarios para outras instrucoes.
						-----> instrucoes com testes unitarios:
									-----> [for], [casesofUse], [create], [while], [if/else];
													-----> (fixado): instrucao [if] está com os 2 blocos iguais!

									-----> demais testes nao precisam de testes unitarios em massa.

						-----> (fixado) (instrucao [while]: testes falhou em sem entrar na malha, e em decremento negativo);
									-----> (fixado) testes com numeros negativos, comparacao >, >=, sem entrar na malha.

[Instrucao.InstrucaoCreate]:
				------> (fica como está) refatorar a instrucao [InstrucaoCreate]: está com muito codigo obscuro, com retirada de objetos no escopo do construtor..



[Planejamento][sem prioridade]:	

	-----> (feito) biblioteca [Arquivos]: (uma pequena biblioteca de le/grava textos/bytes, tudo de uma vez só).
	-----> (constatacao) é possivel com a instrucao [Importer], formar qualquer biblioteca escrita na linguagem base, C sharp, e utilizar como uma biblioteca!;
	é só ter cuidado em nao utilizar listas [List], mas [Vector], para a construcao das bibliotecas importadas..

[ProgramaVM][Testes]:
				-----> escrever pequenos programas, utilizando codigo estruturado, e classes da linguagem orquidea, e validar os testes.
							-----> (fixado) fixar urgentemente a atribuicao com valor de objeto resultante de uma retorno de um metodo.
											-----> as chamadas de metodo não foram testadas com retorno de valor!
							-----> (fixado) compilador nao está nem processando a instanciacao do objeto do teste!!
							-----> (fixado) o compilador nao está reconhecendo a chamada de metodo!
											-----> fixar o processamento da chamada de metodo, nao está com o valor esperado.
							-----> (nao necessario) verificar as expressoes de atribuicao em [ExpressaoGrupos], creio que não há caso previsto para atribuicao com chamada de metodos!
							-----> (fixado) FALHA DESCONHECIDA ESTÁ IMPEDINDO DE RECONHECER a expressao chamada de metodo como expressao de atribuicao com chamada de metodo!
											-----> instrucao legado, fazendo atribuicao erroneamente.

							-----> (fixado) instrucao [Atribuicao].
											-----> (fixar) a expressao de atribuicao na instrucao [Atribuicao] é somente para um token de elemento, como um numero.
															----> falha na avaliacao de uma expressao de atribuicao, em [EvalExpression.Eval()].
																			----> a falha está numa expressao chamada de metodo. Falha na construcao do escop do metodo.
																			----> os escopos estão corretos, mas um detalhe: o valor nao eh o esperado.
															----> o programa está funcionando, porém o valor esperado nao foi alcançado..
																			-----> escopos em ordem: porem os resultados nao sao os esperados.
															-----> está muito lento: uma chamada de metodo está muito lenta!

				-----> (fixado) a expressao de atribuicao estava erroneamente construida: o valor da atribuicao foi confundido com toda a expressao de atribuicao.
											-----> apesar da atribuicao ser refeito, o valor nao foi o esperado..
											-----> (fixar) modificacoes para obter o valor correto, porem não resultou...
							----> isolado o problema: a instrução [return] nao está sendo processado! por isso, o resultado final do metodo nao retorna o valor final apos o laço [for]...




___________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.09:
				
[ProcessadorIDa] (compilador):
-----> (fixado) fixar a compilação da instrução [return]. a ordenação das sequencias id não está correto...
			----> verificando o file header, a instrução return no corpo do metodo está lá.
			----> a falha está na compilação, ou seja, em [ProcessadodrIDs];
					----> (anotação) TODAS INSTRUÇÕES DEVEM TERMINAR COM ponto-e-virgula, mesmo fim de bloco! Cuidando disso, a instrucao return foi compilada, resultando
							num valor esperado.

					----> (fixado, programa fatorial). 
					----> (fixado, programa contagens).
							-----> nao esquecer em cada teste de um programa inteiro, RESETAR os headers de [Expressao.headers], os testes fixados nao estavam
											validando nao pelo codigo mas porque AS CLASSES dos programas TINHAM NOMES IGUAIS!

			----> programa leNomes:
					----> chamada de metodo sem parametros nao é reconhecido.
								-----> erro no processamento de sequencia: está retornando um mapeamento incorreto..
												-----> falha na ordenação de sequencias. por quê? porque o operador [.] (dot) nao
												entra como operador com escape em expressoes regex, causando uma construcao incorreto de pathern resumido...
												-----> tentativa de fixar o operador [.] em pattern regex, falhou.
												-----> testes com Wrapper Data Matriz falharam.
								-----> nao da para entender: no teste em [TextExpression], validou,
								porem nao no teste em [Instrucao][Testes].

					(feito)[ProcessadorIDs](tratadores):
								----> (fixado) fixar a instrucao ChamadaDeMetodo, sem parametros, pois com parametros está reconhecendo. Tinha que
										ter um ponto e virgula no mapeamento de pattern resumed.
______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.09:

(feito) [Instrucao][Programa leNome]: 
	----> (feito) Extrair os caracteres aspas da string de escrita, [Prompt.sWrite()].
	----> (fixado) (um caso de [id] nao previsto! literais que contem [aspas] são tb [id], fixando, o processamento de instrucoes retornou os valores esperados).
	----> (fixado) Verificar o processamento de uma literal constante + variavel string, na composicao de texto escrito [Prompt.sWrite()].
							----> (esta correto quanto a isso) testes de expressao, constante literal + variavel string validou.
							----> (regredido) tentativa de obter um objeto literal, quebrou o codigo, precisando regredir a situação anterior. 
							----> (fixado) o codigo está correto quanto a formacao da expressao: literalText+ variavelString,
							mas está perdendo a literalText como parametro...
										----> mais um caso sem previsao! literal text especificada em [Elementos[0]],
										e nao na expressao principal, como previsto anteriormente...



																

(feito)(Implementacao)[Expression.header]:
			-----> insight! em vez de anular o [Expression.headers]=null, fazer uma mudança de classe de mesmos nomes,
			mas de cenarios/programas diferentes! [Expression.InitHeaders()] deve ser modificado para esta nova funcionalidade...
								----> aguardando testes sem Expressao.headers=null, e com breakPoint sem [Expressao.InitHeaders()],
								para verificar se o codigo que remove classes antigas com mesmo nomes das classes currentes, 
								está funcionando.
					---- PORQUE É INTERESSANTE RETIRAR [Expression.headers=null]: SE ESQUECER DE COLOCAR ESTA EXPRESSAO, e rodar uma sequencia de programas,
					gera erro, porque classes de MESMO NOME anterior, e currente, falha, pois está com as CLASSES DE MESMO NOME anterior...


			-----> (feito): testes sem [Expression.headers=null] E BREAK POINT em [Expressao.InitHeaders()]..
								-----> testes sem [Expresion.headers=null], em [ExpressaoGrupos], [Expressao], validou.



(feito)[Expressao][Testes]:
			---->(fixado) FIXAR em [Expressao], os testes com codigo de testes de [Matriz] e [DictionaryText].
								-----> (feito) testes com [DictionaryText] desatualizado; 
								-----> (fixado) testes com Matriz.GetElement, Matriz.SetElement, Matriz.Create, falha de natureza desconhecido.
											-----> ExpressaoGrupos.ExtraiMultipasExpressoesIndependentes() está processando uma expressao de um token vírgula!!!
															----> (fixado) falha no trecho de codigo onde processa [,] e pilhaDeParenteses == 0.
																		----> (fixado) está extraindo as chamadas de metodo GetElement,SetElement, mas 
																		quando se valida parametros, gera o erro.
															-----> a importancia de testes unitarios em massa: apenas em [Matriz] tem 2 parametros de GetElement,SetElement,
															e o metodo [ExpressaoGrupos.ExtraiMultipasExpressoesIndependentes()] tinha falha com parametros separados por virgula,
															mas o caso base conta com expressoes de parametros...
_________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.09:

(feito)[ExpressaoGrupos]:
		-----> modificação para simplificar e extender com Vectors feito de Objetos, podendo (A FAZER) acessar propriedades do Objeto, na anotação wrapper, p.ex.: v[1].X=5;
		[tornar o codigo menor, simplificar, e extender para objetos com propriedades aninhadas, inclusive com wrapper objects]:
		-----> [ExpressaoGrupos] modificacao no codigo, objetivo: eliminar codigo duplicado, de objetos não estaticos e objetos estaticos: é possivel
			unificar o codigo de propriedades/chamadas de metodos, de OBJETOS NAO ESTATICOS, e NAO ESTATICOS;
								-----> codificado.
								-----> testes, chamada de metodo estatico, chama de metodo nao estatico, propriedades aninhadas nao estatico, feito.
								-----> (fixado) nos testes de atribicao de propriedades aninnhadas.
								-----> (fixado) nos testes [TestesExpressaoAtribuicao].	
								-----> (fixado) a extração de operadores.
								-----> (fixado) o processo de atribuicao de expressoes de objetos sem operador dot.
								-----> (fixado) (FIXAR URGENTEMENTE) o processamento de chamada de metodo, e propriedades aninhadas.				
(feito)[Expressao][Testes]:
		------> testes, ante a modificacao no codigo de [ExpressaoGrupos]:
								-----> (fixado) processamento de metodos wrapper: GetElement,SetElement, de wrapper object Matriz.

(feito)[InstrucaoCreate]:
		----> (duplicacao em outro trecho de codigo, VERIFICAR) esta instrucao está duplicando objeto! verificar se o objeto já existe, e se existir, eliminar o objeto anterior, e setar como o objeto atual.
								-----> trecho obscuro de InstrucaoCreate estava duplicando objetos, em vez de atualizar o valor dos objetos em questão.
								

[Instrucao][Testes]:
	-----> (codificado): pequeno programa utilizando recursao! um algoritmo de fatorial recursivo é uma boa opção.
								-----> (fixado por enquanto) falha na construcao da expressao [n*fx(n-1)], tentando colocar a chamada da funcao recursiva em uma variavel, entao depois fazer o calculo do fatorial.
								-----> (fixar) falha de natureza desconhecida, está impedidindo de retornar um valor inteiro, esta fazendo o parametro como uma string...
												-----> (fixar) falha na recursao, trecho de codigo modificado para nao recursivo, validou.
															-----> (fixado) problemas na avaliação de instrucoes em [InstrucaoBloco], estava retornando
															antes de calcular a instrucao de return!
															-----> (fixado) falha na instrucao if/else nao está obtendo os tokens dos blocos if/else.
																			----> problema serio, os blocos if/else nao podem conter operador [;] entre os blocos.


															------> (FIXAR URGENTEMENTE) a chamada [fatorial(n-1)], nao está sendo construida. na instrucao de Atribuicao,
															a expressao está com os tokens corretos, mas é claro, a funcao esta sem um objeto caller!
																			 ----> obter nome da classe currente está setada, mas desaparece quando tratado na sequencia.
																			 ----> a sequencia de atribuicao com FUNCAO COM PARAMETROS NAO ESTAVA MAPEADA!

															-----> (fixado com o mapeamento) está quebrando porque está tentando fazer uma operacao multiplicação com um dos operandos nullo.

	
	----> (A FAZER) parada, verificar a chamada de funcao, se está obtendo tratador (handler), e está obtendo a expressao correta!.	
				-----> acertar a funcao [ProcessadorIDs.InitMapeamento], para os casos nao tratados: 
								----> rgx_chamadaAFuncaoComAtribuicaoComParametros = "id id =  id ( exprss";
								----> rgx_chamadaAFuncaoComAtribuicaoComParametrosSemInicializacao = "id =  id ( exprss";
											----> ja ha [ChamadaDeMetodoComAtribuicao], fazer semelhante para [FuncaoComAtribuicao], abrangendo os 2 casos acima..






____________________________________________________________________________________________________________________________________________________________________________________________________________			
Daily Scrum 22.09:

[ProcessadorIDs][handlerChamadaDeMetodo]:
				-----> (codificado) acrescido mais 2 casos de sequencia.
				-----> (fixado) parte de codigo nao testada, mas com falha, em determinar a lista de funcoes compativeis.
								-----> parte do codigo fixada, porem resultou num problema: as classes nao foram completamente
								construidas ainda! nao a parte dos metodos:
											-----> (codificado) alem de serem compiladas depois, os corpos dos metodos
											também teriam que ser compiladas novamente pois ha instrucoes com chamada de funcao
											possivelmente dentro dos metodos.
											------> (codificado) inserir em [ExpressaoGrupos], o processamento
											para a expressao com funcoes compiladas depois.

								------> (fixar) o codigo que recompila os metodos está entrando em loop-infinito!!!											
										
											
[ExpressaoGrupos], [ExtratoresOO]:
		------> sobre chamadas de funcao:
						-------> (codificado) NAO É PRECISO MALABARISMO, basta ANTES adicionar o metodo de classe, e DEPOIS
														contruir todos corpo de metodo. Assim, é possivel a funcao [UtilTokens.FindMethodCompatible()]
														encontra metodos ANTES de chamar o handler de [ExpressaoGrupos] de processo
														de extração de chamadas de função.
																	-----> (feito) retirar a variavel booleana Classe.isBuild, setar o registro
																	e depois de processo de todos metodos, construir os corpo dos metodo.
																	-----> (feito) retirar a trava de chamada de funcao, relativo a verificação
																	e tratamento posterior de chamadas de funcao.
																	-----> (feito) retirar as variaveis de Classe.funcaoCompiladaDepois e
																	Classe.parametrosFuncaoCompilarDepois, não é preciso mais.



___________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.09:


(feito)[ExpressaoGrupos], [ExtratoresOO]:
		-----> (fixado) testes em [ProcessadorIDs], se registrou uma chamada de metodo na classe teste.

(fixado)[FileHeader]:
			-----> está lançando exception sabe por que? Na classe FileHeader, que deveria processar somente classes,
			está também processando instrucoes fora da classe, apenas porque nao foi projetado para instrucoes fora da classe.



(feito)[Objeto]:
		-----> factory de objeto mais robusta, obtem objetos  a partir de chamadas de um construtor sem parametros.


		

(fixado)[FileHeader]:
		-----> levar em conta que um arquivo de programa contem nao apenas classes, mas instrucoes sem classe, que está entrando como codigo na ultima classe do programa!
		[FileHeader] foi projetado para processamento de classes, mas com a utilizacao de processamento de codigo em um arquivo, há instrucoes solto, fora de classes..


[Instrucao][ProgramaFatorialRecursivo]:
		-----> a compilacao está atingindo a chamada de metodo, porem nao está sendo construido.
							-----> fixado com o nome da classe currente setado para uma variavel estatica. 
							-----> fixado o processamento duplo de chamadas de funcoes, em [ExpressaoGrupos].
							-----> (FIXAR) chamada de funcao construida, aparentemente o parametro [n-1] nao está sendo processado!
												----> chamada de funcao sendo executado.
												----> (fixado temporariamente) escopo de bloco nao repassa os objetos, para o escopo do metodo!
																----> (para FIXAR definitivamente) falha desconhecido está impedindo de repassar variaveis construido no escopo do bloco.
												-----> (fixado, funcao insert nao atingia o ulltimo elemento da lista) nao está sendo construido corretamente a chamada de metodo [fatorial(n-1)], o parametro está como [n-], deveria ser  [n-1].
												-----> parametro (n-1) setado corretamente.
												
												
												-----> (fixado) VERIFICAR URGENTEMENTE a expressao return, se o valor de x está sendo além do escopo do metodo.
																----> a contagem de tokens não está chegando ao ultimo bloco do if/else!
																como resultado, a instrucao return do else é processado, e acrescentado como instrucao, antes de if/else.
														
												-----> (fixado) a duplicação de objetos parametros.
												-----> (fixado) OS VALORES DOS PARAMETROS NAO DEVEM SER REPASSADOS AO ESCOPO CURRENTE! x*fatorial(x-1) está retornando 1, mas x=2, contudo sair da recursao, x=1, resultando 1*1=1...
																-----> (fixado) falha DESCONHECIDO ESTÁ ADICIONANDO OBJETOS AO ESCOPO CURRENTE.
																-----> modificação para proteçao do escopo currente, com clone().

												-----> (fixar) ehhhh, parece que o problema está na recursão.

												-----> (FIXAR) expressao estatica de atribuicao não está sendo construida!
																-----> objeto estatico chamado sem expressao valido..
																			----> modificacao em [ExpressaoGrupos], para 
																			chamadas estaticas.
[EvalExpression]:
				-----> modificações simplificado na avaliação de chamadas de metodo, o metodo anterior economizava linhas de codigo,
				mas perdia detalhe de cada tipo de chamada. fica mais explicitos tb o empilhamento dos resultados.


					----> outros programas validaram.

__________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.09:

(feito)[Instrucao][ProgramaFatorialRecursivo]:
						-----> (fixado) modificações em [ExpressaoGrupos], validou em parte: objetos estáticos de funções nao validou.
												-----> (fixado) funcao, nao metodo, fixar.
												-----> (fixado) expressao da recursao está bem-formada, porém quando chega em expressao chamada de metodo, recursivo, retorna null.
																	----> o que dizer? 

(feito)[Instrucao][ProgramaNumeroParOuImpar]:
						-----> (fixado) nao havia operador [int] [%]: implementado.
						-----> teste executado.



(constatado)[EvalExpression]:
		-----> (ainda é preciso) nao eh preciso o casting de objetos! Basta setar o valor do Objeto em uma atribuição! Evita o casting dentro da classe Objeto.





(feito)[sem prioridade][UtilTokens.FindMethodCompatible()]:
		------> testar o caso de um metodo parametro.
		------> verificado o processo de parametros property, em [FileHeader]. 
					-----> no metodo parametro, nao conta o nome da funcao, mas a interface de parametros, e o tipo de retorno do metodo.



[ExpressaoGrupos]:
		------> fixar testes de [TesteExpressaoChamadaDeMetodo].
		------> um corte no codigo do compilador, desnecessário este código, aumentou e muito o desempenho do [ProcessadorID].


(fixado)[FileHeader]:
		-----> certo, para testes com mais de 1 classe, está falhando. Nos testes de FileHeader, não houve previsão 
		de mais de 1 classe a processo!
		-----> regressão para testes [FileHeader]: o codigo estava desatualizado! a extração de tokens da classe
		recortava precisamente os tokens de uma classe, não precisando de offset, que estava causando a falha...



(PARA UMA FUTURA MANUTENÇÃO):
		-------> Extender agora para objetos wrapper como objetos possiveis de acessar propriedades de um Objeto, como v[1].X=5;
							----> é possível acessar/adicionar propriedades, em todos Wrapper Objects! Estes objeto
							herdam de [Objeto], sendo possível incluir/acessar propriedades... só precisa
							de uma anotação wrapper de Get/Set propriedades, compor com operador de objetos dot (.)...

___________________________________________________________________________________________________________________________________________
Daily Scrum 27.09:

(feito)[FileHeader]:
		------> (fixado) fixar testes com mais de 1 classe que falharam.
					-----> testes com 4 classes, falhou a ultima classe, e o curioso é que compila com 3 classes.
(feito)[Expressao],[ExpressaoGrupos]:
		------> [Expressao]: testes que falhou
					-----> teste: (fixado) [TesteExpressaoOperadorVariosOperadores]. é o teste com quatro classes, testada em FileHeader e falhou.
		------> [ExpressaoGrupos]: (fixado) [TesteExtracaoExpressoes]

[EvalExpression][Testes]:
		------> varios testes falharam, os primeiros testes falharam.
		------> regressao para [ExpressaoGrupos], a expressao do teste em [EvalExpression], não estava corretamente construida.
					-----> (fixado) objetos wrapper, apenas o nome, nao estava sendo processado, pois ja estava feito,
					precisando apenas instanciar uma expressao objeto, e adicionar a lista de sub-expressoes.
					-----> (fixado) fixar o metodo [UtilTokens.FindMethodCompatible].
								----> um sub-tipo de funcionalidade, quando a classe estática é string, ou double,
								não estava processando corretamente: se não era para incluir o 1o. parametro como parametro de função,
								parava a malha e retornava null, sem testar os parametros!
					-----> continua sem compilar wrappers object!

[Expressao]:
		-----> (fixado, testes em [ProcessadorIDs]) a instanciacao de wrappers object por compilação.
					-----> (planejar, codificar) confusão: em uma expressao, o wrapper object é PROCESSADO, mas em compilação,
					cai a outra categoria;
					-----> chamada de função está sendo chamada, porém com valor de retorno nao esperado.
									----> (fixar) falha no processamento de parametros.

(feito)[ProcessadorID]:
		------> implementar o processo de criação, get/set elementos de wrapper objects.
					-----> (feito) 1a. parte, instanciacao de wrapper objects, feito.
									----> implementacao com codigo ja existente, testado.
									----> teste com Vector anotação clássica: int[] vetor1[20].
					-----> (feito) 2a. parte, chamadas de metodo Get/Set Element, feito.
									-----> implementacao também com codigo ja existente, testado.
									-----> teste com Vector, SetElement.
								-----> fixado o caso em que há GetElement em uma expressao, como: [x=vetor1[5]+2];
								sendo uma expressao valida, mas expressao, processado como uma expressao, codigo já testado.

 ______________________________________________________________________________________________________________________________________________________________
 Daily Scrum 28.09:


(feito)[InstrucaoCasesOfUse]:	verificar a sintaxe correta de [casesOfUse], está incorreto em [ProcessadoIDs.Testes].
						sintaxe: casesOfUse id : ( case operador exprss ) : {} (case operador exprss): {}...
						

(feito)[ProcessadorID]:		
		-----> otimizar o codigo de sequencias wrapper, aparentemente está meio lento.


(feito)[ProcessadorIDs][Testes]:
		-----> (fixado) fixar instrução [if/else];
						-----> (fixado) falha grave, não está processando um operador ">".
										-----> mais um caso nao coberto pelo codigo: objeto como final da expressao.


[EvalExpression][Testes]:
		------> (feito) com o codigo otimizado, continuar os testes de avaliação de metodos string, double.
		------> (feito) teste de cutWords, com instanciacao via compilador, passou, e tb a expressao de setar um elemento do vetor, feito.

		[Testes][FuncoesString]:				
			-----> (fixado) testes com funcoes nao estaticas, falha.
							-----> (fixado)o codigo de tramento de insercao do primeiro parametro como objeto caller desapareceu!

________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.09:

[EvalExpression][Testes]:
			-----> fazer demais testes.
						----> fixar testes unitarios do
									-----> (fixado) [TesteAvaliacaoChamadaDeMetodo].
									-----> (fixado) [TesteAvaliacaoNumeros].
									-----> (A FAZER) [TestsVectorAtribution].
												------> vai ter que fazer com calma, por que o problema e complexo.
												o curioso eh que havia sido fixado, mas nas modificacoes posteriores para fixar outras falhas, perdeu-se a solução.
												------> no casting de Vectors, nao está sendo copiado os elementos dos vectors!

(feito)[Metodo.ExecuteAMethod()]:
			------> na inserção do primeiro parametro como objeto caller, foi retirado o calculo de avaliacao do parametro,
			inserido uma expressao objeto com o objeto caller, e inserido na lista de parametros da chamada de funcao.
			Estava mal-arquitetado, apenas a insercao do objeto caller como uma expressao, para dentro da lista de parametros,
			é que era necessário.


(feito)[EvalExpression]:
			-----> implementação de casting de referências implementada, porém 	o teste que falhou está requerendo uma
			cópia de passagem por valor.
			-----> casting com copia de valor nao se faz em outras linguagens. Melhor deixar como casting com copia por
			referencia...


(nao eh viavel)[EvalExpression][Testes]:
			-----> se houver necessidade de mais testes unitarios, criar uma funcao que recebe o codigo da expressao,
			e: 1- instancia a expressao, 2- faz a avaliacao do expressao, 3- e faz a validacao.
									-----> com esta funcao, é possivel caber muito mais testes, num cenario de testes.
______________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.10:

[Instrucao][Testes pequenos programas]:
	-----> refazer os testes.
				----> teste: (fixar) [ProgramaFactorialRecursivo] falhou.
								---->(fixar) o valor de parametro está associado incorretamente!
										-----> (fixado, mas inicializa com valor null) na criacao do objeto, está atribuindo o valor "x", uma string, deveria ser um numero!
								----> (fixado) isolado o problema: as instrucoes do bloco [else] desapareceu!.	
										----->  (fixado) confirmado a nao construcao do bloco do else.
										----->  (fixado) FIXAR URGENTEMENTE A INSTRUCAO IF/ELSE, BLOCO ELSE, que nao está registrando nenhuma instrucao deste bloco.
													------> (fixado) a instrucao [n=x;] está lançando uma exceção.
	
								----> (fixar) valor encontrado nao validou o valor esperado.
													-----> a 1a. chamada de metodo está retornando 0!!
																------> (feito) RETIRAR DO ESCOPO de Metodo, os objetos instanciado na execução do metodo: [actual], [n], 
																e repassar os valores do parametro [x], para o escopo currente.
																------> está criando um 2o. objeto [x].


								----> FALHA DESCONHECIDO ESTÁ IMPEDINDO O CORRETO PROCESSAMENTO do programa [FatorialRecursivo].
													-----> (fixado) FALHA DESCONHECIDO ESTÁ RETIRANDO OBJETOS DO ESCOPO DA FUNCAO, E ADICIONANDO AO ESCOPO DO METODO, CLONADO.


								----> (fixado) a chamada de metodo [obj.fatorial(n-1)] está retornando null, por isso a pilha de operandos tem um null como operando,
								resultando numa operacao com retorno = 0.
													-----> está retornando null, sabe por que? Porque a chamada de função recursiva está,
													por motivos desconhecido, está sem a lista de instruções!.


[Instrucao][Testes]:
			-----> (fixar) era esperado, as instrucao caseOfUse falhou, porque foi modificado o codigo devido a sintaxe correto da instrução.
			-----> (fixar) as instrucaoes [create] falharam.

[WrappersData Objects],[Objeto]:
			----->(ja foi feito) é interessante guardar uma copia object no campo Objeto.valor, de todos wrapper data,
				   para resolver os Casting, sem talvez nao especificar o tipo do objeto sob casting.
			-----> (codificado, a testar)  implementado em [EvalExpression.EvalPosOrdem()], mas no codigo de pequenos programas,
			nao foi testado ainda, o uso de wrapper object.
___________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.10:

	-----> Resumo do andamento:
						
(fixado)[Instrucao][PequenosProgramas]:						
		------> apenas o programa fatorial recursivo para validar.
					------> está ainda sem validar para x>2, porque o escopo do metodo tb perde a referência!
					------> o problema está na passagem por referência (ponteiro de memória), na instrução [Atribuicao].
					mas se acrescentar um novo objeto, como distinguir do objeto anterior?
										-----> e se para obter um objeto, obtivesse o ultimo objeto de mesmo nome? resolve
										a passagem por referência (mesmo ponteiro de memória).

		------> o que estava falhando: em executa bloco, a instrução return está sendo calculada sem retornar o valor,
		mas retirando o codigo que calculava sem retorno, o teste passou. (estava calculando a expressao return
		antes de retornar o valor, e sendo uma funcao recursiva, ia para outra chamada de metodo recursivo).





(fixar)[Instrucao][TestesCreate].
			-----> o curioso tb é que quando se escreveu estes cenarios de testes, validou tb.
			-----> (fixado) a funcao construtor nao estava repassando o valor dos parametros, para o escopo de execução da função!
			-----> (fixado) a instrucao não é atribuicao, mas setar propriedade aninhada!!! a sequencia não está PROCESSANDO o operador [.] (dot)!
										-----> confirmação: a sequencia está como atribuicao, nao está processando o operador [.];
			-----> (fixado) nao há previsão para objeto [actual], em [ExpressaoGrupos]!
	-----> FALHA DE NATUREZA PROPRIA DESCONHECIDA, ESTÁ IMPEDINDO A EXECUÇÃO DE CONSTRUTOR.
			-----> (fixar) expressao dentro do construtor está maus construido!
										-----> lista de instruções e escopo do construtor, valido.

	------> falha em obter o objeto caller de uma propridade aninhada.
										-----> utilização do objeto actual para obter valores de propriedades sem objetos caller.
										-----> problema em obter o objeto caller.
	


[EvalExpression][Testes]:											
		------> fixar o 1o. teste unitario, de funções string, em [EvalExpression.Testes].
					-------> restaurar a parte final de obter parametros, a partir de expressao objeto e expressao numero, a partir 
					de versões anteriores.
									
		------> (feito )resolver a sintaxe correto da instrução [casesOfUse].
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.10:


(feito)[ProcessadorIDs]: não estava correto o mapeamento de [id.id= id], melhor [id.id= exprss], que permite expressoes na atribuicao, e mantem o caso de atribuicao de um id.


(fixado)[Instrucao][TestesCreate]:
				------> quando se formou corretamente a instrucao [actual.propriedadeB=x], o valor esperado foi encontrado, no cenario de testes unitarios.
				------> remoção do objeto [actual], que fica dentro do escopo da classe, e nao fica no escopo do programa vm.

(fixado)[Instrucao][TestesCasesOfUse]:
			------> o curioso é que quando se escreveu os cenarios de testes, validou.
			------> (fixado) construcao dos blocos de comandos, feito incorretamente: os blocos estavam com os tokens das expressoes condicionais!
			------> (fixado): o build da instrucao [casesOfUse] estava duplicando objetos.

(fixado)[Instrucao][PequenosProgramas][Testes]:
			------> modificações no codigo quebrou os testes de [PequenosProgramas]!.
							----> claro ato de SABOTAGEM! os tratadores estão inicializados com outro handler!
										-----> fixado o ato de SABOTAGEM SIM!



(fixado)[EvalExpression][FuncoesString]:
			------> falha em compor com 1o token como o objeto caller. falha em [ExpressaoGrupos].
							-----> a falha está no [FindMethodCompatible()], em [Metodo], que está incluindo como 1o. parametro, o objeto caller,
							e em outro trecho de [Metodo], estava incluindo novamente o objeto caller como 1o. parametro.
		
__________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.10:

(feito)[Planejamento][Metodo]:
			------> considerar a possibilidade de em vez de [ExecuteAConstructor], fazer [ExecuteAMethod],
					que tem mais opções de parametros, com [wrappers object], [parametro-metodo], [parametro-multi argumento],
					[1o parametro como first caller]. um construtor também é um metodo.

(deploy no Sábado)[Projeto][Resumo]:
			------> preparar para subir o projeto no git hub.
							-----> organizar as bibliotecas, importando via [Module] instrução, ou carregando-as
							dentro da classe [LinguagemOrquidea].

_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.10:
	------> nova biblioteca de musicas/sons: Sounds.exe;
	
(A FAZER)[Library]:
		-----> verificar urgentemente o comando [Library], porque agora há classes de biblioteca além do arquivo de compilação do projeto.
		
	
EM UMA FUTURA PROXIMA MANUTENÇÃO:
			------> criar bibliotecas: imagem, de loop de game, função randomica, e o que demais for suficiente para operação válida da linguagem...
_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.10:
	-----> biblioteca para sons e musicas feito, com biblioteca RayLib-cs, versão compativel Framework .NET 4.8.1,
	
______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 30.10:
	

[ExpressaoGrupos][FUNCIONALIDADE FUNCOES-PARAMETRO]:
	
	implementação de funcões parâmetro: quase saiu de primeira: em vez do escopo da classe currente,
	tem que utilizar o escopo current (no caso um escopo de metodo), para conseguir validar funções-parâmetro!!! Se a função não estiver em uma expressão, funciona porque a handler para
	chamada de função, mas se estiver numa expressão, vai falhar...
					----> a modificação é trivial demais: em vez do escopo da classe currente, procurar nomes de função no escopo do método currente: 
					é o escopo de entrada do processo de composição de expressão, em  [ExpressaoGrupos]... E NÃO ESQUECER:  no escopoo do metodo, tem
					que ter TAMBÉM o escopo da classe do metodo, incluindo proprieadades e métodos.
	
	  			  
				  
	-----> funcionalidade inclusao de funcoes-parametro, implementado.
	-----> [UtilTokens][Testes]: 
					-----> testes com uma funcao parametro.
					-----> falha no teste: o metodoB está com as mesmas instrucoes do metodoA.
									----> em ExtratoresOO, esta com as mesmas instrucoes.
									----> a sintaxe de funcoes-parametro pode estar errado: o erro veio do [FileHeader].
													-----> os tokens dos metodos nao está sendo obtido corretamente: 
													ao mudar o metodo para 1o. metodo, fez o processamento.
													-----> regressao para [FileHeader], para fixar a obtencao
													de tokens corretamente.
																	-----> isolado o problema: alem da
																	obtencao errado de tokens de metodos,
																	o parametro seguinte ao parametro-funcao,
																	esta contabilizado incorretamente;

													----> (fixado) fixado a extração de tokens de parmetros-funcao,
													porém, nao está extraindo todos metodos, apenas o 1o. metodo,
													nao os outros 2 metodos. Agora está extraindo 2 metodos,
													mas falta o ultimo metodo: problemas de indice de tokens.
													----> agora o codigo quebrou no processamento de parametros multi-argumento.
											----> (fixado) falhas para fixar:
															----> um simples metodo com 2 parametros normais, está falhando!
															----> todos metodos com 2 parametros está falhando! 

[UtilTokens][Testes][ParametrosFuncao]:
				  -----> falha no processamento em [ExpressaoGrupos].
	(a velha ideia de sempre: falta de testes unitarios, numa estrutura de codificao bem estruturada...);

(feito)[ParserFile]:									
				  -----> funcionalidade de comentarios.

			
(feito)[Prompt], [sWrite(string, Vector)]:

		URGENTEMENTE TAMBÉM, na classe Prompt, codificar um metodo de escrita na tela, com vários elementos parâmetros.
		Só está parado porque a classe Vector, que guardaria os elementos parâmetros, não é multi-argumento. então,
		como mudar para multi-argumento? Na instanciação da classe Prompt? Mas os metodos são estáticos! 
						-----> Na classe Importer(Type), seria possível mudar o vetor para multi-argumento? Ou no [FileHeader]?
							   Ou, mudar todos vetores setando para multi-argumento?
											-----> a solução mais promissora, seria em [FileHeader],
											e adicionando um hook com a classe [Prompt], para mudar os metodos com Vector,
											em [Prompt], para multi-argumento..
											-----> ou na classe [LinguagemOrquidea], um hook depois de processamento
											de classes-base, como o [Prompt]. É mais adequado..

(feito)[Prompt]: inicializar com um construtor que carregue a biblioteca, e faz a modificação de Vector multi-argumento, e depois chamar o construtor
				em [LinguagemOrquidea], em vez de carrega via importer. Fica sem o gancho anti-design de inclusão de um método (xWrite) a ser modificado.
_________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.10:
	
(feito)[UtilTokens.Testes]:
				-----> (feito) terminar os testes de funcao sem objeto chamador.
								-----> se possivel extender o metodo de processamento, para tb no caso de funcoes do escopo da classe currente,
								o problema é o mesmo, foi codificado separadamente porque viu-se que as funcoes vinham do repositorio
								de classes, nao os headers de classe.
								-----> acertar o indice da malha de tokens, está como o indice de tokens resumidos, quando deveria ser tokens NAO resumidos.
								
				(feito)TESTES, andamento:
								----> codificado um campo em objeto para conter um metodo, se o objeto for funcao-parametro.
								----> se [ExtratoresOO], a dificuldade está em setar o metodo se o parametro for uma funcao-parametero.
				
[PaserFile][Module][Library]:
				-----> (feito) implementar a instrucao [Module], que permite incluir codigo de arquivos externos ao arquivo currente.
						
								
				-----> (verificado) verificar se a instrucao [Library] está operacional.
								----> (fixado) está com codigo, mas limitação de declaração de libraries registradas.


						----> (testes) codificado funcao de importar assemblies [.exe ou [.dll], contendo classes da biblioteca,
						mas é preciso especificar classes que se quer importar, porque todas classes, incluindo a 
						classe [program],classe [Testes], tb estão sendo importados.
								----> falha na importacao apenas da classe especificada. tvz a classe importada depende das classes que deveria nao incluir.



(feito)[Library][Testes]:
				-----> falha desconhecida está corrompendo o codigo, importa o tipo, + classes do [Program], [Testes], que nao é grave, pois a classe
				[Sound] nao depende destas classes.	BIBLIOTECAS nao IMPORTA DE ARQUIVOS .dll, APENAS .exe! A nao ser que o framework 4.8.1 nao há falha
				em importar arquivos .dll que é do framework 2.0...
								-----> fixar ou explicar, por que classes alem da classe biblioteca está importando outras classes.
											----> todas classes com codigo em Program, são incluidas. Se o Program
											tiver uma execução da classe Testes, e esta classe fazer referência a class da biblioteca,
											será incluida com tipo que a classe biblioteca depende.
											----> removendo a classe Program do repositorio de classes, temos
											todas classes da library carregadas, funcionando como uma biblioteca .NET .dll.
											O problema de bibliotecas .dll é que só aceita Frameworks 2.0,2.1,6.0,7.0,
											o que torna dificil porque o projeto está com Framework 4.8, e não há certeza
											que funcionará em todos desktops PC com SO Windows.

____________________________________________________________________________________________________________________________________________________________________
_____________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.11:

		----> (feito em projeto paralelo) pensar em como executar um programa orquidea fora do projeto. (porque na atual situação, o codigo tem que ser feito dentro do projeto,
		o que não é adequado para uma linguagem operacional).
							-----> (feito) um projeto ExecuteOrquidea, seria importar o Assembly do projeto, e por API Reflexão, executar
							um codigo de [ParserAFile], eliminando incongruência de instanciar um objeto de uma classe sem referencia
							em tempo de compilação.
							-----> (feito) um projeto CLI, contendo referencia ao projeto orquidea, foi feito.
		----> (feito) criar metodos de execução de programs orquidea dentro da classe [ParserAFile], que contem instruões de modulos e bibliiotecas importado.
		
		----> (feito) programa HelloWorld running!
_____________________________________________________________________________________________________________________________________________________________________________________
[Documento do Projeto]:

								----> uma questão pertinente é se disponibilizam o Projeto em uma .dll Framework 7.0.

		-----> EXPLICAR O PORQUE DA instrução casesOfUse, e também o porque da enfase de novos operadores, na Linguagen Orquidea... frustações passadas.
								----> instruções de bibliotecas: SoundRayLib, Arquive, como importar libraries .dll pertinente, para poder escrever programas
								orquidea com som, e processamento de arquivos.
														----> explicar o loop continuo para tocar uma musica com a biblioteca SoundRayLib.

		-----> pronto para subir para a nuvem...

___________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 08.11:

[Operador]:
		-----> (fixado) verificar URGENTEMENTE SE OS OPERADORES DE CLASSE ORQUIDEA estão sendo registrados ANTES do processo de metodos, porque os operadores são utilizados
		nos corpos do metodo.	estavam depois do processamento de metodos, o que inviabiliziaria o codigo, pois o codigo é
		processado dentro do corpo dos metodos.

[CasesOfUse]:		
		-----> (feito) acertar a sintaxe e compilacao da instrução [casesOfUse], o desejado é casos com QUALQUER TIPO DE EXPRESSAO, e a ATUAL SINTAXE,
		apenas expressao-objeto é que está sendo processado.
					----> (feito) ignorar o depurador;
					----> (feito) falha estrutural na formacao dos casesOfUse fixada: o mapeamento precisava ser atualizado com a nova notação do casesOfUse que corrige a falha estrutural.
					----> teste com 2 cases, feito, com a nova notação da instrução.
					
_______________________________________________________________________________________________________________________________________________________________________________________________		
Daily Scrum 13.11:

[Projeto]:
		----> (decisao) ante a falta de criação de um repositorio git, sendo no projeto de 2019 já estar registrado um reposidorio git, foi feito a migração para .NET 7.0,
		fica mais restrito o projeto, para Windows 11, mas a long prazo, compensa... bibliotecas .dll .NET 7.0 pode ser adicionadas para bibliotecas padrão orquidea.
		----> (feito) complementar a migração com diretorios do projeto 2019 copiados.
		
________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.11:
		
		
(feito)[Bibliotecas]:		
				----> (feito) construido biblioteca .dll .NET 7, para classe sSounds, com a biblioteca RayLib-cs.
				----> (feito) construido o CLI orquidea, para execução de programas orquidea via terrminal.
								-----> (A FAZER) nao esquecer de colocar os assemblies do projeto orquidea, no diretorio do CLI.
								
(feito)[Migracao Projeto]:
		----> fixar o projetoOrquidea, está com chamada do excecutavel nao encontrado....
					----> houve modificacoes em como os path de arquivos são instanciados.
		----> mudanças nos Assemblies .exe! há o Assembly para .exe, como .dll, que contem os dados de classes do executável.
		mudando os nomes dos Assembly do arquivo do projeto, voltou a normalidade... E também o nome do Assembly carregado
		no projeto mudou o nome, justamente porque o nome do projeto também mudou.
		
(feito)[ParserAFile]:
		----> (feito) codificar a seguinte adição: se o path da library não for encontrado no diretório onde está o .dll do projeto,
		procurar na sub-pasta [libs], acessível no diretorio do .dll do projeto. Fica melhor separar dos arquivos do projeto, das bibliotecas orquidea (feito na linguagem base).
				[Testes]: (confusao de nomes, de arquivo e nome da classe library) falha na importação da library [Sound];
								----> a importancia de testes unitarios: confusão de nome da biblioteca e path da biblioteca
								somente foi percebida com um 2o. teste, que por acaso tem o nome da biblioteca diferente do path da biblioteca...


(feito)[Prompt.sWrite]:
		----> fixar o texto com literals+ variaveis, no programa de teste: QualOSeuNome.
								-----> falha na obtencao de uma literal, com um operador + (concatenação).
												----> um continue está abreviando o processamento do literal, nao chega até o codigo para isso.
												----> falha na ultima codificação de funções-parêmtro, funções-sem objeto caller,
												que desviava o fluxo do codigo e impedia o processamento das demais funcionalidades.
												
(feito) novamente codificação do terminal CLI para execução de programas orquidea. esta com a solucao [ProjectOrquidea2023].
 
________________________________________________________________________________________________________________________________________________________________________________________________
					
		----> fixar a obtencao de nomes de libraries, se for >1, falha, porque não há divisão com separador de vírgula.
		